<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何用hexo搭建一个博客？</title>
    <url>/2023/04/15/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
    <content><![CDATA[<h5 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h5><p>最近学了大半年前端，居然没有一个自己写东西的地方，实在是令人汗颜，这不，现在咱就开始把博客搭起来。</p>
<span id="more"></span>

<h5 id="使用工具："><a href="#使用工具：" class="headerlink" title="使用工具："></a>使用工具：</h5><ul>
<li>hexo</li>
<li>node.js</li>
<li>GitHub</li>
</ul>
<h3 id="搭建之前的准备工作"><a href="#搭建之前的准备工作" class="headerlink" title="搭建之前的准备工作"></a>搭建之前的准备工作</h3><ul>
<li>下载<a href="https://nodejs.org/en">node.js</a>, 软件版本不得低于10.13</li>
<li>下载<a href="https://git-scm.com/">Git</a></li>
</ul>
<h3 id="下载hexo"><a href="#下载hexo" class="headerlink" title="下载hexo"></a>下载hexo</h3><p>下载之后，使用npm安装hexo。</p>
<ul>
<li>在PowerShell中输入以下命令：<br>  <code>$ npm install hexo</code></li>
<li>把hexo目录下的node_modules添加到环境变量，输入以下命令：  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'PATH="$PATH:./node_modules/.bin"'</span> &gt;&gt; ~/.profile</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="下载配置文件"><a href="#下载配置文件" class="headerlink" title="下载配置文件"></a>下载配置文件</h3><p>安装好hexo之后，新建一个你打算存放blog的文件夹。</p>
<ul>
<li>输入命令初始化文件夹：<code>hexo init &lt;folder&gt;</code></li>
<li>进入该文件夹：<code>cd &lt;folder&gt;</code></li>
<li>在该文件夹下下载必要的文件：<code>npm install</code></li>
</ul>
<h3 id="配置网站"><a href="#配置网站" class="headerlink" title="配置网站"></a>配置网站</h3><ul>
<li>打开博客的配置文件<code>_config.yml</code><br>  位置：<code>folder/_config.yml</code></li>
<li>修改参数：<ul>
<li>把title换成网站标题</li>
<li>author换成您自己的名字</li>
<li>language换成中文<code>zh-CN</code></li>
</ul>
</li>
</ul>
<h3 id="配置主题（以NexT为例）"><a href="#配置主题（以NexT为例）" class="headerlink" title="配置主题（以NexT为例）"></a>配置主题（以NexT为例）</h3><h4 id="下载NexT"><a href="#下载NexT" class="headerlink" title="下载NexT"></a>下载NexT</h4><ul>
<li>在<code>folder</code>文件夹下，打开git bash</li>
<li>输入以下命令：<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></tbody></table></figure>
<h4 id="配置NexT"><a href="#配置NexT" class="headerlink" title="配置NexT"></a>配置NexT</h4></li>
<li>打开站点配置文件，找到theme字段，把值更改为next</li>
</ul>
<h4 id="选择布局模型："><a href="#选择布局模型：" class="headerlink" title="选择布局模型："></a>选择布局模型：</h4><ul>
<li>打开主题配置文件</li>
<li>找到关键字Scheme, 选择你喜欢的类型，将该类型的注释去掉</li>
</ul>
<h4 id="添加标签页和分类页"><a href="#添加标签页和分类页" class="headerlink" title="添加标签页和分类页"></a>添加标签页和分类页</h4><ul>
<li>打开主题配置文件</li>
<li>搜索关键字menu</li>
<li>将tags, categories的注释去除</li>
<li>打开git bash, 输入:<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo n page tags</span><br><span class="line">$ hexo n page categories</span><br></pre></td></tr></tbody></table></figure></li>
<li>打开<code>folder/source</code>，发现其新增了tags 和 categories文件夹</li>
<li>打开tags文件夹下的index.md文件，将title值改为分类，并在尾部添加type: categories</li>
<li>categories操作同上</li>
</ul>
<h4 id="更换头像"><a href="#更换头像" class="headerlink" title="更换头像"></a>更换头像</h4><ul>
<li>打开主题配置页面，搜索avatar关键字</li>
<li>将其url改为你喜欢的头像的地址<ul>
<li>其根目录为next主题下的source文件夹</li>
</ul>
</li>
<li>旋转头像和圆形头像按需开启</li>
</ul>
<h4 id="更改社交链接"><a href="#更改社交链接" class="headerlink" title="更改社交链接"></a>更改社交链接</h4><ul>
<li>主题配置文件中搜索social关键字</li>
<li>添加weibo链接：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Weibo: 链接 || 图标（font awesome的图标，或者你自己找一个喜欢的）</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="添加友情链接"><a href="#添加友情链接" class="headerlink" title="添加友情链接"></a>添加友情链接</h4><ul>
<li>主题配置文件中搜索links</li>
<li>在links下添加你喜欢的链接<br>  -格式：<code>链接名称：链接</code></li>
</ul>
<h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><ul>
<li>git bash中输入：<code>hexo new post 文章名称</code></li>
<li>打开博客目录中posts文件夹下的md文件</li>
<li>填写title（标题），tags（标签），categories（分类）</li>
<li>在结束预览的地方添加<!--more-->，以添加<strong>阅读全文</strong>按钮</li>
</ul>
<h4 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h4><ul>
<li>主题配置中搜索reward<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true(改为true)</span><br><span class="line">  animation: true(鼠标hover有文字旋转效果)</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: 添加收款图片（根目录是source）</span><br><span class="line">  alipay: /images/alipay.png</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="开启订阅功能"><a href="#开启订阅功能" class="headerlink" title="开启订阅功能"></a>开启订阅功能</h4><ul>
<li>主题配置文件搜索subscribe<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">follow_me:</span><br><span class="line">  #Twitter: https://twitter.com/username || fab fa-twitter</span><br><span class="line">  #Telegram: https://t.me/channel_name || fab fa-telegram</span><br><span class="line">  WeChat: /images/wechat_channel.png （添加公众号图片）|| fab fa-weixin（微信图标）</span><br><span class="line">  #RSS: /atom.xml || fa fa-rss</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="添加GitHub-corner"><a href="#添加GitHub-corner" class="headerlink" title="添加GitHub corner"></a>添加GitHub corner</h4><ul>
<li>进入<a href="https://tholman.com/github-corners/">GitHub Corners</a></li>
<li>复制你喜欢的效果</li>
<li>打开主题文件下的layout文件夹，找到layout.njk文件，并打开</li>
<li>搜索headband关键字，该div之下粘贴复制的代码<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;body itemscope itemtype="http://schema.org/WebPage"{% if theme.motion.enable %} class="use-motion"{% endif %}&gt;</span><br><span class="line">  &lt;div class="headband"&gt;&lt;/div&gt;</span><br><span class="line">    复制的代码贴到这里</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="修改文章内链接样式"><a href="#修改文章内链接样式" class="headerlink" title="修改文章内链接样式"></a>修改文章内链接样式</h4><ul>
<li>主题文件夹下的source文件夹下的css文件夹下的common文件夹下的components文件夹下的post文件夹</li>
<li>打开post-body.styl文件</li>
<li>在文件的尾部添加以下代码（链接修改成蓝色，hover时改为橙色）<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>{ </span><br><span class="line">  <span class="attribute">color</span>: skyblue;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span>{</span><br><span class="line">    <span class="attribute">color</span>:orange;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="修改文章底部的tags标签"><a href="#修改文章底部的tags标签" class="headerlink" title="修改文章底部的tags标签"></a>修改文章底部的tags标签</h4><ul>
<li>默认是#标签</li>
<li>打开主题文件夹下的layout文件夹下的marco文件夹下的post.njk文件</li>
<li>搜索tags关键字，找到以下代码，将其中的#替换为<code>&lt;i class="fa-solid fa-tag"&gt;&lt;/i&gt;</code><ul>
<li>如果用font awesome的标签不显示，检查标签是否付费标签，付费标签不显示，免费的可以显示<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{%- if post.tags and post.tags.length %}</span><br><span class="line">  {%- set tag_indicate = '&lt;i class="fa fa-tag"&gt;&lt;/i&gt;' if theme.tag_icon else '把这里的#替换成你喜欢的标签' %}</span><br><span class="line">  &lt;div class="post-tags"&gt;</span><br><span class="line">    {%- for tag in post.tags.toArray() %}</span><br><span class="line">      &lt;a href="{{ url_for(tag.path) }}" rel="tag"&gt;{{ tag_indicate }} {{ tag.name }}&lt;/a&gt;</span><br><span class="line">    {%- endfor %}</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">{%- endif %}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h4 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h4><ul>
<li>在根目录运行 <code>$ npm install hexo-generator-searchdb --save</code></li>
<li>在博客配置文件添加以下代码：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></tbody></table></figure></li>
<li>主题配置文件搜索local_search, 把开关改为true<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="添加busuanzi统计功能"><a href="#添加busuanzi统计功能" class="headerlink" title="添加busuanzi统计功能"></a>添加busuanzi统计功能</h4><ul>
<li>主题配置文件搜索busuanzi, 开关改为true<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="隐藏底部驱动"><a href="#隐藏底部驱动" class="headerlink" title="隐藏底部驱动"></a>隐藏底部驱动</h4><ul>
<li>主题配置文件搜索power<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Powered by Hexo &amp; NexT</span><br><span class="line">  powered: false (改为false就不显示了)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="增加字数统计和阅读时长"><a href="#增加字数统计和阅读时长" class="headerlink" title="增加字数统计和阅读时长"></a>增加字数统计和阅读时长</h4><ul>
<li>打开git bash 运行 <code>npm install hexo-word-counter</code></li>
<li>站点配置文件中添加以下内容，中文的话wpm改成300， awl设置为2<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275 </span><br><span class="line">  suffix: "mins."</span><br></pre></td></tr></tbody></table></figure></li>
<li>主题配置文件搜索 wordcount, 开关改为true<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/next-theme/hexo-word-counter</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_total: true</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="把博客部署到GitHub上"><a href="#把博客部署到GitHub上" class="headerlink" title="把博客部署到GitHub上"></a>把博客部署到GitHub上</h4><ul>
<li>注册github账号，新建仓库，仓库名称为username.github.io</li>
<li>打开git bash，添加用户名和邮箱<ul>
<li>输入<code>git config --global user.name 'yourname'</code></li>
<li>输入<code>git config --global user.email 'youremail'</code></li>
</ul>
</li>
<li>设置密钥<ul>
<li>输入<code>ssh-keygen -t rsa -C 'youremail@example.com'</code></li>
<li>进入.ssh文件夹，打开.pub文件，复制其中内容</li>
<li>打开GitHub，找到添加ssh密钥页面，复制公钥内容，点击确定</li>
<li>打开git bash 输入<code>ssh -T git@github.com</code>验证是否配置成功</li>
</ul>
</li>
<li>编辑博客配置文件<ul>
<li>打开博客配置文件，找到deployment部分<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: GitHub仓库的ssh地址</span><br><span class="line">    branch: main</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li>部署博客<ul>
<li>打开git bash输入<code>hexo d</code></li>
<li>如果某些样式无法加载，试试清除浏览器缓存之后再加载</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么用git命令搭建一个GitHub仓库？</title>
    <url>/2023/04/15/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Git常用命令总结"><a href="#Git常用命令总结" class="headerlink" title="Git常用命令总结"></a>Git常用命令总结</h1><p>最近一直被git命令困扰，这次来写写怎么用git</p>
<span id="more"></span>

<h3 id="这是不一样的事情"><a href="#这是不一样的事情" class="headerlink" title="这是不一样的事情"></a>这是不一样的事情</h3><h5 id="这很有趣"><a href="#这很有趣" class="headerlink" title="这很有趣"></a>这很有趣</h5><p><a href="https://cn.bing.com/search?q=next%E4%B8%BB%E9%A2%98%E6%96%87%E6%A1%A3&amp;form=ANSPH1&amp;refig=25b594ca938540cfabb2307c7e96e46f&amp;pc=U531">我是链接</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL声明式编程</title>
    <url>/2023/04/15/SQL%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>SQL是声明性编程语言的一个例子。 语句不直接描述计算，而是描述某些计算的预期结果。数据库系统的查询解释器的角色是设计并执行一个计算过程来产生这样的结果。</p>
<p>这种交互与Python或Scheme的过程编程范式有本质区别。 在Python中，计算过程由程序员直接描述。 声明性语言抽象出过程细节，而专注于结果的形式。</p>
<span id="more"></span>

<p>SQL语言是标准化的，但是大多数数据库系统实现了该语言的一些自定义变体，这些变体被赋予了专有的特性。</p>
<p>union可以构造多行表，它将两个表的行组合在一起。在构造的表中使用左表的列名。行内的间距不会影响结果。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">38</span> <span class="keyword">as</span> latitude, <span class="number">122</span> <span class="keyword">as</span> longitude, "Berkeley" <span class="keyword">as</span> name <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">42</span>, <span class="number">71</span>, "Cambridge" <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">45</span>, <span class="number">93</span>, "Minneapolis";</span><br><span class="line"></span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley</span><br><span class="line"></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge</span><br><span class="line"></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis</span><br></pre></td></tr></tbody></table></figure>

<p>可以使用<mark style="background: #ABF7F7A6;">create table</mark>语句为表指定名称。虽然该语句也可以用于创建空表，但我们将重点关注为select语句定义的现有表提供名称的表单。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cities <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">38</span> <span class="keyword">as</span> latitude, <span class="number">122</span> <span class="keyword">as</span> longitude, "Berkeley" <span class="keyword">as</span> name <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">42</span>, <span class="number">71</span>, "Cambridge" <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">45</span>, <span class="number">93</span>, "Minneapolis";```</span><br><span class="line"></span><br><span class="line">一旦指定了表的名称，就可以在<span class="keyword">select</span>语句中的<span class="keyword">from</span>子句中使用该名称。使用特殊的<span class="keyword">select</span> <span class="operator">*</span>表单可以显示表的所有列。</span><br><span class="line">```<span class="keyword">SQL</span></span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cities;</span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley</span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge</span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Select语句"><a href="#Select语句" class="headerlink" title="Select语句"></a>Select语句</h3><p>一个select语句可以通过列出单行中的值来定义一个新表，或者，更常见的是，通过使用from子句投影一个现有的表：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">column</span> description] <span class="keyword">from</span> [existing <span class="keyword">table</span> name]</span><br></pre></td></tr></tbody></table></figure>
<p>结果表的列由一个以逗号分隔的表达式列表来描述，每个表达式针对现有输入表的每一行进行计算。</p>
<p>例如，我们可以创建一个两列的表，根据每个城市离伯克利的北部或南部多远来描述它。 纬度每一度向北测量60海里。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>) <span class="keyword">from</span> cities;</span><br><span class="line">Berkeley<span class="operator">|</span><span class="number">0</span></span><br><span class="line">Cambridge<span class="operator">|</span><span class="number">240</span></span><br><span class="line">Minneapolis<span class="operator">|</span><span class="number">420</span></span><br></pre></td></tr></tbody></table></figure>
<p>列描述是一种语言中的表达式，它与Python共享许多属性:中缀操作符(如+和%)，内置函数(如abs和round)，以及描述求值顺序的圆括号。 这些表达式中的名称(如上面提到的latitude)计算为被投影行的列值。</p>
<p>可选地，每个表达式后面可以跟关键字as和列名。 当为整个表指定了一个名称时，为每个列指定一个名称通常是有帮助的，以便在以后的select语句中引用它。 由简单名称描述的列将自动命名。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> distances <span class="keyword">as</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>) <span class="keyword">as</span> distance <span class="keyword">from</span> cities;</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> distance<span class="operator">/</span><span class="number">5</span>, name <span class="keyword">from</span> distances;</span><br><span class="line"><span class="number">0</span><span class="operator">|</span>Berkeley</span><br><span class="line"><span class="number">48</span><span class="operator">|</span>Cambridge</span><br><span class="line"><span class="number">84</span><span class="operator">|</span>Minneapolis</span><br></pre></td></tr></tbody></table></figure>

<p>Where子句。select语句还可以包含带有筛选表达式的where子句。这个表达式过滤被投影的行。只有过滤表达式计算为真值的行才会用于在结果表中生成一行。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cold <span class="keyword">as</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> name <span class="keyword">from</span> cities <span class="keyword">where</span> latitude <span class="operator">&gt;</span> <span class="number">43</span>;</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> name, "is cold!" <span class="keyword">from</span> cold;</span><br><span class="line">Minneapolis<span class="operator">|</span><span class="keyword">is</span> cold<span class="operator">!</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>排序子句</strong>。select语句还可以表示对结果表的排序。order子句包含一个排序表达式，该表达式将为每个未筛选的行求值。该表达式的结果值用作结果表的排序标准。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> distance, name <span class="keyword">from</span> distances <span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">-</span>distance;</span><br><span class="line"><span class="number">84</span><span class="operator">|</span>Minneapolis</span><br><span class="line"><span class="number">48</span><span class="operator">|</span>Cambridge</span><br><span class="line"><span class="number">0</span><span class="operator">|</span>Berkeley</span><br></pre></td></tr></tbody></table></figure>

<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>数据库通常包含多个表，查询可能需要包含在不同表中的信息来计算所需的结果。例如，我们可以用第二个表来描述不同城市的日平均高温。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> temps <span class="keyword">as</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> "Berkeley" <span class="keyword">as</span> city, <span class="number">68</span> <span class="keyword">as</span> temp <span class="keyword">union</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> "Chicago"         , <span class="number">59</span>         <span class="keyword">union</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> "Minneapolis"     , <span class="number">55</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>通过将多个表合并成一个表来组合数据，这是数据库系统中的基本操作。 有许多连接的方法，都是密切相关的，但我们将集中在这篇文章的一种方法。 当表被连接时，结果表为输入表中的每个行组合包含一个新行。 如果两个表被连接，左边的表有m行，右边的表有n行，那么连接的表将有m*n行。 连接在SQL中是通过select语句的from子句中用逗号分隔表名来表示的。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cities, temps;</span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley<span class="operator">|</span>Berkeley<span class="operator">|</span><span class="number">68</span></span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley<span class="operator">|</span>Chicago<span class="operator">|</span><span class="number">59</span></span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley<span class="operator">|</span>Minneapolis<span class="operator">|</span><span class="number">55</span></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge<span class="operator">|</span>Berkeley<span class="operator">|</span><span class="number">68</span></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge<span class="operator">|</span>Chicago<span class="operator">|</span><span class="number">59</span></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge<span class="operator">|</span>Minneapolis<span class="operator">|</span><span class="number">55</span></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis<span class="operator">|</span>Berkeley<span class="operator">|</span><span class="number">68</span></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis<span class="operator">|</span>Chicago<span class="operator">|</span><span class="number">59</span></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis<span class="operator">|</span>Minneapolis<span class="operator">|</span><span class="number">55</span></span><br></pre></td></tr></tbody></table></figure>

<p>连接通常伴随着一个<mark style="background: #ABF7F7A6;">where</mark>子句，该子句表示两个表之间的关系。例如，如果我们希望将数据收集到一个表中，该表允许我们关联纬度和温度，那么我们将从连接中选择在每个连接中提到相同城市的行。在cities表中，城市名称存储在名为name的列中。在temps表中，城市名称存储在名为city的列中。<mark style="background: #ABF7F7A6;">where子句可以选择连接表中这些值相等的行。</mark>在SQL中，<mark style="background: #ABF7F7A6;">用一个=符号来测试数字是否相等。</mark></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> name, latitude, temp <span class="keyword">from</span> cities, temps <span class="keyword">where</span> name <span class="operator">=</span> city;</span><br><span class="line">Berkeley<span class="operator">|</span><span class="number">38</span><span class="operator">|</span><span class="number">68</span></span><br><span class="line">Minneapolis<span class="operator">|</span><span class="number">45</span><span class="operator">|</span><span class="number">55</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们在<mark style="background: #FF5582A6;">SQL中组合表的两种方法是join和union</mark>，这使得该语言具有强大的表达能力。</p>
<h3 id="解释SQL"><a href="#解释SQL" class="headerlink" title="解释SQL"></a>解释SQL</h3><p>每个表都有自己的一个类，表中的每一行都由其表的类的实例表示。 一行在表中的每一列中有一个属性，而表是一行的序列。</p>
<p>表的类是使用Python标准库的collections包中的namedtuple函数创建的，该函数返回tuple的新子类，为tuple中的每个元素命名。</p>
<p>考虑下一节中列出的cities表。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cities <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">38</span> <span class="keyword">as</span> latitude, <span class="number">122</span> <span class="keyword">as</span> longitude, "Berkeley" <span class="keyword">as</span> name <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">42</span>, <span class="number">71</span>, "Cambridge" <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">45</span>, <span class="number">93</span>, "Minneapolis";```</span><br><span class="line"></span><br><span class="line">下面的Python语句为这个表构造了一个表示。</span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="keyword">from</span> collections import namedtuple</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> CitiesRow <span class="operator">=</span> namedtuple("Row", ["latitude", "longitude", "name"])</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> cities <span class="operator">=</span> [CitiesRow(<span class="number">38</span>, <span class="number">122</span>, "Berkeley"),</span><br><span class="line"></span><br><span class="line">CitiesRow(<span class="number">42</span>, <span class="number">71</span>, "Cambridge"),</span><br><span class="line"></span><br><span class="line">CitiesRow(<span class="number">43</span>, <span class="number">93</span>, "Minneapolis")]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> distances <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>) <span class="keyword">as</span> distance <span class="keyword">from</span> cities;</span><br><span class="line"></span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> distance<span class="operator">/</span><span class="number">5</span>, name <span class="keyword">from</span> distances;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span><span class="operator">|</span>Berkeley</span><br><span class="line"></span><br><span class="line"><span class="number">48</span><span class="operator">|</span>Cambridge</span><br><span class="line"></span><br><span class="line"><span class="number">84</span><span class="operator">|</span>Minneapolis```</span><br><span class="line"></span><br><span class="line">这个表是根据cities表的name和latitude列生成的。这个结果表可以通过在输入表的行上映射一个函数来生成，这个函数为每个CitiesRow返回一个DistancesRow。</span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> DistancesRow <span class="operator">=</span> namedtuple("Row", ["name", "distance"])</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> def <span class="keyword">select</span>(cities_row):</span><br><span class="line"></span><br><span class="line">latitude, longitude, name <span class="operator">=</span> cities_row</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> DistancesRow(name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>))</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> distances <span class="operator">=</span> list(map(<span class="keyword">select</span>, cities))</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="keyword">for</span> <span class="type">row</span> <span class="keyword">in</span> distances:</span><br><span class="line"></span><br><span class="line">print(<span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Row</span>(name<span class="operator">=</span><span class="string">'Berkeley'</span>, distance<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Row</span>(name<span class="operator">=</span><span class="string">'Cambridge'</span>, distance<span class="operator">=</span><span class="number">240</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Row</span>(name<span class="operator">=</span><span class="string">'Minneapolis'</span>, distance<span class="operator">=</span><span class="number">300</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>我们的SQL解释器的设计概括了这种方法。select语句表示为由select语句的子句构造的类select的实例</p>
<p>```SQL</p>
<blockquote>
<blockquote>
<blockquote>
<p>class Select:</p>
</blockquote>
</blockquote>
</blockquote>
<p>“””select [columns] from [tables] where [condition] order by [order].”””</p>
<p>def <strong>init</strong>(self, columns, tables, condition, order):</p>
<p>self.columns = columns</p>
<p>self.tables = tables</p>
<p>self.condition = condition</p>
<p>self.order = order</p>
<p>self.make_row = create_make_row(self.columns)</p>
<p>def execute(self, env):</p>
<p>“””Join, filter, sort, and map rows from tables to columns.”””</p>
<p>from_rows = join(self.tables, env)</p>
<p>filtered_rows = filter(self.filter, from_rows)</p>
<p>ordered_rows = self.sort(filtered_rows)</p>
<p>return map(self.make_row, ordered_rows)</p>
<p>def filter(self, row):</p>
<p>if self.condition:</p>
<p>return eval(self.condition, row)</p>
<p>else:</p>
<p>return True</p>
<p>def sort(self, rows):</p>
<p>if self.order:</p>
<p>return sorted(rows, key=lambda r: eval(self.order, r))</p>
<p>else:</p>
<p>return rows```</p>
<p>execute方法连接输入表、筛选并对结果行进行排序，然后在这些结果行上映射一个名为make_row的函数。make_row函数是通过调用create_make_row在Select构造函数中创建的，create_make_row是一个高阶函数，它为结果表创建一个新类，并定义如何将输入行投影到输出行。(这个函数的一个版本在sql中有更多的错误处理和特殊情况。)</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>可变数据</title>
    <url>/2023/04/15/%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>Identity <code>is</code> evaluates to True if both and evaluate to the same object<br>Equality <code>==</code> evaluates to True if both and evaluate to equal values Identical objects are always equal values<br>Identity is always Equality.</p>
<span id="more"></span>
<p>An immutable sequence may still change if it contains a mutable value as an element</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ([<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Mutable-Default-Arguments-are-Dangerous"><a href="#Mutable-Default-Arguments-are-Dangerous" class="headerlink" title="Mutable Default Arguments are Dangerous"></a>Mutable Default Arguments are Dangerous</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">s=[]</span>):</span><br><span class="line"><span class="meta">... </span>    s.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">t = [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>![[Pasted image 20230204165726.png]]<br>![[Pasted image 20230204170848.png]]</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">0</span>] = [<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:] = t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:<span class="number">0</span>] = [<span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:] = [<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">4</span>:] = <span class="number">4</span></span><br><span class="line">Error</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">5</span>:] = [<span class="number">55</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">55</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">5</span>] = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.pop()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">1</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">2</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> balance</span><br><span class="line">		balance = balance - amount</span><br><span class="line">		<span class="keyword">return</span> balance</span><br><span class="line">		</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw1</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">	<span class="comment"># nonlocal balance</span></span><br><span class="line">        balance = balance - amount <span class="comment"># 会报错，变量未赋值便访问</span></span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw2</span>(<span class="params">balance</span>): <span class="comment"># 不报错，但是返回值都一样</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        new_balance = balance</span><br><span class="line">        new_balance = new_balance - amount</span><br><span class="line">        <span class="keyword">return</span> new_balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw3</span>(<span class="params">balance</span>): <span class="comment"># 可变数据，无须nonlocal 即可实现nonlocal的效果</span></span><br><span class="line">    b = [balance]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        b[<span class="number">0</span>] = b[<span class="number">0</span>] - amount</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Effect</strong>: Future assignments to that name change its pre-existing binding in the first non-local frame of the current environment in which that name is bound. (对该名称的未来赋值会改变它在当前环境的第一个非本地框架中的已有的绑定，该名称在其中被绑定。)</p>
<p>Names listed in a nonlocal statement must refer to pre-existing bindings in an enclosing scope. Names listed in a nonlocal statement must not collide with pre-existing bindings in the local scope.<br>(在非本地语句中列出的名称必须是指在封闭的作用域中预先存在的绑定。<br>在非本地语句中列出的名字不能与本地作用域中预先存在的绑定相冲突。)</p>
<p>Python pre-computes which frame contains each name before executing the body of a function. Within the body of a function, all instances of a name must refer to the same frame.<br>(在执行一个函数的主体之前，Python 预先计算哪个帧包含每个名字。<br>在一个函数的主体中，一个名字的所有实例必须指向同一个框架。)</p>
<p>• Expressions are referentially transparent if substituting an expression with its value does not change the meaning of a program.<br>如果用表达式的值替换它不会改变程序的意义，那么表达式是透明的</p>
<ul>
<li>Mutation operations violate the condition of referential transparency because they do more than just return a value; they change the environment.<br>  突变操作违反了参照性透明的条件，因为它们不仅仅是返回一个值；它们改变了环境。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    x = <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">z</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> x</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> x+y+z</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = a(<span class="number">2</span>)</span><br><span class="line">total = b(<span class="number">3</span>) + b(<span class="number">4</span>) <span class="comment"># total = 22    b(3)=10</span></span><br><span class="line">total = <span class="number">10</span> + b(<span class="number">4</span>) <span class="comment"># total = 21</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面案例中，两次结果不同的原因是第一次对h(x)两次调用，导致x递增1。用10替换<code>b(3)</code>之后，只调用了<code>h(x)</code>一次，<code>x</code>只递增了一次</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">6</span>)</span><br><span class="line">? Nothing</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = lst.pop(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = lst, lst[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> lst</span><br><span class="line">? <span class="literal">True</span></span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == lst</span><br><span class="line">? <span class="literal">True</span></span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> lst</span><br><span class="line">? <span class="literal">False</span></span><br><span class="line">-- OK! --</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>报错信息</title>
    <url>/2023/04/15/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>编程时，学会读取报错信息也是必要的。</p>
<span id="more"></span>

<p>Instance: </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Traceback (most recent call last): </span><br><span class="line">	File <span class="string">"&lt;pyshell#29&gt;"</span>, line <span class="number">3</span> <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">	result = buggy(<span class="number">5</span>) </span><br><span class="line">File <span class="string">"&lt;pyshell#29&gt;"</span>, line <span class="number">5</span> <span class="keyword">in</span> buggy </span><br><span class="line">	<span class="keyword">return</span> f + x </span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">'function'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="Format"><a href="#Format" class="headerlink" title="Format:"></a>Format:</h5><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">File <span class="string">"&lt;file name&gt;"</span>, line &lt;number&gt;, <span class="keyword">in</span> &lt;function&gt;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>  <strong>File name</strong>: the name of the file that contains the problem.</li>
<li>  <strong>Number</strong>: the line number in the file that caused the problem, or the line number that contains the next function call</li>
<li>  <strong>Function</strong>: the name of the function in which the line can be found.<br>The&nbsp;<strong>second</strong>&nbsp;line in the pair (it’s indented farther in than the first) displays the actual line of code that makes the&nbsp;<em>next</em>&nbsp;function call. This gives you a quick look at what arguments were passed into the function, in what context the function was being used, etc.<br>Finally, remember that the traceback is organized with the “<strong>most recent call last.</strong>“</li>
</ul>
<h3 id="Error-Messages"><a href="#Error-Messages" class="headerlink" title="Error Messages"></a>Error Messages</h3><ul>
<li>The very last line in the traceback message is the error statement. An&nbsp;<em>error statement</em>&nbsp;has the following format:<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;error <span class="built_in">type</span>&gt;: &lt;error message&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li>  <strong>Error type</strong>: the type of error that was caused (e.g.&nbsp;<code>SyntaxError</code>,&nbsp;<code>TypeError</code>). These are usually <strong>descriptive enough</strong> to help you narrow down your search for the cause of error.</li>
<li>  <strong>Error message</strong>: a <strong>more detailed description</strong> of exactly what caused the error. Different error types produce different error messages.</li>
</ul>
<h3 id="Debugging-Techniques"><a href="#Debugging-Techniques" class="headerlink" title="Debugging Techniques"></a>Debugging Techniques</h3><h4 id="Running-doctests"><a href="#Running-doctests" class="headerlink" title="Running doctests"></a>Running doctests</h4><p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>): </span><br><span class="line">	<span class="string">"""A random function. </span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	 &gt;&gt;&gt;foo(4) </span></span><br><span class="line"><span class="string">	 4 </span></span><br><span class="line"><span class="string">	 &gt;&gt;&gt; foo(5) </span></span><br><span class="line"><span class="string">	 5  </span></span><br><span class="line"><span class="string">	 """</span></span><br></pre></td></tr></tbody></table></figure>
<p>The lines in the docstring that look like interpreter outputs are the&nbsp;<strong>doctests</strong>. To run them, go to your terminal and type:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></tbody></table></figure>
<p>This effectively loads your file into the Python interpreter, and checks to see if each doctest input (e.g.&nbsp;<code>foo(4)</code>) is the same as the specified output (e.g.&nbsp;<code>4</code>). If it isn’t, a message will tell you which doctests you failed.</p>
<p>The command line tool has a&nbsp;<code>-v</code>&nbsp;option that stands for&nbsp;<em>verbose</em>.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br></pre></td></tr></tbody></table></figure>
<p>In addition to telling you which doctests you failed, it will also ==tell you which doctests passed==.</p>
<h4 id="Writing-your-own-tests"><a href="#Writing-your-own-tests" class="headerlink" title="Writing your own tests"></a>Writing your own tests</h4><p>Some advice in writing tests:</p>
<ul>
<li>  <strong>Write some tests before you write code</strong>: this is called test-driven development. Writing down how you expect the function to behave first – this can guide you when writing the actual code.</li>
<li>  <strong>Write more tests after you write code</strong>: once you are sure your code passes the initial doctests, write some more tests to take care of edge cases.</li>
<li>  <strong>Test edge cases</strong>: make sure your code works for all special cases.</li>
</ul>
<h4 id="Using-print-statements"><a href="#Using-print-statements" class="headerlink" title="Using&nbsp;print&nbsp;statements"></a>Using&nbsp;<code>print</code>&nbsp;statements</h4><p>Once the doctests tell you where the error is, you have to figure what went wrong. If the doctest gave you a traceback message, look at what&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61a/fa20/articles/debugging.html#error-types">type of error</a>&nbsp;it is to help narrow your search. Also check that you aren’t making any&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61a/fa20/articles/debugging.html#common-bugs">common mistakes</a>.</p>
<p>When you first learn how to program, it can be hard to spot bugs in your code. One common practice is to add&nbsp;<code>print</code>&nbsp;statements.</p>
<p>Some advice:</p>
<ul>
<li>  Don’t just print out a variable – ==add some sort of message to make it easier for you to read:==<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tmp) <span class="comment"># harder to keep track </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'DEBUG: tmp was this:'</span>, tmp) <span class="comment"># easier</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>  Use&nbsp;<code>print</code>&nbsp;statements to view the results of function calls (i.e. after function calls).</li>
<li>  Use&nbsp;<code>print</code>&nbsp;statements at the end of a&nbsp;<code>while</code>&nbsp;loop to view the state of the counter variables after each iteration:<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> i &lt; n: </span><br><span class="line">	i += func(i) </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">'DEBUG: i is'</span>, i)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="Long-term-debugging"><a href="#Long-term-debugging" class="headerlink" title="Long-term debugging"></a>Long-term debugging</h5><p>The&nbsp;<code>print</code>&nbsp;statements described above are meant for <em><strong>quick debugging of one-time errors</strong></em> – after figuring out the error, you would remove all the&nbsp;<code>print</code>&nbsp;statements.</p>
<p>However, sometimes we would like to leave the debugging code if we need to periodically test our file. It can get kind of annoying if every time we run our file, debugging messages pop up. One way to avoid this is to use a global&nbsp;<code>debug</code>&nbsp;variable:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">debug = <span class="literal">True</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">n</span>): </span><br><span class="line">	i = <span class="number">0</span> </span><br><span class="line">	<span class="keyword">while</span> i &lt; n: </span><br><span class="line">		i += func(i) </span><br><span class="line">	<span class="keyword">if</span> debug: </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">'DEBUG: i is'</span>, i)</span><br></pre></td></tr></tbody></table></figure>
<p>Now, whenever we want to do some debugging, we can set the global&nbsp;<code>debug</code>&nbsp;variable to&nbsp;<code>True</code>, and ==when we don’t want to see any debugging input, we can turn it to==&nbsp;<code>False</code>&nbsp;(such a variable is called a <em><strong>“flag”</strong></em>).</p>
<h4 id="Interactive-Debugging"><a href="#Interactive-Debugging" class="headerlink" title="Interactive Debugging"></a>Interactive Debugging</h4><p>One way a lot of programmers like to investigate their code is by use of an interactive <strong>REPL</strong>.. That is, a terminal where you can directly run functions and inspect their outputs.<br>Typically, to accomplish this, you can run</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></tbody></table></figure>
<p>and one then has a session of python where all the definitions of&nbsp;<code>file.py</code>&nbsp;have already been executed.<br>If you are using the&nbsp;<code>ok</code>&nbsp;autograder, it has a specific tool that enables you to jump into the middle of a failing test case. Just run</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python ok -q &lt;question name&gt; -i</span><br></pre></td></tr></tbody></table></figure>
<p>and if you have a failing test case for that question, the setup code and doctest will be printed on the screen and run, and you will then have access to a terminal where you can execute commands related to the program.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python ok -q &lt;question name&gt; --trace</span><br></pre></td></tr></tbody></table></figure>
<p>and a browser window should open up with your code.</p>
<h4 id="Using-assert-statements"><a href="#Using-assert-statements" class="headerlink" title="Using&nbsp;assert&nbsp;statements"></a>Using&nbsp;<code>assert</code>&nbsp;statements</h4><p>A key principle in software development is tha==<strong>t it is generally better for code to crash than produce an incorrect result,</strong>== and having asserts in your code makes it far more likely that your code will crash if it has a bug in it.</p>
<h3 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h3><h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><ul>
<li>  <strong>Cause</strong>: code syntax mistake</li>
<li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">  File <span class="string">"file name"</span>, line number</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incorrect</span>(<span class="params">f</span>)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure></li>
<li>  <strong>Solution</strong>: the&nbsp;<code>^</code>&nbsp;symbol points to the code that contains invalid syntax. <mark style="background: #FF5582A6;">The error message doesn’t tell you&nbsp;<em>what</em>&nbsp;is wrong, but it does tell you&nbsp;<em>where</em>.</mark></li>
<li>  <strong>Notes</strong>: Python will check for&nbsp;<code>SyntaxErrors</code>&nbsp;<mark style="background: #FF5582A6;">before executing any code</mark>. This is different from other errors, which are only raised during runtime</li>
</ul>
<h4 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a><code>IndentationError</code></h4><ul>
<li>  <strong>Cause</strong>: improper indentation</li>
<li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">  File <span class="string">"file name"</span>, line number</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'improper indentation'</span>)</span><br><span class="line">IndentationError: unindent does <span class="keyword">not</span> <span class="keyword">match</span> <span class="built_in">any</span> outer indentation level</span><br></pre></td></tr></tbody></table></figure></li>
<li>  <strong>Solution</strong>: The line that is improperly indented is displayed. ==Simply re-indent it==.</li>
<li>  <strong>Notes</strong>: If you are inconsistent with tabs and spaces, Python will raise one of these. <strong>Make sure you use spaces!</strong> (It’s just less of a headache in general in Python to use spaces and all cs61a content uses spaces).</li>
</ul>
<hr>
<h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a><code>TypeError</code></h3><ul>
<li><strong>Cause 1</strong>:<ul>
<li>  ==Invalid operand types== for primitive operators. You are probably trying to add/subract/multiply/divide incompatible types.</li>
<li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">'function'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><strong>Cause 2</strong>:<ul>
<li>  Using ==non-function objects== in function calls.</li>
<li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'int'</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><strong>Cause 3</strong>:<ul>
<li>  Passing an incorrect number of arguments to a function.</li>
<li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected <span class="number">2</span> arguments, got <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="NameError"><a href="#NameError" class="headerlink" title="NameError"></a><code>NameError</code></h3><ul>
<li><p>  <strong>Cause</strong>: variable not assigned(赋值) to anything OR it doesn’t exist. ==This includes function names==.</p>
</li>
<li><p><strong>Example</strong>:</p>
  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line number</span><br><span class="line">  y = x + <span class="number">3</span></span><br><span class="line">NameError: <span class="keyword">global</span> name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>  <strong>Solution</strong>: Make sure you are <strong>initializing the variable</strong> (i.e. assigning the variable to a value) before you use it.</p>
</li>
<li><p>  <strong>Notes</strong>: The reason the error message says “global name” is because Python will start searching for the variable from a function’s local frame. If the variable is not found there, Python will keep searching the parent frames until it reaches the global frame. If it still can’t find the variable, Python raises the error.</p>
</li>
</ul>
<h3 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a><code>IndexError</code></h3><ul>
<li>  <strong>Cause</strong>: trying to index(索引) a sequence（序列） (e.g. a tuple（元组）, list, string) with a number that exceeds（超过，胜过） the size of the sequence.</li>
<li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line number</span><br><span class="line">  x[<span class="number">100</span>]</span><br><span class="line">IndexError: <span class="built_in">tuple</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>  <strong>Solution</strong>: Make sure the index is within the bounds(边界) of the sequence. If you’re using a variable as an index (e.g.&nbsp;<code>seq[x]</code>, make sure the variable is assigned to a proper index.</li>
</ul>
<h2 id="Common-Bugs"><a href="#Common-Bugs" class="headerlink" title="Common Bugs"></a>Common Bugs</h2><h3 id="Spelling"><a href="#Spelling" class="headerlink" title="Spelling"></a>Spelling</h3><p>Python is&nbsp;<em><strong>case sensitive</strong></em>. The variable&nbsp;<code>hello</code>&nbsp;is not the same as&nbsp;<code>Hello</code>&nbsp;or&nbsp;<code>hello</code>&nbsp;or&nbsp;<code>helo</code>. This will usually show up as a&nbsp;<code>NameError</code>, but sometimes misspelled variables will actually have been defined. In that case, it can be difficult to find errors, and it is never gratifying to discover it’s just a spelling mistake.</p>
<h3 id="Missing-Parentheses"><a href="#Missing-Parentheses" class="headerlink" title="Missing Parentheses"></a>Missing Parentheses</h3><p>A common bug is to leave off the closing parenthesis. This will show up as a&nbsp;<code>SyntaxError</code>. Consider the following code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">return</span> foo(bar()   <span class="comment"># missing a parenthesis here</span></span><br><span class="line"></span><br><span class="line">fun()</span><br></pre></td></tr></tbody></table></figure>

<p>==Python will raise a&nbsp;<code>SyntaxError</code>, but will point to the line&nbsp;<em>after</em>&nbsp;the missing parenthesis:==</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line <span class="string">"number"</span></span><br><span class="line">    fun()</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure>

<p>In general, if Python points a&nbsp;<code>SyntaxError</code>&nbsp;to a seemingly correct line, you are probably forgetting a parenthesis somewhere.</p>
<h3 id="Missing-close-quotes（引号）"><a href="#Missing-close-quotes（引号）" class="headerlink" title="Missing close quotes（引号）"></a>Missing close quotes（引号）</h3><p>This is similar to the previous bug, but much easier to catch. Python will actually tell you the line that is missing the <strong>quote</strong>:(引号)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line <span class="string">"number"</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi</span></span><br><span class="line"><span class="string">           ^</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>EOL</code>&nbsp;stands for “<strong>==End of Line==</strong>.”</p>
<h3 id="vs"><a href="#vs" class="headerlink" title="=&nbsp;vs.&nbsp;=="></a><code>=</code>&nbsp;vs.&nbsp;<code>==</code></h3><p>The single equal sign&nbsp;<code>=</code>&nbsp;is used for&nbsp;<em>assignment</em>; the double equal sign&nbsp;<code>==</code>&nbsp;is used for testing equivalence. The most common error of this form is something like:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x = <span class="number">3</span>:</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Infinite-Loops"><a href="#Infinite-Loops" class="headerlink" title="Infinite Loops"></a>Infinite Loops</h3><p>Infinite loops are often caused by&nbsp;<code>while</code>&nbsp;loops whose conditions never change. For example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(i)</span><br></pre></td></tr></tbody></table></figure>

<p>Sometimes you might have incremented the wrong counter:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">i, n = 0, 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(i)</span><br><span class="line">    n += 1</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Off-by-one-errors"><a href="#Off-by-one-errors" class="headerlink" title="Off-by-one errors"></a>Off-by-one errors</h3><p>Sometimes a&nbsp;<code>while</code>&nbsp;loop or recursive function might stop one iteration too short. Here, it’s best to walk through the iteration/recursion to see what number the loop stops at.</p>
]]></content>
      <categories>
        <category>BugFix</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
        <tag>BugFix</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制</title>
    <url>/2023/04/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p><em>控制语句</em>&nbsp;（control statement）将赋予我们这种能力。它们是根据逻辑比较的结果控制程序执行流程的语句。<br>语句（statement）与我们目前研究过的表达式有着根本的不同。他们没有值（value）。执行控制语句决定了解释器接下来应该做什么，而不是计算某些东西。</p>
<span id="more"></span>

<h4 id="Statement（语句）"><a href="#Statement（语句）" class="headerlink" title="Statement（语句）"></a>Statement（语句）</h4><p>我们已经看到了三种语句：赋值（assignment）、def和&nbsp;return语句。这些 Python 代码行本身并不是表达式，尽管它们都包含表达式作为组件。</p>
<p>语句不是被评估（evaluated），而是被==执行==。<strong>每个语句都描述了对解释器状态的一些更改，并且执行语句会应用该更改</strong>。正如我们在<code>return</code>和赋值语句中看到的那样，==<strong>执行语句可能涉及评估其中包含的子表达式</strong>==。</p>
<p>表达式也可以作为语句执行，在这种情况下，它们==会被求值，但它们的值会被丢弃。==执行纯函数没有效果，但执行非纯函数会因为函数应用而产生效果。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">square</span> ( x ): </span><br><span class="line">		mul ( x , x ) <span class="comment"># 注意！此调用不返回值。</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个例子是有效的 Python，但可能不是预期的。函数体由一个表达式组成。一个表达式本身是一个有效的语句，但该语句的效果是调用了<code>mul</code>函数，结果被丢弃。如果你想对表达式的结果做些什么，你需要这样说：你可以用==赋值语句存储它==或用 <code>return </code>语句==返回==它：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">square</span> ( x ):</span><br><span class="line">		<span class="keyword">return</span> mul ( x , x )</span><br></pre></td></tr></tbody></table></figure>
<p>有时，当调用像<code>print</code>这样的<mark style="background: #FF5582A6;">非纯函数</mark>时，拥有一个主体是表达式的函数确实有意义。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">print_square</span> ( x ):</span><br><span class="line">		<span class="built_in">print</span>(square( x ))</span><br></pre></td></tr></tbody></table></figure>
<p>Python 解释器的工作是执行由语句组成的程序。然而，许多有趣的计算工作都来自对表达式的求值。语句控制程序中不同表达式之间的关系以及它们的结果会发生什么。(Statements govern the relationship among different expressions in a program and what happens to their results.)</p>
<h4 id="Compound-Statements（复合语句）"><a href="#Compound-Statements（复合语句）" class="headerlink" title="Compound Statements（复合语句）"></a>Compound Statements（复合语句）</h4><p>通常，Python 代码是一系列语句。<strong>简单语句是不以冒号结尾的单行</strong>。之所以称为==复合语句，是因为它由其他语句（简单语句和复合语句）组成==。复合语句通常跨越多行，并以单行标题开头，以冒号结尾，冒号标识语句的类型。标题和缩进的语句组(intended suite)一起称为子句。复合语句由一个或多个子句组成：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">	&lt;statement&gt;</span><br><span class="line">	&lt;statement&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;separating header&gt;:</span><br><span class="line">	&lt;statement&gt;</span><br><span class="line">	&lt;statement&gt;</span><br><span class="line">	...</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>  表达式、返回语句和赋值语句都是简单的语句。</li>
<li> <code>def</code>语句是复合语句。<code>def</code> header后面的suite&nbsp;定义了函数体。<br>Specialized evaluation rules for each kind of header dictate when and if the statements in its suite are executed.<br>We say that the ==header controls its suite==.<br>例如，在def语句的情况下，我们看到 return 表达式不会立即求值，而是存储起来以供最终调用定义的函数时使用。</li>
</ul>
<p>我们现在也可以理解多行程序了。<br>To execute a sequence of statements, execute the first statement. If that statement does not redirect control, then proceed（继续） to execute the rest of the sequence of statements, if any remain.<br>This definition exposes the essential structure of a recursively(递归地) defined&nbsp;<em>sequence</em>: a sequence can be decomposed into its first element and the rest of its elements. The “rest” of a sequence of statements is itself a sequence of statements! Thus, we can recursively apply this execution rule. This view of sequences as recursive data structures will appear again in later chapters.<br>The important consequence of this rule is that statements are executed in order, but later statements may never be reached, because of redirected control.</p>
<p><strong>实用指南。</strong> 缩进套件时，所有行必须以相同的方式缩进相同的量（<strong>使用空格，而不是制表符</strong>）。缩进的任何变化都会导致错误。</p>
<h4 id="Defining-Functions-II-Local-Assignment（局部赋值）"><a href="#Defining-Functions-II-Local-Assignment（局部赋值）" class="headerlink" title="Defining Functions II: Local Assignment（局部赋值）"></a>Defining Functions II: Local Assignment（局部赋值）</h4><p>每当应用用户定义的函数时，其定义套件中的子句序列将在本地环境中执行——该环境以通过调用该函数创建的本地框架开始。return语句重定向控制：每当执行第一个return语句&nbsp;时，函数应用程序终止，&nbsp;return表达式的值是被应用函数的返回值。<br>赋值语句可以出现在函数体内。</p>
<p>赋值语句的作用是将名称绑定到&nbsp;当前环境的第一帧中的值（The effect of an assignment statement is to bind a name to a value in the first frame of the current environment.）<br>因此，函数体内的赋值语句不会影响全局框架（As a consequence, assignment statements within a function body cannot affect the global frame.）。函数只能操纵其本地环境这一事实对于创建==<em>模块化</em>==程序至关重要，在模块化程序中，纯函数仅通过它们获取和返回的值进行交互。（The fact that functions can only manipulate their local environment is critical to creating modular programs, in which pure functions interact only via the values they take and return.）</p>
<p>So far, local assignment hasn’t increased the expressive power of our function definitions. It will do so, when combined with other control statements. In addition, local assignment also plays a critical role in clarifying the meaning of complex expressions by assigning names to intermediate quantities.</p>
<h4 id="Conditional-Statements-条件控制"><a href="#Conditional-Statements-条件控制" class="headerlink" title="Conditional Statements 条件控制"></a>Conditional Statements 条件控制</h4><p><strong>Conditional statements</strong>. A conditional statement in Python consists of a series of headers and suites: a required&nbsp;if&nbsp;clause, an optional sequence of&nbsp;elif&nbsp;clauses, and finally an optional&nbsp;else&nbsp;clause:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>When executing a conditional statement, each clause is considered in order. The computational process of executing a conditional clause follows.</p>
<ol>
<li> Evaluate the header’s expression.</li>
<li> If it is a true value, execute the suite. Then, skip over all subsequent clauses in the conditional statement.</li>
</ol>
<p>If the&nbsp;<code>else</code>&nbsp;clause is reached (which only happens if all&nbsp;<code>if&nbsp;</code>and<code>&nbsp;elif&nbsp;</code>expressions evaluate to false values), its suite is executed.</p>
<p><strong>Boolean contexts</strong>. Above, the execution procedures mention “a false value” and “a true value.” The expressions inside the header statements of conditional blocks are said to be in&nbsp;<em>boolean contexts</em>: their truth values matter to control flow, but otherwise their values are not assigned or returned. Python includes several false values, including <code>0</code>,&nbsp;<code>None</code>, and the&nbsp;<em>boolean</em>&nbsp;value&nbsp;<code>False</code>. All other numbers are true values. In Chapter 2, we will see that <strong>every built-in kind of data in Python has both true and false values.</strong></p>
<p><strong>Boolean values</strong>. Python has two boolean values, called<code>&nbsp;True</code>&nbsp;and<code>&nbsp;False</code>. Boolean values represent truth values in logical expressions. The built-in comparison operations,<code>&nbsp;&gt;, &lt;, &gt;=, &lt;=, ==, !=, </code>return these values.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &lt; <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt;= <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>第二个例子读作“5 大于等于 5”，对应于operator模块中的函数<code>ge</code> (greater equal) 。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == -<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>This final example reads “0 equals -0”, and corresponds to&nbsp;eq&nbsp;in the&nbsp;operator&nbsp;module. Notice that Python distinguishes assignment (<code>=</code>) from equality comparison (<code>==</code>), a convention shared across many programming languages.</p>
<p><strong>Boolean operators</strong>. Three basic logical operators are also built into Python:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>逻辑表达式有相应的求值过程。这些过程利用了这样一个事实，即逻辑表达式的真值有时可以在不评估其所有子表达式的情况下确定，这一特性称为&nbsp;<em>短路</em>(short-circuiting)。</p>
<p>评估表达式<code>&lt;left&gt; and &lt;right&gt;</code>：</p>
<ul>
<li>计算子表达式<code>&lt;left&gt;</code>。</li>
<li>如果结果为假值v，则表达式的计算结果为v。</li>
<li>否则，表达式的计算结果为子表达式<code>&nbsp;&lt;right&gt;</code>的值。</li>
</ul>
<p>评估表达式 <code>&lt;left&gt; or &lt;right&gt;</code>：</p>
<ol>
<li> 计算子表达式<code>&lt;left&gt;</code>。</li>
<li> 如果结果为真值v，则表达式的计算结果为v。</li>
<li> 否则，表达式的计算结果为子表达式<code>&nbsp;&lt;right&gt;</code>的值。</li>
</ol>
<p>评估表达式 <code>not &lt;exp&gt;</code>：</p>
<ol>
<li> 评估<code>&lt;exp&gt;</code>&nbsp;;&nbsp;如果结果为假值，则值为<code>True </code>，否则为<code>False</code>。</li>
</ol>
<p>这些值、规则和运算符为我们提供了一种组合比较结果的方法。执行比较并返回布尔值的函数通常以<code>is</code>开头，后面不跟下划线（例如<code>isfinite</code>、<code>&nbsp;isdigit</code>、<code>isinstance</code>等）。【These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with&nbsp;is, not followed by an underscore (e.g.,&nbsp;isfinite,&nbsp;isdigit,&nbsp;isinstance, etc.).】</p>
<h4 id="Iteration-迭代"><a href="#Iteration-迭代" class="headerlink" title="Iteration 迭代"></a>Iteration 迭代</h4><p>一个函数可以被多次应用，尽管它只被定义一次。迭代控制结构是另一种多次执行相同语句的机制。<br>考虑斐波那契数列，其中每个数都是前两个数的和：<br><code>0, 1, 1, 2, 3, 5, 8, 13, 21, ...</code><br>每个值都是通过重复应用 s<code>um-previous-two </code>规则构建的。第一个和第二个固定为 0 和 1。例如，第八个斐波那契数是 13。</p>
<p>我们可以使用<code>while</code>语句来枚举<code>n </code>个斐波那契数列。我们需要跟踪我们创建了多少个值 (<code>&nbsp;k</code>&nbsp;)，以及第<code> k</code> 个值 (&nbsp;<code>curr</code>&nbsp;) 及其前身 (&nbsp;<code>pred&nbsp;</code>)。单步执行此函数并观察斐波那契数如何一个一个地演化，绑定到<code>curr</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span>&nbsp;<span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"""Compute&nbsp;the&nbsp;nth&nbsp;Fibonacci&nbsp;number,&nbsp;for&nbsp;n&nbsp;&gt;=&nbsp;2."""</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;pred,&nbsp;curr&nbsp;=&nbsp;<span class="number">0</span>,&nbsp;<span class="number">1</span>&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Fibonacci&nbsp;numbers&nbsp;1&nbsp;and&nbsp;2</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;<span class="number">2</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Which&nbsp;Fib&nbsp;number&nbsp;is&nbsp;curr?</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;k&nbsp;&lt;&nbsp;n:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pred,&nbsp;curr&nbsp;=&nbsp;curr,&nbsp;pred&nbsp;+&nbsp;curr</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;k&nbsp;+&nbsp;<span class="number">1</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;curr</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span class="line">result&nbsp;=&nbsp;fib(<span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>请记住，逗号分隔赋值语句中的多个名称和值。该行：<br><code>pred，curr = curr，pred + curr</code><br>具有将名称<code>pred</code>重新绑定到<code>curr</code>的值的效果，同时将 <code>curr</code> 重新绑定到<code>pred + curr</code>的值。<code>=</code>==右侧的所有表达式都在重新绑定发生之前进行计算==。<br>这种事件顺序——<strong>在更新左侧的任何绑定之前评估<code>=</code>右侧的所有内容</strong>——对于此函数的正确性至关重要。</p>
<p>A&nbsp;while&nbsp;clause contains a header expression followed by a suite:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expression&gt;:</span><br><span class="line">	&lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To execute a&nbsp;while&nbsp;clause:</p>
<ol>
<li> Evaluate the header’s expression.</li>
<li> If it is a true value, execute the suite, then return to step 1.</li>
</ol>
<p>In step 2, the entire suite of the&nbsp;while&nbsp;clause is executed before the header expression is evaluated again.</p>
<p>In order to prevent the suite of a&nbsp;while&nbsp;clause from being executed indefinitely, the suite should always change some binding in each pass.</p>
<p>A&nbsp;while&nbsp;statement that does not terminate is called an infinite loop. Press&nbsp;<control>-C&nbsp;to force Python to stop looping.</control></p>
<h4 id="Testing-测试函数"><a href="#Testing-测试函数" class="headerlink" title="Testing 测试函数"></a>Testing 测试函数</h4><p>_测试_函数（testing function）是验证函数的行为是否符合预期的行为。我们的函数语言现在已经足够复杂，我们需要开始测试我们的实现。<br>A&nbsp;<em>test</em>&nbsp;is a mechanism for systematically performing this verification. Tests typically take the form of another function that contains one or more sample calls to the function being tested. The returned value is then verified against an expected result. Unlike most functions, which are meant to be general, tests involve selecting and validating calls with specific argument values. Tests also serve as documentation: they demonstrate how to call a function and what argument values are appropriate.</p>
<p><strong>Assertions.</strong>&nbsp;Programmers use&nbsp;assert&nbsp;statements to verify expectations, such as the output of a function being tested. An&nbsp;assert&nbsp;statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">'The 8th Fibonacci number should be 13'</span></span><br></pre></td></tr></tbody></table></figure>
<p>当被断言的表达式的计算结果为真值时，执行断言语句无效。当它是假值时，断言会导致停止执行的错误。</p>
<p>fib的测试函数应该测试几个参数，包括n的极值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">fib_test</span> (): </span><br><span class="line"><span class="keyword">assert</span> fib ( <span class="number">2</span> ) == <span class="number">1</span> , <span class="string">'第二个斐波那契数应该是 1'</span> </span><br><span class="line"><span class="keyword">assert</span> fib ( <span class="number">3</span> ) == <span class="number">1</span> , <span class="string">'第三个斐波那契数应该是 1 '</span> </span><br><span class="line"><span class="keyword">assert</span> fib ( <span class="number">50</span> ) = = <span class="number">7778742049</span> , <span class="string">'第 50 个斐波那契数列错误'</span></span><br></pre></td></tr></tbody></table></figure>
<p>当在文件中而不是直接在解释器中编写 Python 时，测试通常在同一个文件或后缀&nbsp;为 <code>_test.py</code>的相邻文件中编写。</p>
<p><strong>Doctests</strong><br>Python 提供了一种方便的方法，可以将简单的测试直接放在函数的<strong>文档字符串</strong> (docstring)中。==文档字符串的第一行应该包含函数的单行描述==，==然后是一个空行==。参数和行为的详细描述可能如下。此外，文档字符串可能包含调用该函数的示例交互式会话：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>): </span><br><span class="line">        <span class="string">"""返回前n个自然数的和。</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10) </span></span><br><span class="line"><span class="string">		55 			</span></span><br><span class="line"><span class="string">		&gt;&gt;&gt;sum_naturals(100) </span></span><br><span class="line"><span class="string">		5050 """</span></span><br><span class="line">		total, k = <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line">		<span class="keyword">while</span> k &lt;= n: </span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>
<p>Then, the interaction can be verified via the&nbsp;<a href="http://docs.python.org/py3k/library/doctest.html">doctest module</a>. Below, the&nbsp;globals&nbsp;function returns a representation of the global environment, which the interpreter needs in order to evaluate expressions. 然后，可以通过<a href="http://docs.python.org/py3k/library/doctest.html">doctest 模块</a>验证交互。下面，&nbsp;globals函数返回全局环境的表示，解释器需要它来评估表达式。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>为了仅验证单个函数的 doctest 交互，我们使用&nbsp;名为run_docstring_examples的doctest函数。这个函数（不幸的是）调用起来有点复杂。它的第一个参数是要测试的函数。第二个应该始终是表达式&nbsp;globals()的结果，这是一个返回全局环境的内置函数。第三个参数为True表示我们想要“详细”输出：所有测试运行的目录。</p>
<pre><code class="python">&gt;&gt;&gt; from  doctest  import  run_docstring_examples 
&gt;&gt;&gt; run_docstring_examples ( sum_naturals ,  globals (),  True )
在 NoName 中寻找测试
Trying: 
sum_naturals ( 10 ) Expecting: 55 ok Trying: sum_naturals ( 100 ) Expecting: 5050 ok```
</code></pre>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>设计函数</title>
    <url>/2023/04/15/%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>好的函数的品质都强化了函数是抽象的想法。</p>
<span id="more"></span>

<ul>
<li>  每个功能应该<strong>只有一个</strong>工作。该工作应该可以用一个简短的名称来识别，并且可以在一行文本中进行描述。按顺序执行多个作业的函数应分为多个函数。</li>
<li>  ==_<strong>不要重复自己</strong>==_是软件工程的核心原则。所谓的 DRY 原则指出，多个代码片段不应描述冗余逻辑。相反，==该逻辑应该实现一次，命名并多次应用==。如果您发现自己正在复制和粘贴一段代码，那么您可能已经找到了进行功能抽象的机会。</li>
<li>  函数应该被一般地（genrally）定义。平方不在 Python 库中正是因为它是pow函数的特例，pow将数字计算为任意幂。</li>
</ul>
<p>函数定义通常包括描述函数的文档，称为_==docstring==_，它==必须与函数体一起缩进==。文档字符串通常是==三引号==。第一行在一行中描述了函数的工作。以下几行可以描述参数并阐明函数的行为：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">        <span class="string">"""Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann's constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure>
<p>When you call&nbsp;<code>help</code>&nbsp;with the name of a function as an argument, you see its docstring (type&nbsp;<code>q</code>&nbsp;to quit Python help).</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></tbody></table></figure>
<p>代码只写一次，但往往要读很多遍。<br>The Python docs include&nbsp;<a href="http://www.python.org/dev/peps/pep-0257/">docstring guidelines</a>&nbsp;that maintain consistency across different Python projects.</p>
<p><strong>Comments</strong>. Comments in Python can be attached to the end of a line following the&nbsp;#&nbsp;symbol. For example, the comment&nbsp;Boltzmann’s constant&nbsp;above describes&nbsp;k. ==These comments don’t ever appear in Python’s&nbsp;help, and they are ignored by the interpreter.== They exist for humans alone.</p>
<p>A consequence of defining general functions is the introduction of additional arguments. ==Functions with many arguments can be awkward to call and difficult to read.==<br>In Python, we can provide ==default values== for the arguments of a function. When calling that function, arguments with ==default values are optional==. ==If they are not provided, then the default value is bound to the formal parameter(形式参数) name instead.== For instance, if an application commonly computes pressure for one mole of particles, this value can be provided as a default:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n=<span class="number">6.022e23</span></span>):</span><br><span class="line">        <span class="string">"""Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas (default: one mole)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann's constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure>

<p>The&nbsp;<code>=&nbsp;</code>symbol means two different things in this example, depending on the context in which it is used. In the<code>&nbsp;def&nbsp;</code>statement header,<code>&nbsp;=&nbsp;</code>==does not perform assignment==, but instead ==indicates a default value to use== when the&nbsp;pressure&nbsp;function is called. By contrast, the assignment statement to<code>&nbsp;k</code>&nbsp;==in the body of the function binds the name&nbsp;k&nbsp;to an approximation(近似值) of Boltzmann’s constant.==</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>)</span><br><span class="line"><span class="number">2269.974834</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)</span><br><span class="line"><span class="number">6809.924502</span></span><br></pre></td></tr></tbody></table></figure>
<p>The&nbsp;<code>pressure</code>&nbsp;function is defined to take three arguments, but only two are provided in the first call expression above. In this case, the value for&nbsp;<code>n&nbsp;</code>is taken from the&nbsp;<code>def&nbsp;</code>statement default. If a third argument is provided, the default is ignored.</p>
<p>As a guideline, most data values used in a function’s body should be expressed as default values to named arguments, so that they are easy to inspect and can be changed by the function caller. Some values that never change, such as the fundamental constant&nbsp;k, can be bound in the function body or in the global frame.</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
        <tag>SICP</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>隐序列</title>
    <url>/2023/04/15/%E9%9A%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">range</span>(<span class="number">10000</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">45006230</span>]</span><br><span class="line"><span class="number">45016230</span></span><br></pre></td></tr></tbody></table></figure>
<p>在本例中，在构造range实例时，并不是存储该范围内的所有999,990000个整数。相反，range对象将第一个元素10,000添加到索引45,006,230以生成元素45,016,230。按需计算值，而不是从现有表示中检索值，是惰性计算的一个例子。在计算机科学中，<mark style="background: #FF5582A6;">惰性计算</mark>指的是延迟某个值的计算，直到该值需要时才计算的程序。</p>
<span id="more"></span>

<p>迭代器是一个对象，它提供对值的一个接一个顺序访问。<br>迭代器抽象有两个组件：一种机制用于检索正在处理的序列中的下一个元素，另一种机制用于通知已经到达序列的末尾且不再有其他元素存在。<br>对于任何容器，比如列表或range，都可以通过调用内置的<mark style="background: #FFF3A3A6;">iter函数</mark>来获得迭代器。可以通过调用内置的<mark style="background: #ABF7F7A6;">next函数来访问迭代器的内容。</mark></p>
<p>Python表示没有更多可用值的方式是在调用next时引发<mark style="background: #ABF7F7A6;">StopIteration</mark>异常。可以<mark style="background: #ABF7F7A6;">使用try语句处理此异常</mark>。</p>
<p>迭代器维护局部状态以表示其在序列中的位置。每次调用next时，该头都会上升。<mark style="background: #ADCCFFA6;">两个独立的迭代器可以跟踪同一序列中的两个不同位置。然而，同一个迭代器的两个名称将共享一个位置，因为它们共享相同的值。</mark></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">13</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">iter</span>(r)  <span class="comment"># 1st iterator over r</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">iter</span>(r)  <span class="comment"># 2nd iterator over r</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(t)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(t)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = t        <span class="comment"># Alternate name for the 2nd iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(u)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(u)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<p>向前移动第二个迭代器不会影响第一个迭代器。因为从第一个迭代器返回的最后一个值是4，所以它被定位为next返回5。另一方面，第二个迭代器被定位为返回7 next。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(t)</span><br><span class="line"><span class="number">7</span>```</span><br><span class="line"></span><br><span class="line">&lt;mark style=<span class="string">"background: #ABF7F7A6;"</span>&gt;在迭代器上调用<span class="built_in">iter</span>将返回该迭代器，而不是副本&lt;/mark&gt;。Python中包含了这种行为，这样程序员就可以对一个值调用<span class="built_in">iter</span>来获得迭代器，而不必担心它是迭代器还是容器。</span><br><span class="line"></span><br><span class="line">迭代器的有用性源于这样一个事实：迭代器的底层数据序列不能显式地表示在内存中。 **迭代器提供了一种机制，可以依次考虑一系列的值，但不需要同时存储所有这些元素**。 相反，**当从迭代器请求下一个元素时，可以根据需要计算该元素，而不是从现有的内存源检索该元素。**</span><br><span class="line"></span><br><span class="line">`<span class="built_in">range</span> `能够惰性地计算序列的元素，因为所表示的序列是一致的，而且从范围的起始和结束边界计算任何元素都很容易。 **迭代器允许延迟生成更广泛的底层序列数据集，因为它们不需要提供对底层序列的任意元素的访问**。 相反，迭代器只需要在每次请求另一个元素时依次计算序列的下一个元素。 虽然不像访问序列的任意元素那样灵活(称为随机访问)，但对顺序数据的顺序访问通常对于数据处理应用程序来说已经足够了。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 可迭代对象</span></span><br><span class="line"></span><br><span class="line">任何可以产生迭代器的值都称为可迭代值。 在Python中，&lt;mark style=<span class="string">"background: #ABF7F7A6;"</span>&gt;可迭代值是任何可以传递给内置<span class="built_in">iter</span>函数的值。&lt;/mark&gt; &lt;mark style=<span class="string">"background: #ABF7F7A6;"</span>&gt;可迭代对象包括序列值，如字符串和元组，以及其他容器，如集合和字典&lt;/mark&gt;。迭代器也是可迭代对象，因为它们可以传递给<span class="built_in">iter</span>函数。</span><br><span class="line"></span><br><span class="line">即使是字典之类的&lt;mark style=<span class="string">"background: #FF5582A6;"</span>&gt;无序集合在生成迭代器时也必须对其内容定义顺序。&lt;/mark&gt; 字典和集合是无序的，因为程序员无法控制迭代的顺序，但是Python在其规范中保证了它们的某些属性的顺序。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = {<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">{<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: <span class="number">2</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="built_in">iter</span>(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(k)</span><br><span class="line"><span class="string">'one'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(k)</span><br><span class="line"><span class="string">'three'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = <span class="built_in">iter</span>(d.values())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(v)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(v)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果由于添加或删除键而导致字典的结构发生变化，那么所有迭代器都将失效，<mark style="background: #FF5582A6;">未来的迭代器可能会对其内容的顺序进行任意更改</mark>。另一方面，<mark style="background: #FF5582A6;">改变现有键的值不会改变内容的顺序或使迭代器失效。</mark></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'two'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(k)</span><br><span class="line">       </span><br><span class="line">RuntimeError: dictionary changed size during iteration</span><br><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></tbody></table></figure>

<h2 id="内置迭代器"><a href="#内置迭代器" class="headerlink" title="内置迭代器"></a>内置迭代器</h2><p>一些内置函数接受可迭代值作为参数并返回迭代器。 这些函数广泛用于延迟序列处理。</p>
<p>map函数是惰性的：调用它并不执行计算其结果元素所需的计算。 相反，将创建一个迭代器对象，如果使用next进行查询，该对象将返回结果。 我们可以在下面的例子中观察到这一事实，在这个例子中，对print的调用被延迟，直到double迭代器请求相应的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">double_and_print</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'***'</span>, x, <span class="string">'=&gt;'</span>, <span class="number">2</span>*x, <span class="string">'***'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doubled = <span class="built_in">map</span>(double_and_print, s)  <span class="comment"># double_and_print not yet called</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(doubled)                       <span class="comment"># double_and_print called once</span></span><br><span class="line">*** <span class="number">3</span> =&gt; <span class="number">6</span> ***</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(doubled)                       <span class="comment"># double_and_print called again</span></span><br><span class="line">*** <span class="number">4</span> =&gt; <span class="number">8</span> ***</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(doubled)                       <span class="comment"># double_and_print called twice more</span></span><br><span class="line">*** <span class="number">5</span> =&gt; <span class="number">10</span> ***</span><br><span class="line">*** <span class="number">6</span> =&gt; <span class="number">12</span> ***</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>filter函数返回一个迭代器over, zip，而reverse函数也返回迭代器。 TODO演示这些值</p>
<h2 id="For-语句"><a href="#For-语句" class="headerlink" title="For 语句"></a>For 语句</h2><p>Python中的for语句操作迭代器。如果对象具有返回迭代器的__iter__方法，则该对象是可迭代的(接口)。可迭代对象可以是for语句头中的<code>&lt;expression&gt;</code>的值:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>为了执行for语句，Python计算头文件<code>&lt;expression&gt;</code>，它必须产生一个可迭代值。然后，对该值调用<code>__iter__</code>方法。在引发<code>StopIteration</code>异常之前，Python会反复调用该迭代器上的<code>__next__</code>方法，并将结果绑定到for语句中的。然后，它执行<code>&lt;suite&gt;</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> counts:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，counts列表从其__iter__()方法返回一个迭代器。 然后for语句重复调用该迭代器的__next__()方法，并每次将返回值赋给item。 这个过程一直持续，直到迭代器抛出StopIteration异常，此时for语句的执行结束。</p>
<p>有了迭代器的知识，我们就可以用while、赋值和try语句来实现for语句的执行规则。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = counts.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = items.__next__()</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面，调用counts的__iter__方法返回的迭代器被绑定到一个名称 items上，以便可以依次查询每个元素。 StopIteration异常的handling子句不做任何事情，但是处理异常提供了退出while循环的控制机制。<br>要在for循环中使用迭代器，迭代器还必须具有<code>__iter__</code>方法。<a href="http://docs.python.org/3/library/stdtypes.html#iterator-types">迭代器类型 Python文档</a>建议迭代器有一个’ iter ‘方法，该方法返回迭代器本身，因此所有迭代器都是可迭代的。</p>
<h2 id="生成器和Yield声明"><a href="#生成器和Yield声明" class="headerlink" title="生成器和Yield声明"></a>生成器和Yield声明</h2><p>Letters和 Positives对象要求我们引入一个新的概念 self.current到我们的对象，以跟踪序列的进程。 使用上面所示的简单序列，这可以很容易地完成。 然而，对于复杂的序列，__next__方法在计算中保存自己的位置可能会相当困难。生成器允许我们利用Python解释器的特性来定义更复杂的迭代。</p>
<p>生成器是由称为<mark style="background: #FF5582A6;">生成器函数</mark>的特殊函数类返回的迭代器。 生成器函数与常规函数的区别在于，它们<mark style="background: #FF5582A6;">不在函数体中包含return语句，而是使用yield语句返回序列的元素</mark>。</p>
<p>生成器不使用对象的属性来跟踪它们在一系列中的进度。相反，它们控制生成器函数的执行，直到每次调用生成器的__next__方法时执行下一个yield语句为止。使用生成器函数可以更简洁地实现Letters迭代器。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">letters_generator</span>():</span><br><span class="line">        current = <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">while</span> current &lt;= <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">yield</span> current</span><br><span class="line">            current = <span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>尽管我们从未显式定义<code>__iitem__</code>或<code>__next__</code>方法，但<code>yield</code>语句表明我们正在定义一个生成器函数。 当被调用时，生成器函数不会返回特定的生成值，而是返回自身可以返回生成值的生成器(它是一种迭代器类型)。 <mark style="background: #FF5582A6;">生成器对象有__item__和__next__方法，每次对__next__的调用都会从它之前停止的地方继续执行生成器函数，直到执行另一个yield语句。</mark></p>
<p>第一次调用__next__时，程序从letters_generator函数体开始执行语句，直到遇到yield语句为止。然后，它暂停并返回current.yield的值，不会破坏新创建的环境，它们会保存它以供以后使用。当__next__再次被调用时，执行将在它停止的地方继续。letters_generator作用域内的当前名称和任何其他绑定名称的值在后续对__next__的调用中保留。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = letters_generator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(letters)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'generator'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></tbody></table></figure>
<p>直到第一次调用__next__，生成器才会开始执行它的生成器函数的任何主体语句。每当生成器函数返回时，生成器将引发StopIteration异常。</p>
<h2 id="可迭代接口"><a href="#可迭代接口" class="headerlink" title="可迭代接口"></a>可迭代接口</h2><p>一个对象是可迭代的，如果它在__iter__方法被调用时返回一个迭代器。可迭代值表示数据集合，它们提供了一种固定的表示方式，可以产生多个迭代器。</p>
<p>例如，下面的Letters类的一个实例表示一个连续的字母序列。每次调用它的__iter__方法时，都会构造一个新的LetterIter实例，它允许顺序访问序列的内容。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Letters</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">'a'</span>, end=<span class="string">'e'</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> LetterIter(self.start, self.end)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="创建迭代器的常用方法"><a href="#创建迭代器的常用方法" class="headerlink" title="创建迭代器的常用方法"></a>创建迭代器的常用方法</h2><p>•    <code>range(start, end)</code> returns an iterable containing numbers from start to end-<br>    1.    If start is not provided, it defaults to 0.<br>•    <code>map(f, iterable)</code> returns a new iterator containing the values resulting from applying f to each value in iterable.<br>•    <code>filter(f, iterable)</code> returns a new iterator containing only the values in iterable for which f(value) returns True.</p>
<h2 id="生成器和yield语句"><a href="#生成器和yield语句" class="headerlink" title="生成器和yield语句"></a>生成器和yield语句</h2><p>生成器函数是一种特殊的 Python 函数，它使用 yield语句而不是返回语句来报告数值。当一个生成器函数被调用时，它返回一个生成器对象，这是一种迭代器的类型。在右边，你可以看到一个函数，它返回一个自然数的迭代器。<br>yield语句与return语句类似。然而，返回语句在函数退出后关闭了当前的框架，而yield语句会使框架被保存到下一次调用时，这使生成器能够自动跟踪迭代状态。</p>
<p>一旦再次调用next，执行就会在上次停止的地方继续进行，直到下一个yield语句或函数的结束。一个生成器函数可以有多个 yield语句。<br>在一个函数中包含一个 yield 语句，会自动告诉 Python 这个函数将创建一个生成器。当我们调用这个函数时，它会返回一个生成器对象，而不是执行主体。当生成器的下一个方法被调用时，主体被执行，直到下一个 yield语句被执行。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的编程</title>
    <url>/2023/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>像数据抽象中的函数一样，类在数据的使用和实现之间创建了抽象障碍。与分派字典一样，对象响应行为请求。 与可变数据结构一样，对象具有不能从全局环境直接访问的局部状态。</p>
<p>面向对象编程的范例有自己的词汇表来支持对象隐喻。 我们已经看到，对象是一个具有方法和属性的数据值，可以通过<mark style="background: #FF5582A6;">点表示</mark>法访问。 每个对象也有一个类型，称为它的类。 为了创建新的数据类型，我们实现了新的类。</p>
<span id="more"></span>
<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>类充当所有类型为该类的对象的模板。每个对象都是某个特定类的实例。到目前为止，我们使用的对象都有内置类，但是也可以创建新的用户定义的类。类定义指定类的对象之间共享的属性和方法。</p>
<p>创建一个新的对象实例的行为被称为实例化类。 Python中实例化类的语法与调用函数的语法相同。</p>
<p>对象的属性是与对象相关联的名值对，可以通过<mark style="background: #ABF7F7A6;">点表示法</mark>访问。与类的所有对象不同，<mark style="background: #ABF7F7A6;">特定于特定对象的属性称为实例属性</mark>。每个帐户都有自己的余额和帐户持有人名称，它们是实例属性的示例。在更广泛的编程社区中，<mark style="background: #ABF7F7A6;">实例属性也可以称为字段、属性或实例变量</mark>。</p>
<p>对对象进行操作或执行特定于对象的计算的函数称为方法。方法的返回值和副作用可以依赖并更改对象的其他属性。<br>方法的行为可以依赖于对象不断变化的属性。两次使用相同参数的withdraw调用会返回不同的结果。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>用户定义的类由由单个子句组成的class语句创建。类语句定义类名，然后包含一组定义类属性的语句：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>当一个类语句被执行时，一个新的类被创建并绑定到<code>&lt;name&gt;</code> 在当前环境的第一个框架中。 然后执行<code>&lt;suite&gt;</code>。 在套件内的任何名称对于类语句，通过<code>def</code>或赋值语句创建或修改类的属性。</p>
<p>类通常是围绕操纵实例属性来组织的，实例属性是与该类的每个实例相关联的名值对。 该类通过定义初始化新对象的方法来指定其对象的实例属性。</p>
<p><code>&lt;suite&gt;</code> 类的对象语句包含为该类对象定义新方法的def语句。 初始化对象的方法在Python中有一个特殊的名称，<code>__init__</code>(单词“<code>init</code>”的两侧各有两个下划线)，它被称为该类的构造函数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br></pre></td></tr></tbody></table></figure>
<p>Account的<code>__init__</code>方法有两个形式参数。第一个<code>self</code>绑定到新创建的<code>Account</code>对象。 第二个形参<code>account_holder</code>绑定到在调用类进行实例化时传递给类的实参。</p>
<p>构造函数将实例属性名<code>balance</code>绑定到<code>0</code>。 它还将属性名称持有者绑定到名称<code>account_holder</code>的值。 形参<code>account_holder</code>是<code>__init__</code>方法中的本地名称。 另一方面，通过最终赋值语句绑定的名称持有者将持续存在，因为它使用点表示法存储为<code>self</code>属性。</p>
<p>定义了Account类之后，就可以实例化它了。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Account(<span class="string">'Kirk'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>这个对Account类的“调用”创建了一个新对象，它是Account的一个实例，然后用两个参数调用构造函数<code>__init__</code>：新创建的对象和字符串<code>'Kirk'</code>。按照惯例，我们使用参数名<code>self</code>作为构造函数的第一个参数，因为它被绑定到正在实例化的对象。几乎所有的Python代码都采用了这种约定。</p>
<p>现在，我们可以使用点表示法访问对象的balance和holder</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">'Kirk'</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>同一性</strong> ：每个新的account实例都有自己的balance属性，该属性的值<mark style="background: #ABF7F7A6;">独立于同一类的其他对象</mark>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Account(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.balance = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[acc.balance <span class="keyword">for</span> acc <span class="keyword">in</span> (a, b)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">200</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>为了强制这种分离，作为用户定义类实例的每个对象都有一个唯一标识。使用is和is not操作符比较对象标识。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<p>尽管由相同的调用构造，绑定到a和b的对象是不一样的。通常，使用赋值将对象绑定到新名称并不会创建新对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<p>只有当使用调用表达式语法实例化类(例如Account)时，才会创建具有用户定义类的新对象。</p>
<p><strong>方法</strong> : 对象方法也由class语句集合中的def语句定义。下面，deposit和withdraw都定义为Account类对象上的方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></tbody></table></figure>
<p>虽然方法定义在声明方式上与函数定义没有区别，但<mark style="background: #ABF7F7A6;">方法定义在执行时确实有不同的效果</mark>。 <mark style="background: #ABF7F7A6;">由类语句中的def语句创建的函数值绑定到声明的名称，但在类内部局部绑定为属性。</mark> <mark style="background: #FF5582A6;">该值是使用类实例中的点表示法作为方法调用的。</mark></p>
<p><mark style="background: #FF5582A6;">每个方法定义同样包含一个特殊的第一个参数self，它被绑定到调用该方法的对象。</mark> 例如，假设在一个特定的Account对象上调用了deposit，并传递了一个参数值：存入的金额。 对象本身与self绑定，而参数与amount绑定。 <mark style="background: #FF5582A6;">所有被调用的方法都可以通过self参数访问对象，因此它们都可以访问和操作对象的状态。</mark></p>
<p>为了调用这些方法，我们再次使用点表示法，如下所示。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="string">'Insufficient funds'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.holder</span><br><span class="line"><span class="string">'Spock'</span></span><br></pre></td></tr></tbody></table></figure>

<p>当通过<mark style="background: #FF5582A6;">点表示法</mark>调用方法时，对象本身(在本例中绑定到spock_account)扮演双重角色。首先，它确定了“withdraw”这个名字的含义；withdraw不是环境中的名称，而是Account类本地的名称。其次，<mark style="background: #FF5582A6;">在调用withdraw方法时，它被绑定到第一个参数self。</mark></p>
<h2 id="消息传递和点表达式"><a href="#消息传递和点表达式" class="headerlink" title="消息传递和点表达式"></a>消息传递和点表达式</h2><p>在类中定义的方法，以及通常在构造函数中分配的实例属性，是面向对象编程的基本元素。 这两个概念在数据值的消息传递实现中<mark style="background: #FF5582A6;">复制了调度字典的</mark>大部分行为。 对象使用点表示法接受消息，但这些消息不是任意字符串值的键，而是<mark style="background: #FF5582A6;">类的本地名称</mark>。 <mark style="background: #FF5582A6;">对象也有命名的本地状态值(实例属性)，但是可以使用点表法访问和操作该状态，而不必在实现中使用非本地语句</mark>。</p>
<p><mark style="background: #FF5582A6;">消息传递的中心思想是，数据值应该通过响应与它们所表示的抽象类型相关的消息而具有行为</mark>。 点表示法是Python的一个语法特性，它将消息传递隐喻形式化。 使用内置对象系统的语言的优点是，消息传递可以与其他语言特性无缝地交互，比如赋值语句。 我们不要求不同的消息“获取”或“设置”与本地属性名相关联的值；语言语法允许我们直接使用消息名称。</p>
<p><strong>点表示</strong> : 代码片段spock_account.deposit称为点表达式。 点表达式由表达式、点和名称组成：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;expression&gt; . &lt;name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><code>&lt;表达式&gt;</code>可以是任何有效的Python表达式，但必须是一个简单的名称(而不是计算结果为名称的表达式)。对于<code>&lt;表达式&gt;</code>的值的对象，点表达式计算为具有给定的的属性的值。</p>
<p>内置函数<code>getattr</code>还根据名称返回对象的属性。它<mark style="background: #FF5582A6;">是点表示法的等价函数</mark>。使用<code>getattr</code>，我们可以使用字符串查找属性，就像使用分派字典一样。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(spock_account, <span class="string">'balance'</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们还可以用<code>hasattr</code>测试对象是否有命名属性。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(spock_account, <span class="string">'deposit'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<p>对象的属性包括它的<mark style="background: #FF5582A6;">所有实例属性</mark>，<mark style="background: #FF5582A6;">以及类中定义的所有属性(包括方法)</mark>。 方法是类的属性，需要特殊处理</p>
<p><strong>方法和函数。</strong> 当在对象上调用方法时，该对象将隐式地作为方法的第一个参数传递。 也就是说，对象就是<code>&lt;表达式&gt;</code>的值，<mark style="background: #FF5582A6;">在点的左边会自动作为第一个参数传递给点表达式右边命名的方法。</mark> <mark style="background: #FF5582A6;">因此，对象被绑定到参数self。</mark></p>
<p>为了实现自动自绑定，Python区分了函数(我们从正文开始就一直在创建)和绑定方法(绑定方法将函数和将调用该方法的对象结合在一起)。<mark style="background: #FF5582A6;">绑定的方法值已经与它的第一个参数(调用它的实例)相关联，该参数将在调用该方法时被命名为self。</mark></p>
<p>通过对点表达式的返回值调用<code>type</code>，我们可以看到交互式解释器中的区别。<mark style="background: #FF5582A6;"> 作为类的属性，方法只是一个函数，而作为实例的属性，它是一个绑定方法</mark>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(spock_account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'method'</span>&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>这两个结果的不同之处在于，<mark style="background: #FF5582A6;">第一个是带有参数self和amount的标准双参数函数</mark>。 第二个是一个<mark style="background: #FF5582A6;">单参数方法</mark>，在调用该方法时，名称self将自动绑定到名为spock_account的对象，而形参amount将绑定到传递给该方法的实参。 这两个值，无论是函数值还是绑定的方法值，都与同一个desposit函数体相关联。</p>
<p>我们可以以两种方式调用<code>deposit</code> : <mark style="background: #FF5582A6;">作为函数和作为绑定方法</mark>。 在前一种情况下，必须显式地为self形参提供一个实参。 在后一种情况下，self参数是自动绑定的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.deposit(spock_account, <span class="number">1001</span>)  <span class="comment"># The deposit function takes 2 arguments</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">1000</span>)           <span class="comment"># The deposit method takes 1 argument</span></span><br><span class="line"><span class="number">2011</span></span><br></pre></td></tr></tbody></table></figure>

<p>函数<code>getattr</code>的行为与点表法完全相同：<mark style="background: #FF5582A6;">如果它的第一个参数是一个对象，但名称是类中定义的一个方法，那么getattr返回一个绑定的方法值。</mark> 另一方面，<mark style="background: #FF5582A6;">如果第一个参数是一个类，则getattr将直接返回属性值，这是一个普通函数。</mark></p>
<p><strong>命名约定。</strong> <mark style="background: #FF5582A6;">类名通常使用<code>CapWords</code>约定编写</mark>(也称为CamelCase，因为名称中间的大写字母看起来像驼峰)。 <mark style="background: #FF5582A6;">方法名称遵循命名函数的标准约定，使用用下划线分隔的小写单词</mark>。</p>
<p>在某些情况下，有些实例变量和方法与对象的维护和一致性有关，我们不希望对象的用户看到或使用它们。 它们不是类定义的抽象的一部分，而是实现的一部分。 Python的约定是，如果<mark style="background: #FF5582A6;">属性名以下划线开头，则只能在类本身的方法中访问，而不是由类的用户访问。</mark></p>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>某些属性值在给定类的所有对象之间共享。 这些<mark style="background: #FF5582A6;">属性与类本身相关联，而不是与类的任何单独实例相关联</mark>。 例如，假设一家银行按固定利率对账户余额支付利息。 利率可能会变化，但它是所有账户共享的单一价值。</p>
<p>类属性是由类语句集合中的<mark style="background: #FF5582A6;">赋值语句</mark>创建的，而不属于任何方法定义。 在更广泛的开发人员社区中，<mark style="background: #FF5582A6;">类属性也可以称为类变量或静态变量。 </mark>下面的类语句为帐户创建了一个名为interest的类属性。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        interest = <span class="number">0.02</span>            <span class="comment"># A class attribute</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="comment"># Additional methods would be defined here</span></span><br></pre></td></tr></tbody></table></figure>

<p>仍然可以从类的任何实例访问此属性</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account = Account(<span class="string">'Kirk'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br></pre></td></tr></tbody></table></figure>

<p>对类属性的单个赋值语句会更改该类所有实例的属性值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>属性名称。</strong> 我们已经在对象系统中引入了足够的复杂性，以至于必须<mark style="background: #FF5582A6;">指定名称如何解析为特定的属性</mark>。毕竟，我们可以很容易地拥有具有相同名称的类属性和实例属性。</p>
<p>计算一个点表达式：<br><code>&lt;expression&gt; . &lt;name&gt;</code></p>
<ul>
<li>  计算<code>&lt;表达式&gt;</code> 在点的左边，它产生点表达式的对象。</li>
<li><code>&lt;name&gt;</code> 匹配该对象的实例属性; 如果存在具有该名称的属性，则返回其值。</li>
<li>如果 <code>&lt;name&gt;</code> 如果实例属性中没有出现<code>&lt;name&gt;</code> 在类中查找，这<mark style="background: #FF5582A6;">会产生一个类属性值</mark>。</li>
<li> 除非它是一个函数，否则将返回该值，在这种情况下，将返回绑定方法。</li>
</ul>
<p>在这个计算过程中，<mark style="background: #FF5582A6;">在类属性之前找到实例属性</mark>，就像在环境中局部名称优先于全局名称一样。 <mark style="background: #FF5582A6;">在求值过程的第四步中，类中定义的方法与点表达式的对象相结合，形成一个绑定方法。</mark> 一旦引入了类继承，在类中查找名称的过程将很快产生额外的细微差别。</p>
<p><strong>属性赋值。</strong> 所有在左侧包含点表达式的赋值语句都会影响该点表达式对象的属性。 如果对象是一个实例，则赋值设置一个实例属性。 如果对象是一个类，则赋值设置一个类属性。 该规则的结果是，<mark style="background: #FF5582A6;">对对象属性的赋值不能影响其类的属性</mark>。 下面的例子说明了这一区别。</p>
<p>如果将account实例的命名属性interest赋值，则创建一个与现有class属性同名的新实例属性。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest = <span class="number">0.08</span></span><br></pre></td></tr></tbody></table></figure>
<p>属性值将从点表达式返回。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是，class属性interest仍然保留其原始值，对于所有其他帐户都返回该值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></tbody></table></figure>

<p>对类属性的更改将影响spock_account，但kirk_account的实例属性将不受影响。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.05</span>  <span class="comment"># changing the class attribute</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest     <span class="comment"># changes instances without like-named instance attributes</span></span><br><span class="line"><span class="number">0.05</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest     <span class="comment"># but the existing instance attribute is unaffected</span></span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在使用面向对象的编程范式时，我们经常会发现不同的类型是相互关联的。特别地，我们发现相似的类在专业化程度上是不同的。两个类可能具有相似的属性，但是一个类表示另一个类的特殊情况。</p>
<p>例如，我们可能想要实现一个支票帐户，它与标准帐户不同。支票账户每次取款都要额外收取1美元，利率也较低。这里，我们演示所需的行为。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch = CheckingAccount(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.interest     <span class="comment"># Lower interest rate for checking accounts</span></span><br><span class="line"><span class="number">0.01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.deposit(<span class="number">20</span>)  <span class="comment"># Deposits are the same</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.withdraw(<span class="number">5</span>)  <span class="comment"># withdrawals decrease balance by an extra charge</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></figure>

<p>支票帐户是帐户的专门化。 在OOP术语中，通用帐户将作为CheckingAccount的基类，而CheckingAccount将是account的子类。 (术语父类和超类也用于基类，而子类也用于子类。)</p>
<p><mark style="background: #FF5582A6;">子类继承其基类的属性，但可能覆盖某些属性，包括某些方法。</mark> 对于继承，<mark style="background: #ABF7F7A6;">我们只指定子类和基类之间的不同之处。 我们在子类中未指定的任何东西都会自动假定其行为与基类一样。</mark></p>
<p>除了作为一个有用的组织特性之外，继承在我们的对象隐喻中也有作用。 <mark style="background: #FF5582A6;">继承意味着表示类之间的is-关系，这与have -a关系相反</mark>。 支票帐户是一种特定类型的帐户，因此从帐户继承CheckingAccount是继承的适当用法。 另一方面，银行拥有它管理的银行账户列表，因此任何一方都不应该从另一方继承。 相反，account对象的列表将自然地表示为bank对象的实例属性。</p>
<h2 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h2><p>首先，我们给出Account类的完整实现，其中包括该类及其方法的文档字符串。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="string">"""A bank account that has a non-negative balance."""</span></span><br><span class="line">        interest = <span class="number">0.02</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">"""Increase the account balance by amount and return the new balance."""</span></span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">"""Decrease the account balance by amount and return the new balance."""</span></span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></tbody></table></figure>

<p>CheckingAccount的完整实现如下所示。通过将计算结果为基类的表达式放在类名后的圆括号中来指定继承。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">CheckingAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        <span class="string">"""A bank account that charges for withdrawals."""</span></span><br><span class="line">        withdraw_charge = <span class="number">1</span></span><br><span class="line">        interest = <span class="number">0.01</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></tbody></table></figure>
<p>这里，我们引入了一个特定于CheckingAccount类的类属性withdraw_charge。我们给interest属性赋一个较低的值。我们还定义了一个新的withdraw方法来覆盖Account类中定义的行为。如果类套件中没有其他语句，则所有其他行为都继承自基类帐户。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking = CheckingAccount(<span class="string">'Sam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.deposit(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.withdraw(<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.interest</span><br><span class="line"><span class="number">0.01</span></span><br></pre></td></tr></tbody></table></figure>

<p>check .deposit表达式计算为一个存入存款的绑定方法，该方法在Account类中定义。当Python解析不是实例属性的点表达式中的名称时，它会在类中查找该名称。事实上，在类中“查找”名称的行为试图在原始对象的类的继承链中的每个基类中找到这个名称。我们可以递归地定义这个过程。在类中查找名称。</p>
<ul>
<li><ol>
<li>如果它<mark style="background: #FF5582A6;">命名了类中的一个属性，则返回该属性的值</mark>。</li>
</ol>
</li>
<li><ol start="2">
<li>否则，在<mark style="background: #FF5582A6;">基类中查找名称</mark>(如果有的话)。</li>
</ol>
</li>
</ul>
<p>在执行deposit情况下，Python首先在实例中查找名称，然后在CheckingAccount类中查找。 最后，它将查看Account类，其中定义了deposit。 根据点表达式的计算规则，因为deposit是在类中为检查实例查找的函数，所以点表达式计算为绑定的方法值。 该方法使用参数10调用，参数10调用self绑定到check对象并将amount绑定到10的deposit方法。</p>
<p>对象的类始终保持不变。 尽管在Account类中找到了deposit方法，但在调用deposit时，self绑定到CheckingAccount的实例，而不是Account的实例。</p>
<p><strong>调用父类。</strong> 已经被覆盖的属性仍然可以通过类对象访问。 例如，我们通过调用Account的withdraw方法实现了CheckingAccount的withdraw方法，该方法带有一个包含withdraw_charge的参数。</p>
<p>注意到我们调用了self.withdraw_charge ，而不是等价的CheckingAccount.withdraw_charge。 <mark style="background: #FF5582A6;">前者优于后者的好处是继承自CheckingAccount的类可以覆盖取款费用</mark>。 如果是这样的话，我们希望我们的withdraw实现找到新的值而不是旧的值。</p>
<p><strong>接口。</strong> 在面向对象的程序中，<mark style="background: #FF5582A6;">不同类型的对象共享相同的属性名是非常常见的。 </mark><mark style="background: #ABF7F7A6;">对象接口是属性和这些属性上的条件的集合。</mark> 例如，所有帐户都必须有接受数字参数的存款和取款方法，以及一个余额属性。 类Account和CheckingAccount都实现了这个接口。 继承特别以这种方式促进名称共享。 在某些编程语言(如Java)中，必须显式声明接口实现。 在Python、Ruby和Go等其他语言中，任何具有适当名称的对象都实现一个接口。</p>
<p>如果<mark style="background: #FF5582A6;">程序中使用对象(而不是实现对象)的部分不假设对象类型，而只假设对象的属性名称，那么它们对未来的更改是最健壮的。</mark> 也就是说，它们<mark style="background: #FF5582A6;">使用对象抽象</mark>，而不是对其实现进行任何假设。</p>
<p>例如，假设我们运行了一个彩票，我们希望向每个帐户列表中存入5美元。 下面的实现没有对这些帐户的类型进行任何假设，因此同样适用于具有deposit方法的任何类型的对象：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">deposit_all</span>(<span class="params">winners, amount=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> winners:</span><br><span class="line">            account.deposit(amount)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>Python支持子类从多个基类继承属性的概念，这是一种称为多重继承的语言特性。</p>
<p>假设我们有一个从Account继承的SavingsAccount，但每次向客户存款时都要收取少量费用。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        deposit_charge = <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></tbody></table></figure>

<p>然后，一位聪明的经理构思出一个具有支票账户和储蓄账户双重优点的活期账户：提现费、存款费和低利率。它既是支票账户又是储蓄账户!“ 如果我们建造了它，”行政人员解释道，“就会有人签约并支付所有费用。”我们甚至会给他们一美元。”</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            self.balance = <span class="number">1</span>           <span class="comment"># A free dollar!</span></span><br></pre></td></tr></tbody></table></figure>

<p>事实上，这个实现已经完成了。取款和存款都将产生费用，分别使用CheckingAccount和SavingsAccount中的函数定义。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal = AsSeenOnTVAccount(<span class="string">"John"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.balance</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit(<span class="number">20</span>)            <span class="comment"># $2 fee from SavingsAccount.deposit</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw(<span class="number">5</span>)            <span class="comment"># $1 fee from CheckingAccount.withdraw</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></tbody></table></figure>
<p>无歧义引用按预期正确解析：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit_charge</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw_charge</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是，如果引用是模糊的，比如对Account和CheckingAccount中定义的withdraw方法的引用，该怎么办?下图描述了AsSeenOnTVAccount类的继承图。每个箭头从一个子类指向一个基类。<br>![[Pasted image 20230206112746.png]]<br>对于这样一个简单的“菱形”形状，Python从左到右，然后向上解析名称。在这个例子中，Python按顺序检查以下类中的属性名，直到找到具有该名称的属性：<br><code>asseenontvaccount, CheckingAccount, SavingsAccount, Account, object</code><br>继承排序问题没有正确的解决方案，因为在某些情况下，我们可能倾向于优先考虑某些继承的类而不是其他类。 然而，任何支持多重继承的编程语言都必须以一致的方式选择某种顺序，以便该语言的用户能够预测其程序的行为。</p>
<p>Python使用一种称为<mark style="background: #FF5582A6;">C3方法解析排序的递归算</mark>法来解析这个名称。任何类的方法解析顺序都可以在所有类上使用<mark style="background: #FF5582A6;">mro方法</mark>查询。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[c.__name__ <span class="keyword">for</span> c <span class="keyword">in</span> AsSeenOnTVAccount.mro()]</span><br><span class="line">[<span class="string">'AsSeenOnTVAccount'</span>, <span class="string">'CheckingAccount'</span>, <span class="string">'SavingsAccount'</span>, <span class="string">'Account'</span>, <span class="string">'object'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>查找方法解析顺序的精确算法不是本文的主题，但Python的主要作者在<a href="http://python-history.blogspot.com/2010/06/method-resolution-order.html">原始论文的参考资料</a>中进行了描述。</p>
<h2 id="对象的角色"><a href="#对象的角色" class="headerlink" title="对象的角色"></a>对象的角色</h2><p>Python对象系统的设计是为了使数据抽象和消息传递既方便又灵活。 类、方法、继承和点表达式的专门化语法都使我们能够在程序中形式化对象隐喻，这提高了我们组织大型程序的能力。</p>
<p>特别是，我们希望我们的对象系统能够在程序的不同方面促进关注点的分离。 <mark style="background: #FF5582A6;">程序中的每个对象封装并管理程序状态的某些部分，每个类语句定义实现程序整体逻辑的某些部分的函数</mark>。 <mark style="background: #ABF7F7A6;">抽象障碍加强了大型程序不同方面之间的边界</mark>。</p>
<p><mark style="background: #FF5582A6;">面向对象编程特别适合为具有独立但相互作用的部分的系统建模的程序</mark>。 例如，不同的用户在社交网络中互动，不同的角色在游戏中互动，不同的形状在物理模拟中互动。 当表示这样的系统时，程序中的对象通常会自然地映射到被建模的系统中的对象，而类表示它们的类型和关系。</p>
<p>另一方面，<mark style="background: #FF5582A6;">类可能不提供实现某些抽象的最佳机制。 功能抽象为表示输入和输出之间的关系提供了一种更自然的隐喻</mark>。 人们不应该强迫自己在类中容纳程序中的每一点逻辑，特别是在定义用于操作数据的独立函数更自然的情况下。 函数也可以强制关注点分离。</p>
<p>Python等多范式语言允许程序员将组织范式与适当的问题相匹配。 在软件工程中，为了简化或模块化程序，学习何时引入新类(而不是新函数)是一项重要的设计技能，值得仔细注意。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CS61A</tag>
        <tag>笔记</tag>
        <tag>SICP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
