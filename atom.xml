<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alicia&#39;s Blog</title>
  
  <subtitle>a way to get closer to technique</subtitle>
  <link href="https://sajlle.github.io/atom.xml" rel="self"/>
  
  <link href="https://sajlle.github.io/"/>
  <updated>2023-10-25T10:11:31.622Z</updated>
  <id>https://sajlle.github.io/</id>
  
  <author>
    <name>Alicia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>积极心理学的目的</title>
    <link href="https://sajlle.github.io/2023/10/26/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E7%9B%AE%E7%9A%84/"/>
    <id>https://sajlle.github.io/2023/10/26/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E7%9B%AE%E7%9A%84/</id>
    <published>2023-10-25T18:09:49.000Z</published>
    <updated>2023-10-25T10:11:31.622Z</updated>
    
    <content type="html"><![CDATA[<p>the how of happiness 书籍谈到了适合的重要性，鉴别什么适合你。</p><p>培养积极的心态，预防抑郁。</p><p>《积极心理学手册》积极心理学让人们的关注从生活中最糟糕是事情同时转移到建立最美好的事情上。<br>马丁塞利格曼</p><span id="more"></span><p>如何专注于研究有效的东西。<br>问题在于我们提出的问题是什么。</p><p>如何在逆境中成功？<br>适应力。<br>积极适应的模式，即使面对不利或者非常危险的环境。<br>乐观的相信，事情会被圆满的解决。这次也许不会成功，下次会成功的，我从失败中学到了东西。<br>理想主义就是现实主义。有意义感。<br>事情的目标的意义。</p><p>帮助他人的意义。<br>资助，助人的螺旋。对社会有利。</p><p>我擅长的是什么？</p><p>面向未来。<br>五年十年后的目标。</p><p>榜样。<br>一个可以效仿的人。</p><p>有社会支持。不单干，与人合作。求助。<br>合适的人，请求就会回应你的人。</p><p>承认弱点的勇气。</p><p>问题制造现实，问题制造可能性。问题制造探索。<br>问题才是突破点，科学史的转折点在于新问题的的形成。</p><p>欣赏个人的优势，美德，提升自尊和自信。<br>欣赏起作用的东西。</p><p>欣赏好的事物。<br>为某事感激。</p><p>不把一切看作理所当然。<br>感觉及好的的东西。感激好的，好的就会增长。<br>把好看作理所当然，好就会贬值。</p><p>欣赏自己的优点。<br>我的长处是什么，我的优点是什么。<br>有根据的自信。</p><p>理解问题<br>要问什么问题</p><p>如何培养适应力？有个榜样。<br>Marva Collins</p><p>我相信你能成功，停止抱怨，承担生活的责任。停止抱怨父母，停止抱怨社会。成功与否全在你自己。</p><p>从专注缺点到专注优点。</p><p>Howard Gardner<br>多元智力</p><p>问长处<br>欣赏长处<br>人会增值</p><p>从一个被动的，不积极的受害者转变成一个主动的人<br>改变看法</p><p>我会行动，承担责任。<br>经历痛苦的重要性。<br>经历痛苦之后我会行动。</p><p>希望和乐观会变成自我实现的预言。</p><p>你能给小组带来什么优势，<br>你怎么让它成为一个优秀的小组<br>你的优势如何应用到现实之中。<br>你要为小组承担责任。</p><p>Nathaniel Branden 自尊 责任<br>自尊的六根支柱</p><ol><li>自我负责，承担责任，理解没人会让你的生活更美好，你必须为自己的幸福自尊自信负责。你必须自己创造。能否从这次经历中最大限度的获益，全取决你自己。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;the how of happiness 书籍谈到了适合的重要性，鉴别什么适合你。&lt;/p&gt;
&lt;p&gt;培养积极的心态，预防抑郁。&lt;/p&gt;
&lt;p&gt;《积极心理学手册》积极心理学让人们的关注从生活中最糟糕是事情同时转移到建立最美好的事情上。&lt;br&gt;马丁塞利格曼&lt;/p&gt;</summary>
    
    
    
    <category term="心理" scheme="https://sajlle.github.io/categories/%E5%BF%83%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="积极心理学" scheme="https://sajlle.github.io/tags/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>辨识情绪重现的诱发因子</title>
    <link href="https://sajlle.github.io/2023/09/10/%E8%BE%A8%E8%AF%86%E6%83%85%E7%BB%AA%E9%87%8D%E7%8E%B0%E7%9A%84%E8%AF%B1%E5%8F%91%E5%9B%A0%E5%AD%90/"/>
    <id>https://sajlle.github.io/2023/09/10/%E8%BE%A8%E8%AF%86%E6%83%85%E7%BB%AA%E9%87%8D%E7%8E%B0%E7%9A%84%E8%AF%B1%E5%8F%91%E5%9B%A0%E5%AD%90/</id>
    <published>2023-09-10T14:56:46.000Z</published>
    <updated>2023-09-10T07:08:14.549Z</updated>
    
    <content type="html"><![CDATA[<p>诱发因子是会引发情绪重现的外在或内在刺激，通常发生在正常意识之外的潜意识层次，因此要辨识什么会诱发我们的情绪重现，可能很困难。但是，能够越来越觉察诱发引子，是至关重要的事，因为它有时候能让我们避开引发情绪重现的人、情境和行为。</p><span id="more"></span><h2 id="情绪重现的诱发因子"><a href="#情绪重现的诱发因子" class="headerlink" title="情绪重现的诱发因子"></a>情绪重现的诱发因子</h2><p>诱发因子是会引发情绪重现的外在或内在刺激，通常发生在正常意识之外的潜意识层次，因此要辨识什么会诱发我们的情绪重现，可能很困难。但是，能够越来越觉察诱发引子，是至关重要的事，因为它有时候能让我们避开引发情绪重现的人、情境和行为。</p><p>外在的诱发因子，是使我们重回痛苦创伤经历的那些人、事、地、物、表情、沟通风格……等。这里是一些常见而强大的诱发因子：再访你的父母、看见很像童年施虐者的人、特别创伤性事件的纪念日、听到某人使用父母羞辱你时的语调或用字遣词。</p><p>然而，很多诱发因子没有这么明确，有时候不认识的成人也能诱发我们的恐惧，即使他们一点也不像原本的施虐者。当我遇到一群青少年时，我仍偶尔会被诱发情绪重现，因为我成长的社区有很多暴力的青少年。因此，我那颇具同理心的儿子常开玩笑说，他长大时不会变成青少年。</p><p>有时候别人看着我们，或甚至仅注意到我们，也能诱发我们的恐惧和毒性羞耻。我的一位案主有一次来找我时被严重诱发了，只因为一只猫盯着他看。其他常见的诱发因子，包括犯错、请求帮助，或者必须在一群人面前说话。还有，光是感到疲倦、生病、寂寞或饥饿，有时也会诱发情绪重现。任何身体疼痛也可能是诱发因子。</p><p><mark style="background: #FF5582A6;">对很多幸存者来说，权威人士是最大的诱发因子</mark>。我认识好几位幸存者，他们连一张停车罚单都没拿过，可是只要经过警察或警车旁边，他们就会焦虑地全身紧绷。</p><p>没什么比教学更会诱发我了，但我花了几十年时间去克服教书的严重表现焦虑。幸好我不愿放弃这项活动，因为只要开始做，我大部分的时候都很享受它。除了硬撑过去，我没有任何真正的进步，直到我了解了我的表现焦虑，是情绪重现了和家人晚餐谈话的时刻。这个领悟使我能看清自己无意识地害怕我的父母会出现，并且当众嘲笑我。</p><p>一开始，我（我的找碴鬼）认为这是荒谬可笑的想法，但当我在去教书的车程中，开始想像并练习积极地捍卫自己以抵抗父母，我很快就感觉到焦虑大幅减少。这个练习使我想出了情绪重现管理步骤的第六步，还有对找碴鬼发怒（我们会在下一章说明对找碴鬼发怒）。</p><h2 id="那个眼神：一个常见的诱发因子"><a href="#那个眼神：一个常见的诱发因子" class="headerlink" title="那个眼神：一个常见的诱发因子"></a>那个眼神：一个常见的诱发因子</h2><p>初期使用这个管理步骤协助案主时，我很惊讶地发现，有些案主的童年受虐经验不算严重，却深受情绪重现所苦。他们多数人都很确定，自己从未被打，但他们当中许多人都提到，自己有多痛恨父母给他们的那个眼神。</p><p>在多数情况中，“那个眼神”伴随着轻蔑的表情。轻蔑，是强而有力的惩罚性面容，充满恫吓和厌恶的情绪力道。如果间歇地加上拉高的音量，更可以加强那个情绪力道。</p><p>当父母给孩子那个眼神，他就是在“告诉”孩子：你不只大难临头，而且你还不配当人。久而久之，那个眼神会使他的恐惧与羞耻情绪重现，使他感到害怕和可憎。</p><p>如果那个眼神是用来控制年纪较大的孩子，它通常会使孩子情绪重现推至早期、还没有记忆的时期，而那个眼神在那个时期若配上有创伤性的惩罚，会更为强大。事实上，那个会引发情绪重现的眼神，几乎都曾和鞭打或其他可怕的情况一起出现过，否则光是那个眼神，是很少能够把孩子吓到乖乖听话的。在亲职压力服务单位工作数年的经验，使我相信，那个眼神确实曾与创伤性的惩罚一起出现过。</p><p>那个眼神通常是透过一种称为“制约”的心理历程而产生力量，这是源于一个嫌恶制约的经典案例：技术人员对笼子内的动物施以电击，同时响起铃铛声。被电击的动物当然会对电击有害怕和痛苦的反应。然而，一直重复结合电击和铃铛声，不消几次，就能使动物只听到铃铛声也会害怕。</p><p>我相信，这就是孩子如何变得害怕那个眼神的同样道理，那个眼神和体罚或极度的遗弃结合次数够多的话，父母不用打，光靠那个眼神，就能得到相同的结果。而且在童年早期重复次数够多的话，这个结合效果就可以维持一生，以至于父母可以永远用那个眼神来控制孩子。我在安宁照护工作时，看到好几位将死且瘦弱的母亲，仍然可以用那个眼神就把他们壮硕的儿子吓个半死。</p><p>那个眼神于是成为成年幸存者的强力诱发因子，使他们情绪重现童年时的恐惧和羞辱。再说一次，我的许多案主并不记得这些，因为那些惩罚只需要和那个眼神一起在他们幼童时期出现几个月，那个眼神就能永远深植成诱发因子，而很少有人可以记得三岁或四岁以前的事。</p><p>不幸的是，那个眼神可以一直有效，甚至延续到父母死后。这至少有两个原因。</p><p>第一个原因，我们会内化我们的父母。当我们不完美时，他们能够在我们的潜意识和想像中出现，并且给我们那个眼神。这“不完美”包括了想法、感受或行动。</p><p>令人难过的是，我常看到情绪重现中的案主出现同样的表情，沉着脸藐视他们自己。</p><p>第二个原因，当有人不认同地看着我们时，我们可能会概化地认为，他们就像父母一样危险，如同我在第一章说过自己情绪重现的例子。</p><p>童年被那个眼神创伤的最糟糕状况是，当我们被引发情绪重现时，会错误地把那个眼神的记忆转移和投射到他人身上，尤其容易对权威人士或像我们父母的人这么做，即使他们没有做出那个眼神。</p><p>不容忽视的内在诱发因子过了疗愈初期后，我们会开始注意到内在诱发因子比外在诱发因子更常见，这种诱发因子通常是内在找碴鬼令人讨厌的产物，它们通常是危险的或必须完美的想法或视像。幸存者可能会没来由地把某人看做会虐待人的人，也可能无缘无故地认为自己没有完美地做好一项工作，把自己烦恼到情绪重现。他们还可能列举自己会搞砸事情的种种可能性，自己吓自己。</p><p>内在诱发因子发作最严重时，一点点小失误就能引发情绪重现大发作，然后让幸存者极端地注意负面，不停地执着于缺陷和危险，固执于曾经出差错或可能出差错的一切。</p><p>随着渐渐复原，许多幸存者会很震惊地发现，自己的情绪重现大多来自于内在找碴鬼造成的内在诱发因子。接下来，我们会探讨如何从内在找碴鬼的诱发历程中自救。</p><h2 id="预防性地辨识诱发因子"><a href="#预防性地辨识诱发因子" class="headerlink" title="预防性地辨识诱发因子"></a>预防性地辨识诱发因子</h2><p>随着持续疗愈，我们会越来越懂得诱发因子，并尽可能避开它们。辨识诱发因子，也能帮助我们更快地进入情绪重现管理状态。进一步的辨识，可以帮我们应付无可避免的诱发情境。事先准备可以让我们在发作前，就预防性地练习情绪重现管理，就像先前我提到自己的表现焦虑。</p><p>辨识自己正在被诱发，甚至比辨识诱发因子更重要。这是因为，有时候情绪重现一开始时并不明显，但会越来越严重。即早辨识，有助于我们早点应用管理步骤，并减低情绪重现的强度和缩短发作时间。</p><p>最后，化解情绪重现需要重新平衡脑部与身体的重大生化改变，而这需要一些时间。比方说，肾上腺素过旺，有时候会戏剧性地变成肾上腺素过耗的疲累，直到肾上腺素的运作回归平衡。采用快速的改善方式去降低情绪重现的强度，可以缩减身体复原的时间。</p><h2 id="情绪重现的迹象"><a href="#情绪重现的迹象" class="headerlink" title="情绪重现的迹象"></a>情绪重现的迹象</h2><p>我们可能常常处在情绪重现中，却没有“看到重现”。然而，有许多线索能帮助我们辨识，其实自己正在经历情绪重现。这是疗愈中很重要的一件事，因为光是能点出我们正在经历的是情绪重现（情绪重现管理的第一步），往往就能立即让我们有所缓和。更重要的是，辨识情绪重现，会指引我们去做情绪重现管理的其他十二个步骤。</p><p>情绪重现的一个常见迹象，是我们会觉得渺小、无助、无望。在强烈的情绪重现中，这种感觉会强到变成羞耻感，羞耻到我们不愿意外出或露脸。</p><p>感到脆弱、紧张不安、易受伤，也是另一个呈现方式。幸存者可能会注意到，自己离家后所创建的自尊蒸发了。这是童年时家庭里不明说的规则——不准有自尊——的情绪重现。</p><p>另一个常见的情绪重现迹象，是内在或外在找碴鬼益发恶毒，通常是变得更夸张或更灾难化，还有更严厉的自我批判或批判他人。一个非常常见的例子是，落入极端化、全有全无的思考模式，像是只看得到自己或他人的哪里不好。</p><p>在我疗愈的中期，我学到了如果自己特别严重地论断别人，通常就代表我情绪重现至我就在苛刻的父母身边。诱发因子通常是因为我自己的一些脆弱之处占了上风，而我的反应是，过度注意别人的过错，这样我可以有借口逃避那些人，并且逃避被别人看到自己不光鲜状态的那种尴尬。</p><p>还有一个情绪重现的迹象，就是我们的情绪反应和诱发因子不成比例。两个常见的状况有：</p><ol><li>一件小小不愉快的事，却感觉像紧急大事般；</li><li>一点小小的不公平，就感觉像是严重的正义破裂。</li></ol><p>第一个状况举例来说，如果你掉了原本拿着的书，你就勃然大怒，狂骂自己好几个小时。第二个状况的例子是，别的驾驶人换线没打方向灯，虽然没有造成什么大害，可是引发你愤慨暴怒，在你心中回荡了数小时。</p><p>在这样的时候若我们缺乏觉察，便会对自己爆发自我厌恶和自我仇视，或者可能会不公平地对无辜的他人爆炸。</p><p>另一方面，一旦我们辨识出情绪重现是针对童年的真正危机和不公，就可以选择使用健康的情绪重现管理。此外，我们可以借由把情绪重现视为的确受到创伤的证明，而在疗愈中有所收获。当我们做到后者，就可以把我们的愤怒转化成健康愤慨，而对象是成长过程中可憎的不公不义。</p><h2 id="再谈自我药疗"><a href="#再谈自我药疗" class="headerlink" title="再谈自我药疗"></a>再谈自我药疗</h2><p>情绪重现的另一个迹象，是更加重地使用原始的自我纾解方式。很多幸存者早早就学会透过食物、令人分心的活动，或是改变情绪的物质，去管理自己痛苦的感受。一段时间后，自我药疗可能会变成一种习惯，并且恶化成物质成瘾或历程成瘾。</p><p>我相信自我药疗的严重程度是一个光谱，从一端是偶尔使用，到另一端的真正成瘾。对很多幸存者来说，自我药疗只是程度上的差别而已，但如果出现比平时更强烈地渴望使用更多的物质或历程，那就是强力的讯号，说明你正在经历情绪重现。</p><p>练习觉察突然高涨的渴望，把它解读为是时候该采取情绪重现管理步骤了。还有，我见到许多幸存者，透过有效地使用这些管理步骤，也渐渐地减少了自我药疗的习惯。</p><h2 id="治疗会谈中的情绪重现"><a href="#治疗会谈中的情绪重现" class="headerlink" title="治疗会谈中的情绪重现"></a>治疗会谈中的情绪重现</h2><p>这部分是写给正在接受心理治疗的幸存者，或是考虑接受治疗的幸存者。多年来，我注意到随着幸存者对我越来越有安全感，在会谈中处理情绪重现的机会也就变得更加频繁。有时候，甚至好像他们的某个部分已“计划”好，在会谈中或快要会谈时让情绪重现发作，有如他们希望在情绪重现管理方面能“边做边学”。有些治疗师认为，这是案主退化以创建健康自我（ego）的机制。</p><p>我最近有这样的经验：一位案主冲进我的办公室，她晚到了五分钟，看得出来很激动、很焦虑。她的开场白是大喊：“我真是个失败者！我什么都做不好！你一定对我很厌烦了。”这位案主曾经因为我认同她在我们的治疗工作中的成就而感动。</p><p>根据上次会谈中她揭露母亲会惩罚不完美，所以我很确定，迟到诱发了她的情绪重现。此刻她正经历着右脑的情绪主宰，以及左脑较弱的理性思考。如同情绪重现常有的状况，她暂时忘记了成年后的知识和理解，这似乎是一种解离机制。在此例中，它使这位案主忘记了我非常重视我们的合作。</p><p>我相信这种解离也造成了信任不断地被反复创建又失去，这在情绪重现中很常见，而随着疗愈的进展，我们将学到情绪重现会使我们忘记盟友事实上依然可靠。而且，透过足够的练习，我们可以学会把不信任可靠朋友的感觉，解读成情绪重现的讯号，是无人可信赖的童年的情绪重现。</p><h2 id="哀悼可以化解情绪重现"><a href="#哀悼可以化解情绪重现" class="headerlink" title="哀悼可以化解情绪重现"></a>哀悼可以化解情绪重现</h2><p>回到上一个案例。我对那位案主说出我的怀疑：“你觉得自己有没有可能正在经历情绪重现？”因为之前我们多次辨识过她的负面情绪其实就是情绪重现，所以她这次立刻辨识出来，放下，并且陷入深深的啜泣。</p><p>她掉入了深沉的哀悼。</p><p>她的哭泣结合了放松的泪水和哀悼的泪水，放松的泪水来自于能够接受我的同理心，哀悼的泪水则来自于释放糟糕的童年痛苦。而她放松的泪水也来自于记得这种困惑，与难以承受的痛苦来源。</p><p>她继续哭着，释放原本的创伤痛苦。在情绪重现中，有很多眼泪可能哭不出来。</p><p>她停止哭泣后，回忆起小时候在圣诞袜中收到一颗煤块，因为她恶劣的母亲以此惩罚她晚了十分钟上餐桌。她的眼泪马上变成了对此虐待的健康愤怒，并且觉得自己回到了有力量的自我。这是哀悼把她带回到现在，并打破了情绪重现的失忆。</p><p>然后她记得要唤起自我保护的本能，我们已经透过角色扮演和自我表达训练，渐进地在重建这本能。于是她愤怒地抱怨父母如何破坏她捍卫自己、抵抗虐待和不公的权利，开始厚着脸皮反复地喊：“不公平！”好像在告诉她的父母，他们再也没办法因为她这么说而攻击她。</p><p>她接着重申自己有权拥有界线，讥笑她的父母不配当父母。然后，她把愤怒转向找碴鬼，响亮地对它说：“不！”“不，你不能论断我。不，你不能再撕裂我了。不，你不能用你愚蠢的担心浪费我的时间！”</p><p>最后，我提醒她要再唤起自己的安全感，记得自己现在处于成人的身体里，她也不再受到父母的控制；她有很多资源可用：聪明、力量、恢复力、归属感；她住在安全的家中；她有治疗师和两位朋友的支持，我们是她的盟友，随时看得到她本质的价值。</p><p>我也告诉她我的观察：她的情绪重现管理能力持续地在进步，而且她的情绪重现越来越少发作，也越来越不强烈了。</p><p>过了大约四十分钟，她从情绪重现中解脱。我多次见证哀悼的这种修复力量。</p><h2 id="管理内在找碴鬼"><a href="#管理内在找碴鬼" class="headerlink" title="管理内在找碴鬼"></a>管理内在找碴鬼</h2><p>CPTSD幸存者成年并脱离创伤家庭后，通常不会意识到自己的心智受到内在找碴鬼所主宰。我在帮助他人管理情绪重现时，最常提供的帮助，就是鼓励他们挑战那个危言耸听和完美主义的找碴鬼。</p><p>我的心理治疗工作中常发生这种状况：一位案主正在说着一个无关紧要的小过失，却突然进入灾难化的说法。他的说法来自于内在找碴鬼恶梦般的幻想，认为他的人生正分崩离析、每况愈下、充满灾难……那是他童年持续被过度惩罚时的情绪重现。</p><p>我的一位案主极端化的状况像是这样：“今天早上我上完厕所回到座位，我的老板看我的眼神怪怪的。我知道，他一定认为我又懒又笨，他想开除我了。我知道，我会找不到下一份工作，我的女朋友会认为我是个废物，并且离开我，我会因为压力而生病，而且没钱付医疗保险和租金。很快的，我就得靠购物推车过活。”许多夸张的内在找碴鬼嚷嚷，都是以流落街头作结。这相当令人不安，完全是遗弃的象征啊！</p><p>复原需要能够辨识内在找碴鬼的灾难化，这样我们才能用“思考中断法”和“思考修正法”去对抗它。在这个例子中，我提醒我的案主，我们已经多次发现他的找碴鬼，为了他的人生可能完蛋的各种方式而“抓狂”。然后，我鼓励他拒绝沉溺在这个过程中，也鼓励他，只要找碴鬼试图吓他或贬低他，就对找碴鬼愤怒地说“不”。</p><p>最后，我提醒他各种实际上和老板有过的正面经验（思考修正法），也协助他列举工作上、学业上、人生中的各种成功经验。</p><p>内在找碴鬼不只会加重情绪重现，还会变成诱发情绪重现的心理作用。下两章将会谈及如何翻转找碴鬼的伤害。</p><h2 id="进阶的情绪重现管理"><a href="#进阶的情绪重现管理" class="headerlink" title="进阶的情绪重现管理"></a>进阶的情绪重现管理</h2><h3 id="在遗弃性的忧郁中醒来"><a href="#在遗弃性的忧郁中醒来" class="headerlink" title="在遗弃性的忧郁中醒来"></a>在遗弃性的忧郁中醒来</h3><p>随着疗愈的进展，你会注意到诱发过程的更多微妙之处，然后变得更能够觉察内在找碴鬼不易被发现的诱发因子。你也会发现，有些诱发因子很难辨识，尤其是睡着时发生的状况。</p><p>我现在认为是“为自己孤独”的老痛苦。这常会使我哭泣，但也常让我从情绪重现中解脱。</p><h3 id="弹性地使用情绪重现管理步骤"><a href="#弹性地使用情绪重现管理步骤" class="headerlink" title="弹性地使用情绪重现管理步骤"></a>弹性地使用情绪重现管理步骤</h3><p>海伦在会谈的开场白，是深深的自我疏离：“我就是个没希望的个案。昨天我把自己卡在很糟的情绪重现里，完全没有原因。而且那不是你一直告诉我的，那种无法搞懂的起床情绪重现，我整个早上都还好，然后……砰！我就发作了，一直到现在，而且没有任何蠢诱发因子。没有任何事情引发它，就是我，毫无希望地搞砸了！我脑袋坏了！”</p><p>辨识情绪重现的诱发因子是个滑坡（slipperyslope）3。认出诱发因子常常可以使我们为了停止情绪重现，而责难自己和厌恨自己，但我们并不总是能找出诱发因子。这种情况，寻找诱发因子可以很快地劣化成自我病理化的活体解剖。随着落入情绪重现的深渊，这个滑坡很快地会变成悬崖。</p><p>这几乎是观点的问题，在寻找诱发因子时，是来自于支持自己，还是来自于找麻烦？如果是后者，那最好别再找诱发因子，而改成提取自我接纳，毕竟总是会有我们无法理解的诱发因子。这种时候，这个自我支持的过程需要胜过“把一切弄清楚”的健康欲望。</p><p>当你拼命想要搞定情绪重现时，如果这个努力会变得使你对自己恼怒或对自己失望，那么自我接纳的过程就需要胜过这个努力。如前所述，有时候整体上你所能做到的最好理解，就是“你的内在小孩正深深地感到被遗弃”。他正因为找碴鬼的羞辱攻击而蜷缩害怕，并且需要你做出改变，证明你无论如何都会爱护他。</p><h3 id="存在性的诱发因子"><a href="#存在性的诱发因子" class="headerlink" title="存在性的诱发因子"></a>存在性的诱发因子</h3><p>许多心理学家使用“存在”一词来描述一个事实：所有的人类都会遇上痛苦的事件。有些是每个人时不时都会经历的正常且反复出现的痛苦，恐怖的国际事件、困难的抉择、疾病、偶尔感到凄苦孤独，都是存在性痛苦的常见例子。存在性的苦难对于CPTSD幸存者来说，特别容易诱发情绪重现，因为我们通常有非常多原生家庭的不幸，可诱发情绪重现。</p><p>另一个特别会诱发情绪重现的存在性现象，就是我们都会遭受看不见、不可预测的情绪变化。好心情有时候会莫名其妙地变成坏心情，好像小说家大卫‧米切（DavidMitchell）所写的：“好心情脆弱如蛋……而坏心情脆弱如砖。”</p><p>无法预测的情绪变化通常会造成CPTSD的问题，能很快地诱发情绪重现大发作，这往往是因为你以前展现自己全面的感受时会受到惩罚或遗弃，所以现在，基于旧习，你心情变坏时，你就会自动地解离。</p><p>这时，内在小孩常会觉得，你又回到了疗愈前那个没空感觉的人。这小孩于是觉得自己再度被困在那个具毁灭性、遗弃的过去，而导致情绪重现或许是他唯一能够引起你注意的办法。</p><p>这就是为什么我试着尽可能用无条件的正向关怀，把我的缺省立场转向自己和我的内在小孩。</p><h2 id="后期的疗愈"><a href="#后期的疗愈" class="headerlink" title="后期的疗愈"></a>后期的疗愈</h2><p>当复原的程度足够，你会理解到，情绪重现的痛苦大多是合宜的，那只是童年受虐和忽略的延迟反应。由此，你可用化解情绪重现的方式去处理感受，并且创建越来越健康的自我。</p><p>接着，这会开始减少你那未化解的童年痛苦——那个点燃你情绪重现的痛苦。情绪重现的频率于是变得较少，强度变弱，也比较让人能够承受。后来，你一发现自己被诱发情绪重现，就会学着唤醒你的自我保护本能。</p><p>随着情绪重现渐少，并且变得更容易管理，它周围所创建的防卫机制（自恋、强迫性、解离或关系依赖等），也会变得更容易瓦解。</p><p>在你复原的这个阶段，当你脱离一个情绪重现时，你可能会“讽刺地”感到满意。在觉知的许多层面里，你或许会感觉到在父母屋檐下的童年生活，远比你以为的更糟，但同时你可能会感到解脱了，因为现在的你已经比起以前父母破坏你人生的时候，更自由了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;诱发因子是会引发情绪重现的外在或内在刺激，通常发生在正常意识之外的潜意识层次，因此要辨识什么会诱发我们的情绪重现，可能很困难。但是，能够越来越觉察诱发引子，是至关重要的事，因为它有时候能让我们避开引发情绪重现的人、情境和行为。&lt;/p&gt;</summary>
    
    
    
    <category term="心理" scheme="https://sajlle.github.io/categories/%E5%BF%83%E7%90%86/"/>
    
    
    <category term="CPTSD" scheme="https://sajlle.github.io/tags/CPTSD/"/>
    
  </entry>
  
  <entry>
    <title>如何帮助儿童管理情绪重现？</title>
    <link href="https://sajlle.github.io/2023/09/10/%E5%A6%82%E4%BD%95%E5%B8%AE%E5%8A%A9%E5%84%BF%E7%AB%A5%E7%AE%A1%E7%90%86%E6%83%85%E7%BB%AA%E9%87%8D%E7%8E%B0%EF%BC%9F/"/>
    <id>https://sajlle.github.io/2023/09/10/%E5%A6%82%E4%BD%95%E5%B8%AE%E5%8A%A9%E5%84%BF%E7%AB%A5%E7%AE%A1%E7%90%86%E6%83%85%E7%BB%AA%E9%87%8D%E7%8E%B0%EF%BC%9F/</id>
    <published>2023-09-10T14:38:25.000Z</published>
    <updated>2023-09-10T06:59:48.020Z</updated>
    
    <content type="html"><![CDATA[<p>这个清单是给社工、老师、亲戚、邻居和朋友，用来帮助创伤家庭的孩子们。这清单是根据本章一开始的步骤调整而来，而根据小孩的年龄，有些步骤可能比其他步骤更适合。即使你并非处于帮助儿童的角色，也请为你的内在小孩至少读过一次。</p><span id="more"></span><ol><li><p>帮助小孩发展对情绪重现的觉察：“你以前什么时候有过这种感觉？这是不是有人对你很坏时的感觉？”</p></li><li><p>展示“觉得危险并不代表你身陷危险”。教他们有些地方比其他地方安全。用温柔、轻松的语调说：“也许你可以和我一起休息一下。”“你在我身边很安全。”“这里没有人可以伤害你。”</p></li><li><p>示范有大人在乎他的照料和保护，目标是成为这孩子的第一个安全关系。帮孩子与其他安全、爱护他的大人、团体或社团创建链接。</p></li><li><p>用舒缓、可靠的方式对孩子说话。平衡“爱与限制”：每一个负面要有五个正面。慈爱地设立限制。</p></li><li><p>引导孩子的思绪回到他自己的身体，以减少过度换气和过度刺激。<br> A. 教他系统性地放松主要肌肉群。<br> B. 教他深深的、慢慢的腹式呼吸。<br> C. 鼓励他放慢，以减少会增加恐惧的匆促。<br> D. 教他冷静、集中注意力的活动，像是画画、合气道、太极、瑜伽、伸展活动。<br> E. 辨识安全的地方，并鼓励他到那里避静。</p></li><li><p>教他“用说的”。在有些家庭中，说话是危险的，而言语抒发可以释放痛苦与恐惧，并重建应对技巧。</p></li><li><p>帮助他哀悼安全感的逝去。虐待和忽略会导致悲伤和愤怒，哭泣则会释放恐惧。以不伤害他人的方式宣泄愤怒，可以创建安全感。</p></li><li><p>缩小内在找碴鬼。让大脑变得更为“使用者友善”，更加地觉察对自己说负面的话，和基于恐惧的幻想。教他思考中断法和思考取代法：帮助他创建一个清单，可以记得他的好处、优势、成就和资源。</p></li><li><p>帮助他辨识自己的4F类型，以及那个类型的优点。使用象征法、歌曲、卡通或电影角色。战：金刚战士；逃：蓝色哔哔鸟、巴布工程师；僵：降世神通；讨好：芝麻街的格罗弗。</p></li><li><p>教育他这些权利和需求：界线、说不、抗议不公平、寻求负责的大人保护。</p></li><li><p>辨识并且避开危险的人、地方和活动（例如，超人会避开氪石，运动明星不嗑药）。</p></li><li><p>破解永恒式的思考。创造可得的未来的鲜明景象，那里更安全、更友善、更富足，并以类似的成功故事举例。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个清单是给社工、老师、亲戚、邻居和朋友，用来帮助创伤家庭的孩子们。这清单是根据本章一开始的步骤调整而来，而根据小孩的年龄，有些步骤可能比其他步骤更适合。即使你并非处于帮助儿童的角色，也请为你的内在小孩至少读过一次。&lt;/p&gt;</summary>
    
    
    
    <category term="心理" scheme="https://sajlle.github.io/categories/%E5%BF%83%E7%90%86/"/>
    
    
    <category term="CPTSD" scheme="https://sajlle.github.io/tags/CPTSD/"/>
    
  </entry>
  
  <entry>
    <title>管理情绪重现的十三个步骤</title>
    <link href="https://sajlle.github.io/2023/09/10/%E7%AE%A1%E7%90%86%E6%83%85%E7%BB%AA%E9%87%8D%E7%8E%B0%E7%9A%84%E5%8D%81%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4/"/>
    <id>https://sajlle.github.io/2023/09/10/%E7%AE%A1%E7%90%86%E6%83%85%E7%BB%AA%E9%87%8D%E7%8E%B0%E7%9A%84%E5%8D%81%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4/</id>
    <published>2023-09-10T14:12:05.000Z</published>
    <updated>2023-09-10T07:00:04.484Z</updated>
    
    <content type="html"><![CDATA[<p>当你困在情绪重现中，你就是在重新经历童年最糟的情绪，一切都令人难以承受和困惑, 你会觉得很渺小、脆弱、无助；一切都觉得很困难；当下感觉人生非常可怕；被他人看见，会感到极其痛苦的脆弱。</p><p>本文介绍了管理情绪重现的十三个步骤，帮助你降低情绪重现袭来之时的痛苦感受。</p><span id="more"></span><h2 id="什么是情绪重现"><a href="#什么是情绪重现" class="headerlink" title="什么是情绪重现"></a>什么是情绪重现</h2><p>对于难以承受的童年遗弃感受，情绪重现是极为扰人的退化情况（杏仁核绑架），一旦你卡在情绪重现中时，恐惧、羞耻或忧郁便可能掌控了你的感觉。情绪重现有着一些共同的现象：你会觉得很渺小、脆弱、无助；一切都觉得很困难；当下感觉人生非常可怕；被他人看见，会感到极其痛苦的脆弱；你的电池好像没电了。在最糟的情绪重现里，你会觉得世界末日马上就要发生在你身上。</p><p><mark style="background: #FF5582A6;">当你困在情绪重现中，你就是在重新经历童年最糟的情绪，一切都令人难以承受和困惑</mark>，尤其是因为CPTSD的情绪重现鲜少有视觉成分。这是因为，如高曼的研究显示，“杏仁核绑架”是脑部的情绪记忆部分有强烈的反应，压过了理性的脑部部位。被引发4F反应的人，他们的大脑频繁地有这种反应，以至于小事也能引发恐慌感受。</p><h2 id="管理情绪重现的十三个步骤"><a href="#管理情绪重现的十三个步骤" class="headerlink" title="管理情绪重现的十三个步骤"></a>管理情绪重现的十三个步骤</h2><p>以下的清单列出了十三个实用步骤，可以帮助你管理情绪重现（情绪重现时，聚焦在粗体字的部分）：</p><ol><li><p><strong>对自己说：</strong>“<strong>我正在经历情绪重现。</strong>”情绪重现把你带到没有时间感的内心，让你感到无助、绝望、身处险境，如同你的童年。但是，你正在感受的这些感觉是过去的记忆，现在已经无法伤害你。</p></li><li><p><strong>提醒自己：</strong>“<strong>我感到害怕，但我没有危险！我现在很安全。</strong>” 记得你现在是处于安全的当下，远离了过去的危险。</p></li><li><p><strong>承认自己有界线的权利和需求</strong>。提醒你自己，你不必允许任何人错待你；你可以自由地离开危险的情境，并且抗议不公平的行为。</p></li><li><p><strong>安慰鼓励的对内在小孩说话</strong>。你的内在小孩需要知道你无条件地爱他，知道当他觉得迷失或害怕时，可以寻求你的安慰和保护。</p></li><li><p><strong>破解伤痛永恒的想法</strong>。在儿时，恐惧和遗弃感觉像是永无止尽，安全的未来是难以想像的。但记得，这个情绪重现会过去，就像它以往种种总是会过去一样。</p></li><li><p><strong>提醒自己现在是处于成人的身体中</strong>，有你儿时所没有的盟友、技巧和资源可以提供保护（觉得脆弱渺小是情绪重现的一个征兆）。</p></li><li><p><strong>重回你的身体</strong>。恐惧会使你过度用脑地担忧，或是麻木和放空。</p><p> A.  温和地告诉自己的身体要放松：感觉你的每一个主要肌肉群，温柔地鼓励它们放松（紧绷的肌肉会传送错误的危险讯号到你的大脑）。</p><p> B. 深深地、慢慢地呼吸（憋气也会传送危险讯号）。</p><p> C. 放慢。急躁会使你的大脑打开逃反应。</p><p> D. 找个安全的地方，去放松和舒缓自己：用毯子包住自己、抱着枕头或填充动物玩偶、躺在床上、躺在衣柜里、泡澡，或是小睡一下。</p><p> E. 感觉你身体的恐惧，但不做反应。恐惧只是你身体的一股能量，只要你不逃避它，它就无法伤害你。</p></li><li><p><strong>抗拒内在找碴鬼的夸大和灾难化</strong>。</p><p> A. 使用思考中断法，去停止找碴鬼没完没了地夸大危险，和总是计划控制无法控制的一切。拒绝羞辱、仇恨或遗弃你自己。把自我攻击的愤怒，用来对找碴鬼不公平的自我苛责说：“不！”</p><p> B. 使用思考取代法和思考修正法，记住一连串你的优点和成就，去取代负面思考。</p></li><li><p><strong>允许自己哀悼</strong>。情绪重现是释放陈旧压抑的恐惧、伤害和遗弃的机会，可借以肯定并且安抚内在小孩过往无助且绝望的经历。健康的哀悼能把你的眼泪转化成自我怜悯，也能把你的愤怒转化为自我保护。</p></li><li><p><strong>培养安全的关系和寻求支持</strong>。需要的话，花些时间独处，但不要让羞耻感隔绝你，感到羞耻不代表你就是可耻的。教育你的亲密他人，什么是情绪重现，并请他们帮助你在情绪重现时，用谈话和感受去度过它。</p></li><li><p><strong>学习辨识会引起情绪重现的诱发因子</strong>。避开不安全的人、地方、活动和会引发情绪重现的心智活动。如果诱发因子是无可避免的，就用这些步骤练习预防措施。</p></li><li><p><strong>搞清楚情绪重现了什么经历</strong>。情绪重现是发现、肯定、疗愈过往受虐和遗弃伤口的机会，它们也能指向你未满足的发展需求，并且能使你有动机去满足那些需求。</p></li><li><p><strong>对缓慢的复原过程要有耐心</strong>。现在你需要时间去降低肾上腺素的运作，以及未来需要很多时间，去渐渐降低情绪重现的强度、持续时间和频率。真正的复原是渐进的过程，常常前进两步就后退一步，而非一蹴而就的救赎幻想。所以，不要为了情绪重现的发生而打击自己。</p></li></ol><p>我有些案主把这个清单贴在容易看见的地方，直到他们能够记得那些重点，这让他们的复原进度通常较为迅速。你也可以打印我网站上的“十三步骤”网页：<a href="http://www.pete-walker.com./">www.pete-walker.com。</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当你困在情绪重现中，你就是在重新经历童年最糟的情绪，一切都令人难以承受和困惑, 你会觉得很渺小、脆弱、无助；一切都觉得很困难；当下感觉人生非常可怕；被他人看见，会感到极其痛苦的脆弱。&lt;/p&gt;
&lt;p&gt;本文介绍了管理情绪重现的十三个步骤，帮助你降低情绪重现袭来之时的痛苦感受。&lt;/p&gt;</summary>
    
    
    
    <category term="心理" scheme="https://sajlle.github.io/categories/%E5%BF%83%E7%90%86/"/>
    
    
    <category term="CPTSD" scheme="https://sajlle.github.io/tags/CPTSD/"/>
    
  </entry>
  
  <entry>
    <title>vue-router一键入门</title>
    <link href="https://sajlle.github.io/2023/05/10/vue-router%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/"/>
    <id>https://sajlle.github.io/2023/05/10/vue-router%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/</id>
    <published>2023-05-09T16:04:33.000Z</published>
    <updated>2023-05-09T08:08:40.392Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：概念介绍，配置路由，嵌套路由，动态路由，编程式导航，路由守卫</p><span id="more"></span><h2 id="啥是路由？"><a href="#啥是路由？" class="headerlink" title="啥是路由？"></a>啥是路由？</h2><p>路由是对应关系<br>路由分为两类：前端路由和后端路由</p><p>后端路由指的是：请求方式、请求地址与 function 处理函数之间的对应关系。</p><h3 id="SPA-与前端路由"><a href="#SPA-与前端路由" class="headerlink" title="SPA 与前端路由"></a>SPA 与前端路由</h3><p>SPA 指的是一个 web 网站只有唯一的一个 HTML 页面，所有组件的展示与切换都在这唯一的一个页面内完成。 此时，不同组件之间的切换需要通过前端路由来实现。</p><p>在 SPA 项目中，不同功能之间的切换，要依赖于前端路由来完成</p><h3 id="啥是前端路由？"><a href="#啥是前端路由？" class="headerlink" title="啥是前端路由？"></a>啥是前端路由？</h3><p>Hash 地址与组件之间的对应关系</p><h3 id="前端路由的工作方式"><a href="#前端路由的工作方式" class="headerlink" title="前端路由的工作方式"></a>前端路由的工作方式</h3><p>① 用户点击了页面上的路由链接<br>② 导致了 URL 地址栏中的 Hash 值发生了变化<br>③ 前端路由监听了到 Hash 地址的变化<br>④ 前端路由把当前 Hash 地址对应的组件渲染都浏览器中</p><h2 id="vue-router-的基本使用"><a href="#vue-router-的基本使用" class="headerlink" title="vue router 的基本使用"></a>vue router 的基本使用</h2><h3 id="啥是vue-router"><a href="#啥是vue-router" class="headerlink" title="啥是vue router"></a>啥是vue router</h3><p>vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目 中组件的切换</p><h3 id="vue-router-的版本"><a href="#vue-router-的版本" class="headerlink" title="vue-router 的版本"></a>vue-router 的版本</h3><p>vue-router 目前有 3.x 的版本和 4.x 的版本。</p><ul><li>vue-router 3.x 只能结合 vue2 进行使用</li><li>vue-router 4.x 只能结合 vue3 进行使用</li></ul><h3 id="vue-router-4-x的使用步骤"><a href="#vue-router-4-x的使用步骤" class="headerlink" title="vue router 4.x的使用步骤"></a>vue router 4.x的使用步骤</h3><p>① 在项目中安装 vue-router </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-router@next</span><br></pre></td></tr></tbody></table></figure><p>② 定义路由组件<br>在项目中定义 MyHome.vue、MyMovie.vue、MyAbout.vue 三个组件，将来要使用 vue-router 来控制它们 的展示与切换：<br>③ 声明路由链接和占位符<br>使用 标签来声明路由链接，并使用 标签来声明路由占位符</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt; App 根组件 &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--声明路由链接--&gt;</span><br><span class="line">&nbsp;&lt;router-link to="/home"&gt;home&lt;/router-link&gt; |</span><br><span class="line">&nbsp;&lt;router-link to="/movie"&gt;movie&lt;/router-link&gt; |</span><br><span class="line">&nbsp;&lt;router-link to="/about"&gt;movie&lt;/router-link&gt; </span><br><span class="line">&lt;!--声明占位符--&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>④ 创建路由模块<br>从 vue-router 中按需导入两个方法 </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createRouter, createWebHashHistory } <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br></pre></td></tr></tbody></table></figure><p>导入需要使用路由控制的组件 </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">'./components/Home.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">'./components/About.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Movie</span> <span class="keyword">from</span> <span class="string">'./components/Movie.vue'</span></span><br></pre></td></tr></tbody></table></figure><p>创建路由实例对象 </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>({</span><br><span class="line">&nbsp; &nbsp; <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">&nbsp; &nbsp; <span class="attr">routes</span>: [</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">component</span>: <span class="title class_">Home</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/movie'</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: <span class="title class_">About</span>},</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>向外共享路由实例对象 </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></tbody></table></figure><p>在 main.js 中导入并挂载路由模块</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router.js'</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">'#app'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="vue-router的高级用法"><a href="#vue-router的高级用法" class="headerlink" title="vue router的高级用法"></a>vue router的高级用法</h2><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。 通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>({</span><br><span class="line">&nbsp; &nbsp; <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">&nbsp; &nbsp; <span class="attr">routes</span>: [</span><br><span class="line">&nbsp; &nbsp; <span class="comment">// redirected to home page</span></span><br><span class="line">&nbsp; &nbsp; {<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/home'</span>},</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">component</span>: <span class="title class_">Home</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/movie'</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: <span class="title class_">About</span>},</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="路由高亮"><a href="#路由高亮" class="headerlink" title="路由高亮"></a>路由高亮</h3><p>可以通过如下的两种方式，将激活的路由链接进行高亮显示： ① 使用默认的高亮 class 类<br>② 自定义路由高亮的 class 类</p><h4 id="默认的高亮-class-类"><a href="#默认的高亮-class-类" class="headerlink" title="默认的高亮 class 类"></a>默认的高亮 class 类</h4><p>被激活的路由链接，默认会应用一个叫做 router-link-active 的类名。开发者可以使用此类名选择器，为激活 的路由链接设置高亮的样式：</p><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.router-link-active</span>{</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义路由高亮的-class-类"><a href="#自定义路由高亮的-class-类" class="headerlink" title="自定义路由高亮的 class 类"></a>自定义路由高亮的 class 类</h4><p>在创建路由的实例对象时，开发者可以基于 linkActiveClass 属性，自定义路由链接被激活时所应用的类名</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>({</span><br><span class="line">&nbsp; &nbsp; <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">&nbsp; &nbsp; <span class="attr">linkActiveClass</span>: <span class="string">'router-link'</span>,</span><br><span class="line">&nbsp; &nbsp; <span class="attr">routes</span>: [</span><br><span class="line">&nbsp; &nbsp; {<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/home'</span>},</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">component</span>: <span class="title class_">Home</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/movie'</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: <span class="title class_">About</span>},</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>通过路由实现组件的嵌套展示，叫做嵌套路由。</p><p>如何嵌套路由？<br>① 声明子路由链接和子路由占位符</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&nbsp; &lt;h1&gt;About page&lt;/h1&gt;</span><br><span class="line">&nbsp; &lt;router-link to="/about/tab1"&gt;tab1&lt;/router-link&gt; |</span><br><span class="line">&nbsp; &lt;router-link to="/about/tab2"&gt;tab2&lt;/router-link&gt;</span><br><span class="line">&nbsp; &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>② 在父路由规则中，通过 children 属性嵌套声明子路由规则</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tab1</span> <span class="keyword">from</span> <span class="string">'./components/Tab1.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab2</span> <span class="keyword">from</span> <span class="string">'./components/Tab2.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>({</span><br><span class="line">&nbsp; &nbsp; <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">&nbsp; &nbsp; <span class="attr">linkActiveClass</span>: <span class="string">'router-link'</span>,</span><br><span class="line">&nbsp; &nbsp; <span class="attr">routes</span>: [</span><br><span class="line">&nbsp; &nbsp; {<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/home'</span>},</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">component</span>: <span class="title class_">Home</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'/movie'</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>, <span class="attr">name</span>:<span class="string">'mov'</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="attr">path</span>: <span class="string">'/about'</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="attr">redirect</span>: <span class="string">'/about/tab1'</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="attr">children</span>: [</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'tab1'</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { <span class="attr">path</span>: <span class="string">'tab2'</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。在 vue-router 中 使用英文的冒号（:）来定义路由的参数项。</p><p>示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">path</span>: <span class="string">'/movie/:id'</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>},</span><br></pre></td></tr></tbody></table></figure><h4 id="route-params-参数对象"><a href="#route-params-参数对象" class="headerlink" title="$route.params 参数对象"></a>$route.params 参数对象</h4><p>通过动态路由匹配的方式渲染出来的组件中，可以使用 $route.params 对象访问到动态匹配的参数值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;h1&gt;Movie Page {{$route.params.id}}&lt;/h1&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&nbsp; &lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-props-接收路由参数"><a href="#使用-props-接收路由参数" class="headerlink" title="使用 props 接收路由参数"></a>使用 props 接收路由参数</h4><p>为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参。示例代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{path:'/movie/:id', component:Movie, props:true}</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h2&gt;movie 组件 ---- {{id}}&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default{</span><br><span class="line">props:["id"]</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>通过调用 API 实现导航的方式，叫做编程式导航。与之对应的，通过点击链接实现导航的方式，叫做声明式导 航。</p><p>例如： 普通网页中点击 链接、vue 项目中点击 都属于声明式导航  </p><p>普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航</p><h4 id="vue-router-中的编程式导航api"><a href="#vue-router-中的编程式导航api" class="headerlink" title="vue router 中的编程式导航api"></a>vue router 中的编程式导航api</h4><p>vue-router 提供了许多编程式导航的 API，其中最常用的两个 API 分别是<br>① <code>this.$router.push('hash 地址')</code> 跳转到指定 Hash 地址，从而展示对应的组件<br>② <code>this.$router.go(数值 n)</code> 实现导航历史的前进、后退</p><h5 id="router-push"><a href="#router-push" class="headerlink" title="$router.push"></a>$router.push</h5><p>调用 this.$router.push() 方法，可以跳转到指定的 hash 地址</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;h1&gt;Home page&lt;/h1&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;button @click="gotoMovie(3)"&gt;go to Movie&lt;/button&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&nbsp; &lt;/template&gt;</span><br><span class="line">&nbsp; </span><br><span class="line">&nbsp; &lt;script&gt;</span><br><span class="line">&nbsp; &nbsp; export default{</span><br><span class="line">&nbsp; &nbsp; &nbsp; methods:{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; gotoMovie(id){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // this.$router.push(`/movie/${id}`)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.$router.push({name:'mov', params:{id:1}})</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="router-go"><a href="#router-go" class="headerlink" title="$router.go"></a>$router.go</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;h1&gt;Movie Page {{$route.params.id}} --- {{id}}&lt;/h1&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;button @click="goback"&gt;go back&lt;/button&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&nbsp; &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&nbsp; &lt;script&gt;</span><br><span class="line">&nbsp; &nbsp; export default{</span><br><span class="line">&nbsp; &nbsp; &nbsp; name:'Movie',</span><br><span class="line">&nbsp; &nbsp; &nbsp; props:["id"],</span><br><span class="line">&nbsp; &nbsp; &nbsp; methods:{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; goback(){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.$router.go(-1)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>通过 name 属性为路由规则定义名称的方式，叫做命名路由。<br>命名路由的 name 值不能重复，必须保证唯一性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="attr">path</span>: <span class="string">'/movie'</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>, <span class="attr">name</span>:<span class="string">'mov'</span> }</span><br></pre></td></tr></tbody></table></figure><h4 id="使用命名路由实现声明式导航"><a href="#使用命名路由实现声明式导航" class="headerlink" title="使用命名路由实现声明式导航"></a>使用命名路由实现声明式导航</h4><p>为 标签动态绑定 to 属性的值，并通过 name 属性指定要跳转到的路由规则。期间还可以用 params 属性指定跳转期间要携带的路由参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;h1&gt;Home page&lt;/h1&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;button @click="gotoMovie(3)"&gt;go to Movie&lt;/button&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;router-link :to="{name:'mov', params:{id:3}}"&gt;go to movie&lt;/router-link&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;!-- 注意冒号不能少 --&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&nbsp; &lt;/template&gt;</span><br><span class="line">&nbsp; </span><br><span class="line">&nbsp; &lt;script&gt;</span><br><span class="line">&nbsp; &nbsp; export default{</span><br><span class="line">&nbsp; &nbsp; &nbsp; methods:{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; gotoMovie(id){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.$router.push(`/movie/${id}`)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // this.$router.push({name:'mov', params:{id:1}})</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="使用命名路由实现编程式导航"><a href="#使用命名路由实现编程式导航" class="headerlink" title="使用命名路由实现编程式导航"></a>使用命名路由实现编程式导航</h5><p>调用 push 函数期间指定一个配置对象，name 是要跳转到的路由规则、params 是携带的路由参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;h1&gt;Home page&lt;/h1&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;button @click="gotoMovie(3)"&gt;go to Movie&lt;/button&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;router-link :to="{name:'mov', params:{id:3}}"&gt;go to movie&lt;/router-link&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;!-- 注意冒号不能少 --&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&nbsp; &lt;/template&gt;</span><br><span class="line">&nbsp; </span><br><span class="line">&nbsp; &lt;script&gt;</span><br><span class="line">&nbsp; &nbsp; export default{</span><br><span class="line">&nbsp; &nbsp; &nbsp; methods:{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; gotoMovie(id){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //this.$router.push(`/movie/${id}`)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.$router.push({name:'mov', params:{id:1}})</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>导航守卫可以控制路由的访问权限。</p><h4 id="如何声明全局导航守卫"><a href="#如何声明全局导航守卫" class="headerlink" title="如何声明全局导航守卫"></a>如何声明全局导航守卫</h4><p>全局导航守卫会拦截每个路由规则，从而对每个路由进行访问权限的控制。可以按照如下的方式定义全局导航 守卫.</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter{(...)}</span><br><span class="line">router.<span class="title function_">beforeEach</span>(fn)</span><br></pre></td></tr></tbody></table></figure><h4 id="守卫方法的-3-个形参"><a href="#守卫方法的-3-个形参" class="headerlink" title="守卫方法的 3 个形参"></a>守卫方法的 3 个形参</h4><p>全局导航守卫的守卫方法中接收 3 个形参，格式为：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>{</span><br><span class="line"><span class="comment">// to 目标路由对象</span></span><br><span class="line"><span class="comment">// from 当前导航要离开的路由对象</span></span><br><span class="line"><span class="comment">// next 是一个函数，表示是否放行</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="next-函数的-3-种调用方式"><a href="#next-函数的-3-种调用方式" class="headerlink" title="next 函数的 3 种调用方式"></a>next 函数的 3 种调用方式</h4><ul><li>直接放行：next() </li><li>强制其停留在当前页面：next(false) </li><li>强制其跳转到登录页面：next(‘/login’)</li></ul><h4 id="结合-token-控制后台主页的访问权限"><a href="#结合-token-控制后台主页的访问权限" class="headerlink" title="结合 token 控制后台主页的访问权限"></a>结合 token 控制后台主页的访问权限</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> token = localStorge.<span class="title function_">getItem</span>(<span class="string">'token'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">path</span>===<span class="string">'/main'</span> &amp;&amp; !token){</span><br><span class="line"><span class="title function_">next</span>(<span class="string">'/login'</span>)</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要内容：概念介绍，配置路由，嵌套路由，动态路由，编程式导航，路由守卫&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="工具使用" scheme="https://sajlle.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="vue" scheme="https://sajlle.github.io/tags/vue/"/>
    
    <category term="vue-router" scheme="https://sajlle.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vue3基础一键入门</title>
    <link href="https://sajlle.github.io/2023/05/02/vue3%E5%9F%BA%E7%A1%80%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/"/>
    <id>https://sajlle.github.io/2023/05/02/vue3%E5%9F%BA%E7%A1%80%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/</id>
    <published>2023-05-01T16:30:04.000Z</published>
    <updated>2023-05-05T01:53:19.512Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学vue，开始创建项目的时候用npm总是失败，改用yarn才ok。<br>这是一篇基础记录帖。想看高级的请绕道哦。</p><span id="more"></span><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue</span><br><span class="line"></span><br><span class="line">yarn create vite my-vite-project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> my-vite-project</span><br><span class="line">yarn </span><br><span class="line">yarn dev</span><br></pre></td></tr></tbody></table></figure><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&nbsp; &nbsp; export default{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; data(){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg:'hello, world',</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; url:'https://www.baidu.com/',</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count:0</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; },</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; methods:{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addOne(){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.count += 1</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changeWorld(){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let arr = this.msg.split('')</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.msg=arr.reverse().join('')</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="简单指令大全"><a href="#简单指令大全" class="headerlink" title="简单指令大全"></a>简单指令大全</h2><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p> v-bind语法和简写  </p><ul><li>语法：v-bind:属性名=”vue变量” </li><li>简写：:属性名=”vue变量”<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a :href="url" @click="preventBaidu(1,$event)"&gt;preventDefault&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3></li><li>语法：<ul><li>v-on: 事件名称=”函数”</li><li>简写：@事件名称=”函数”<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a :href="url" @click="btn"&gt;zuzhibaidumorentiaozhuan&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="v-on获取事件对象"><a href="#v-on获取事件对象" class="headerlink" title="v-on获取事件对象"></a>v-on获取事件对象</h3><ul><li>无形参<ul><li>@事件名称=”函数”</li><li>methods里的函数：<code>func(e){{e.preventDefault()}</code></li></ul></li><li>有形参<ul><li><code>@事件名称="函数(形参，$event)"</code></li><li>methods里的函数：<code>func(形参，e){e.preventDefault()}</code></li></ul></li></ul><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><ul><li>事件.prevent：阻止默认行为</li><li>事件.stop：阻止冒泡</li><li>事件.once：只执行一次该事件<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;&lt;button @click.once="addN(20)"&gt;addN&lt;/button&gt;</span><br><span class="line">&nbsp;&lt;button @click.stop="son"&gt;sonn&lt;/button&gt;</span><br><span class="line">&nbsp;&lt;a :href="url" @click.prevent="btn"&gt;prevent baidu&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="获取按键修饰符"><a href="#获取按键修饰符" class="headerlink" title="获取按键修饰符"></a>获取按键修饰符</h3><ul><li><code>@keydown.enter = "fn"</code>按下enter执行fn</li><li><code>@keydown.esc = "fn"</code>按下esc执行fn</li></ul><h3 id="练习翻转世界"><a href="#练习翻转世界" class="headerlink" title="练习翻转世界"></a>练习翻转世界</h3><p>需求：点击按钮 - 把文字取反显示 - 再点击取反显示(回来了) 提示: 点击事件里, 把Vue变量值挨个字母取反赋予回来 (提示跟数组有关系)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div @click="father"&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;h1&gt;{{msg}}&lt;/h1&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;button @click="changeWorld"&gt;change world&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&nbsp; &nbsp; export default{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; data(){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg:'hello, world',</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; },</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; methods:{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changeWorld(){</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let arr = this.msg.split('')</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.msg = arr.reverse().join('')</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>用处：将表单标签和值双向绑定<br>语法：<code>v-model="vue变量"</code><br>注意：只能用在表单标签上</p><h4 id="下拉菜单v-model写哪里？"><a href="#下拉菜单v-model写哪里？" class="headerlink" title="下拉菜单v-model写哪里？"></a>下拉菜单v-model写哪里？</h4><p>写在select标签上<br>value值写在option上</p><h4 id="复选框v-model注意事项"><a href="#复选框v-model注意事项" class="headerlink" title="复选框v-model注意事项"></a>复选框v-model注意事项</h4><ul><li>v-model的变量是非数组，关联的是check属性</li><li>v-model的变量是数组，关联的是value属性</li><li>所以要把复选框的变量写成数组</li></ul><h4 id="单选框v-model注意事项"><a href="#单选框v-model注意事项" class="headerlink" title="单选框v-model注意事项"></a>单选框v-model注意事项</h4><ul><li>注意要写name，name值等于分类，value值是选项值</li></ul><h4 id="vue变量初始值会不会影响表单的默认状态"><a href="#vue变量初始值会不会影响表单的默认状态" class="headerlink" title="vue变量初始值会不会影响表单的默认状态?"></a>vue变量初始值会不会影响表单的默认状态?</h4><ul><li>会，因为数据是双向绑定的</li></ul><h3 id="v-model的修饰符"><a href="#v-model的修饰符" class="headerlink" title="v-model的修饰符"></a>v-model的修饰符</h3><ul><li><code>v-model.number</code>以<code>parseFloat</code>把值转换为数值型</li><li><code>v-model.trim</code>清除字符串两端的空格</li><li><code>v-model.lazy</code>当发生更改且失去焦点时才触发事件</li></ul><h3 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h3><ul><li>语法：<ul><li><code>v-text = "vue变量"</code>——把值当成普通字符串显示</li><li><code>v-html = "vue变量"</code>——把值解析成标签再显示</li></ul></li><li>二者会覆盖插值表达式，在vue3中，如果写了二者再写插值表达式会报错</li></ul><h3 id="v-show-和-v-if"><a href="#v-show-和-v-if" class="headerlink" title="v-show 和 v-if"></a>v-show 和 v-if</h3><ul><li>语法：<ul><li><code>v-show="vue变量(true/false)"</code>——采用<code>display:none</code>对标签进行显示隐藏</li><li><code>v-if="vue变量(true/false)"</code>——采用移除dom标签的方式对标签进行显示隐藏</li></ul></li><li><code>v-if</code>可配合<code>v-else-if</code>和<code>v-else</code>使用<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p v-if="age&lt;18"&gt;未成年&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p v-else-if="age&lt;50 &amp;&amp; age &gt;= 18"&gt;成年了&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p v-else&gt;中年了&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul><li>作用：列表渲染, 按照所在标签结构, 数据数量, 循环生成列表</li><li>语法<ul><li><code>v-for="(值，索引) in 目标结构"</code></li><li><code>v-for= 值 in 目标结构</code></li></ul></li><li>目标结构 <ul><li>数组</li><li>对象</li><li>列表</li><li>数字<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;!--遍历数组--&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;ul&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li v-for="(item,index) in arr"&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {{ item }} ---- {{ index }}</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/li&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--遍历列表里的对象--&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;ul&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li v-for="item in stuArr"&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {{ item.name }}--{{ item.sex }}--{{ item.hobby }}</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/li&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--遍历对象--&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;ul &gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li v-for="(value,key) in tObj"&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {{ key }}: {{ value }}</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/li&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--遍历数字--&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;ul&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li v-for="index in count"&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {{ index }}</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/li&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &lt;/ul&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><p>当v-for遍历的目标结构改变, Vue触发v-for的更新。<br>例如，遍历数组时，数组变更，就会导致v-for更新，页面更新。</p><ul><li>常见的数组变更方法：push, pop, shift, unshift, splice, reverse, join, split, sort</li><li>常见的不变更数组的方法：map, filter, concat, slice<ul><li>采用不变更数组的方法，返回新数组，不改变原数组，v-for就不会更新。</li><li>需要更新可用新数组覆盖原数组，或者采用this.$set()</li></ul></li><li>vue无法监测数组更新，如需更新使用Vue.set()或者this.$set()</li></ul><h4 id="v-for-就地更新和虚拟dom"><a href="#v-for-就地更新和虚拟dom" class="headerlink" title="v-for 就地更新和虚拟dom"></a>v-for 就地更新和虚拟dom</h4><p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。<br>这种虚拟DOM对比方式, 可以提高性能。</p><p>.vue文件中的template里写的标签, 都是模板, 都要被vue处理成虚拟DOM对象, 才会渲染显示到真实DOM页面上。</p><ol><li>内存中生成一样的虚拟DOM结构(==本质是个JS对象==)<br>比如template里标签结构<br>&nbsp; &nbsp;<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&nbsp; &nbsp;&lt;template&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp;&lt;div id="box"&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;p class="my_p"&gt;123&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp;&lt;/div&gt;</span><br><span class="line">&nbsp; &nbsp;&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><br>&nbsp;<br>对应的虚拟DOM结构<br>&nbsp; &nbsp;<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp;<span class="keyword">const</span> dom = {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp;<span class="attr">type</span>: <span class="string">'div'</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp;<span class="attr">attributes</span>: [{<span class="attr">id</span>: <span class="string">'box'</span>}],</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp;<span class="attr">children</span>: {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="attr">type</span>: <span class="string">'p'</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="attr">attributes</span>: [{<span class="attr">class</span>: <span class="string">'my_p'</span>}],</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="attr">text</span>: <span class="string">'123'</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp;}</span><br><span class="line">&nbsp; &nbsp;}</span><br></pre></td></tr></tbody></table></figure></li><li>以后vue数据更新<br>&nbsp; &nbsp;* 生成新的虚拟DOM结构<br>&nbsp; &nbsp;* 和旧的虚拟DOM结构对比<br>&nbsp; &nbsp;* 利用diff算法, 找不不同, 只更新变化的部分(重绘/回流)到页面 - 也叫打补丁<br>==好处1: 提高了更新DOM的性能(不用把页面全删除重新渲染)==<br>==好处2: 虚拟DOM只包含必要的属性(没有真实DOM上百个属性)==<br>总结: 虚拟DOM保存在内存中, 只记录dom关键信息, 配合diff算法提高DOM更新的性能，在内存中比较差异, 然后给真实DOM打补丁更新上。</li></ol><h3 id="动态class"><a href="#动态class" class="headerlink" title="动态class"></a>动态class</h3><ul><li>语法：<code>:class="类名称:布尔值"</code><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p :class="{redStr:bool}"&gt;值为true&lt;/p&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.redStr{</span><br><span class="line">color:red;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default{</span><br><span class="line">data(){</span><br><span class="line">return {</span><br><span class="line">bool:true,</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="动态style"><a href="#动态style" class="headerlink" title="动态style"></a>动态style</h3><ul><li>语法：<code>:style="{css属性名称:值}"</code><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p :style="{backgroundColor: colorStr}"&gt;动态style&lt;/p&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">&nbsp; data(){</span><br><span class="line">&nbsp; &nbsp; return {</span><br><span class="line">&nbsp; &nbsp; &nbsp; colorStr: 'red'</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul><li>过滤器只能用在, 插值表达式和v-bind动态属性里。</li><li>Vue中的过滤器场景<ul><li>字符串翻转, “输入hello, world”, 输出”dlrow ,olleh”</li><li>字母转大写, 输入”hello”, 输出”HELLO”</li></ul></li><li>语法<ul><li>Vue.filter(“过滤器名”, (值) =&gt; {return “返回处理后的值”})<ul><li>写在入口文件main.js里</li></ul></li><li>filters: {过滤器名字: (值) =&gt; {return “返回处理后的值”}<ul><li>写在单页面文件里<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p&gt;原来的样子: {{ msg }}&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p&gt;使用翻转过滤器: {{ msg | reverse }}&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p :title="msg | toUp"&gt;鼠标长停&lt;/p&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">&nbsp; data(){</span><br><span class="line">&nbsp; &nbsp; return {</span><br><span class="line">&nbsp; &nbsp; &nbsp; msg: 'Hello, Vue'</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; },</span><br><span class="line">&nbsp; </span><br><span class="line">&nbsp; filters: {</span><br><span class="line">&nbsp; &nbsp; toUp (val) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; return val.toUpperCase()</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="给过滤器传参-多过滤器"><a href="#给过滤器传参-多过滤器" class="headerlink" title="给过滤器传参 | 多过滤器"></a>给过滤器传参 | 多过滤器</h4></li></ul></li></ul></li><li>语法<ul><li>过滤器传参: vue变量 | 过滤器(实参)</li><li>多个过滤器: vue变量 | 过滤器1 | 过滤器2<ul><li>把第一个过滤器的结果当作变量传给第二个过滤器<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&nbsp; &lt;div&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p&gt;原来的样子: {{ msg }}&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p&gt;使用翻转过滤器: {{ msg | reverse('|') }}&lt;/p&gt;</span><br><span class="line">&nbsp; &nbsp; &lt;p :title="msg | toUp | reverse('|')"&gt;鼠标长停&lt;/p&gt;</span><br><span class="line">&nbsp; &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h3><ul><li>一个变量的值, 依赖另外一些数据计算而来的结果</li><li>计算属性也是vue数据变量, 所以不要和data里重名, 用法和data相同</li><li>语法<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="attr">computed</span>: {</span><br><span class="line"><span class="string">"计算属性名"</span> () {</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="string">"值"</span></span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; }</span><br><span class="line">&nbsp;<span class="comment">// 完整写法</span></span><br><span class="line">&nbsp;<span class="attr">computed</span>:{</span><br><span class="line">&nbsp;属性名:{</span><br><span class="line">&nbsp;<span class="title function_">set</span>(<span class="params">值</span>){</span><br><span class="line">&nbsp;</span><br><span class="line">&nbsp;},</span><br><span class="line">&nbsp;<span class="title function_">get</span>(<span class="params"></span>){</span><br><span class="line">&nbsp;<span class="keyword">return</span> 值</span><br><span class="line">&nbsp;}</span><br><span class="line">&nbsp;}</span><br><span class="line">&nbsp;}</span><br></pre></td></tr></tbody></table></figure></li><li>特点：函数内使用的变量改变, 重新计算结果返回</li><li>注意：计算属性名和data里名字不能重复</li><li>优势：带缓存, 基于依赖项的值进行缓存，依赖的变量不变, 都直接从缓存取结果，依赖项改变, 函数自动执行并重新缓存</li></ul><h3 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h3><p>可以侦听data/computed属性值的改变</p><ul><li>语法<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听简单类型的数据，比如数组</span></span><br><span class="line"><span class="attr">watch</span>:{</span><br><span class="line">被侦听的属性名(newVal, oldVal){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newVal, oldVal)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听复杂类型的数据，比如对象</span></span><br><span class="line"><span class="attr">watch</span>:{</span><br><span class="line">被侦听的属性:{</span><br><span class="line"><span class="attr">immediate</span>: <span class="literal">true</span>, <span class="comment">// 立即执行</span></span><br><span class="line"><span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度侦听，例如可以侦听对象的属性的改变</span></span><br><span class="line"><span class="title function_">handler</span>(<span class="params">newVal, oldVal</span>){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newVal.<span class="property">name</span>, oldVal.<span class="property">name</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h3><ul><li>组件是可复用的vue实例，封装了标签样式和JS代码。</li><li>组件化：把页面上可复用的重复的部分封装成组件</li></ul><h3 id="组件的基本使用"><a href="#组件的基本使用" class="headerlink" title="组件的基本使用"></a>组件的基本使用</h3><p>创建组件<br>注册组件</p><ul><li>全局注册（在main.js）中。<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> 组件对象 <span class="keyword">from</span> vue文件路径</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">componenet</span>(<span class="string">'组件名'</span>,组件对象)</span><br></pre></td></tr></tbody></table></figure></li><li>局部注册（在vue文件内）<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 组件对象 <span class="keyword">from</span> vue文件路径</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>{</span><br><span class="line"><span class="attr">components</span>:{</span><br><span class="line"><span class="string">'组件名'</span>: 组件对象</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="scoped的作用"><a href="#scoped的作用" class="headerlink" title="scoped的作用"></a>scoped的作用</h3><ul><li>加上之后，当前组件内的标签都被添加data-v-hash的属性</li></ul><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><ul><li>子组件内用props定义变量准备接受，然后使用变量</li><li>父组件内，引入子组件，以属性的方式给子组件传值。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;p&gt;标题 {{title}} &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default{</span><br><span class="line">props:['title']</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;son title="你好啊"&gt;&lt;/son&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import son from './son.vue'</span><br><span class="line">export default{</span><br><span class="line">components:{</span><br><span class="line">son</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>父传子的数据流向叫做单向数据流。<br>props属性是只读的，子组件修改不通知父级，会造成数据的不一致。</p><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><ul><li>父组件内, 给组件@自定义事件=”父methods函数”</li><li>子组件内, 恰当时机this.$emit(‘自定义事件名’, 值)<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;son title="你好啊" @kan='kanFn'&gt;&lt;/son&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import son from './son.vue'</span><br><span class="line">export default{</span><br><span class="line">components:{</span><br><span class="line">son</span><br><span class="line">},</span><br><span class="line">methods:{</span><br><span class="line">kan(){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;p&gt;标题 {{title}} &lt;/p&gt;</span><br><span class="line">&lt;button @click="kanFn"&gt;price-1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default{</span><br><span class="line">data(){</span><br><span class="line">return{</span><br><span class="line">msg:1</span><br><span class="line">}</span><br><span class="line">},</span><br><span class="line">props:['title'],</span><br><span class="line">methods:{</span><br><span class="line">kanFn(){</span><br><span class="line">this.$emit('kan', this.msg)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h4><p>语法</p><ul><li><code>src/EventBus/index.js</code> – 创建空白Vue对象并导出 </li><li>在要接收值的组件(List.vue) <code>eventBus.$on('事件名', 函数体)</code></li><li>在要传递值的组件(MyProduct.vue) <code>eventBus.$emit('事件名', 值)</code></li></ul><p>eventBus技术本质是什么? </p><ul><li>空白Vue对象, 只负责<code>$on和$emit</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学vue，开始创建项目的时候用npm总是失败，改用yarn才ok。&lt;br&gt;这是一篇基础记录帖。想看高级的请绕道哦。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://sajlle.github.io/tags/vue/"/>
    
    <category term="vue3" scheme="https://sajlle.github.io/tags/vue3/"/>
    
    <category term="前端框架" scheme="https://sajlle.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>日语五十音一键入门</title>
    <link href="https://sajlle.github.io/2023/05/01/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/"/>
    <id>https://sajlle.github.io/2023/05/01/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/</id>
    <published>2023-04-30T19:41:42.000Z</published>
    <updated>2023-04-30T11:45:14.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="あいうえお"><a href="#あいうえお" class="headerlink" title="あいうえお"></a>あいうえお</h2><p>作用：</p><ul><li>注音</li><li>构词</li></ul><p>あい 爱</p><span id="more"></span><h2 id="さしすせそ"><a href="#さしすせそ" class="headerlink" title="さしすせそ"></a>さしすせそ</h2><p>せかい、世界<br>おさき、酒<br>おいしい、美味的<br>うそ、假话<br>いちご、いちえ、一期一会</p><p>すごい、好厉害</p><h2 id="たちつてと"><a href="#たちつてと" class="headerlink" title="たちつてと"></a>たちつてと</h2><p>うた、歌<br>ちしき、知识<br>ちかてつ、地铁<br>すてき、绝妙的<br>いと、线</p><p>たすかて、help！救命！</p><h2 id="なにぬねの"><a href="#なにぬねの" class="headerlink" title="なにぬねの"></a>なにぬねの</h2><p>おさきなな、尾崎娜娜<br>にこ、笑眯眯的<br>なに、什么<br>いぬ、狗<br>ねこ、猫<br>ぬの、布</p><p>なるほど、原来如此</p><h2 id="はひふへほ"><a href="#はひふへほ" class="headerlink" title="はひふへほ"></a>はひふへほ</h2><p>こくはく、告白<br>ひと、人<br>ふく、服装<br>へた、不擅长某事<br>ほほ、脸颊</p><p>はやく、快点</p><h2 id="まみむめも"><a href="#まみむめも" class="headerlink" title="まみむめも"></a>まみむめも</h2><p>くま、熊<br>うみ、海<br>むかし、过去<br>あめ、雨<br>きもち、情感</p><p>うらやましい、好羡慕啊</p><h2 id="かきくえこ"><a href="#かきくえこ" class="headerlink" title="かきくえこ"></a>かきくえこ</h2><p>かお、脸<br>かく、书写<br>きおく、记忆<br>いけ、池塘<br>こえ、声音</p><p>けち、小气！</p><h2 id="やゆよ"><a href="#やゆよ" class="headerlink" title="やゆよ"></a>やゆよ</h2><p>へや、屋<br>やくそく、约定<br>ゆめ、梦<br>ゆき、雪<br>よめ、老婆</p><p>やめて、住手，停下。</p><h2 id="らりるれろ"><a href="#らりるれろ" class="headerlink" title="らりるれろ"></a>らりるれろ</h2><p>さくら、樱花<br>くすり、药<br>はる、春天<br>れきし、历史<br>ろく、六</p><p>がんばれ、加油！</p><h2 id="わをん"><a href="#わをん" class="headerlink" title="わをん"></a>わをん</h2><p>わたし，我<br>わくわく、表示激动的心情<br>おんせん、温泉<br>てしき、天气<br>みんな、大家</p><p>きをつけて、小心哦</p><h2 id="浊音"><a href="#浊音" class="headerlink" title="浊音"></a>浊音</h2><p>がぎぐげご<br>ざじずぜぞ<br>だぢづでど<br>ばびぶべぼ<br>じandぢ the same tone<br>ずandづ the same tone</p><h2 id="鼻浊音"><a href="#鼻浊音" class="headerlink" title="鼻浊音"></a>鼻浊音</h2><p>がぎぐげご用于词中词尾可读鼻浊音<br>年轻人很少使用鼻浊音</p><h2 id="半浊音"><a href="#半浊音" class="headerlink" title="半浊音"></a>半浊音</h2><p>ぱぴぷぺぽ<br>かきくけこ<br>たちつてと<br>以上三行假名位于词中词尾时不发送气音</p><p>如何分辨不送气音，浊音？</p><ul><li>背单词</li><li>学语法</li></ul><p>だれ、谁<br>てがみ、信<br>ざんねん、残念，遗憾，可惜<br>てんふら、天妇罗（油炸食品）</p><p>ただいま、おすえり。我回来了，你回来啦。</p><h2 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h2><p>除了い之外的い段假名和复元音やゆよ拼合起来的音节</p><ul><li>除了い之外的い段假名：<ul><li>きしちにひみりぎじびぴ、</li></ul></li></ul><p>しゅみ，趣味<br>かのじょ，她，女朋友<br>かいしゃ，会社，公司<br>おもちゃ、玩具</p><p>じゃあね，再见</p><h2 id="声调"><a href="#声调" class="headerlink" title="声调"></a>声调</h2><ul><li>数字标记法<ul><li>一个假名是一拍</li><li>0 第一个假名低音，后面的假名高音</li><li>1 第一个假名高音，后面的假名低音</li><li>2 第一个假名低音，第二个假名高音，第三个假名低音</li><li>3 第一个假名低音，第二个，第三个假名高音，第四个假名低音</li><li>4 第一个假名低音，第二个，第三个，第四个假名高音，第五个假名低音</li></ul></li></ul><h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><ul><li><p>音节分为长音节，短音节，音节长短可改变意思。</p><ul><li>例如啤酒和大厦</li></ul></li><li><p>长音：把短音拖长一倍</p></li><li><p>浊音，半浊音，拗音都有长音</p></li></ul><p>长音写法：</p><ul><li>あいう列后加あいう。</li><li>え加い（默认）え加え（少见）</li><li>お加う（默认）お加お（少见）</li><li>片假名加ー<ul><li>可通过减号打出片假名的长音符号</li></ul></li></ul><h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><ul><li>符号：っ<ul><li>双打促音后的辅音即可输入促音符号</li></ul></li><li>停顿一个假名的拍子，然后读促音之后的单词</li></ul><p>きって ，切手<br>インターネット，Internet</p><p>おかあさん、妈妈<br>べんきょう、学习<br>すうがく、数学<br>きっさてん、咖啡店</p><p>ちょっとまって、稍等一下</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>日语发音短平快</li><li>要输入小一号的假名，只需要日语罗马音前输入l或者x即可</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;あいうえお&quot;&gt;&lt;a href=&quot;#あいうえお&quot; class=&quot;headerlink&quot; title=&quot;あいうえお&quot;&gt;&lt;/a&gt;あいうえお&lt;/h2&gt;&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注音&lt;/li&gt;
&lt;li&gt;构词&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あい 爱&lt;/p&gt;</summary>
    
    
    
    <category term="语言" scheme="https://sajlle.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="日语" scheme="https://sajlle.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
    <category term="五十音图" scheme="https://sajlle.github.io/tags/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>webpack一键入门</title>
    <link href="https://sajlle.github.io/2023/05/01/webpack%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/"/>
    <id>https://sajlle.github.io/2023/05/01/webpack%E4%B8%80%E9%94%AE%E5%85%A5%E9%97%A8/</id>
    <published>2023-04-30T19:39:13.000Z</published>
    <updated>2023-04-30T11:45:28.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g</span><br><span class="line">yarn init</span><br><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></tbody></table></figure><p>配置script</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"scripts"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line"><span class="attr">"build"</span><span class="punctuation">:</span><span class="string">"webpack"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><ul><li>新建文件夹folder， folder/src</li><li>新建文件src/index.js</li><li>新建文件src/add/add.js</li><li>运行命令<code>yarn build</code>生成foler/dist/main.js</li></ul><h2 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h2><h3 id="更改webpack的出口和入口"><a href="#更改webpack的出口和入口" class="headerlink" title="更改webpack的出口和入口"></a>更改webpack的出口和入口</h3><ul><li>[配置文档](<a href="https://webpack.docschina.org/concepts/#entry">概念 | webpack 中文文档 (docschina.org)</a>)<ul><li>新建webpack.config.js（如果更改了package.json，在里面添加了<code>"type":"module"</code>则需要把后缀名改为cjs</li><li>在上述文件里<ul><li>通过entry设置文件入口</li><li>通过output设置出口，文件名</li></ul></li></ul></li><li>所有打包资源都要跟入口产生直接的或者间接的引用关系</li></ul><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><ul><li>(document)[<a href="https://webpack.docschina.org/plugins/html-webpack-plugin/">HtmlWebpackPlugin | webpack 中文文档 (docschina.org)</a>]</li><li>添加配置<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">'index.js'</span>,</span><br><span class="line">  <span class="attr">output</span>: {</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">'index_bundle.js'</span>,</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>({</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'./public/index.html'</span> <span class="comment">// 入口html文件地址</span></span><br><span class="line">  })],</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><h4 id="打包css文件"><a href="#打包css文件" class="headerlink" title="打包css文件"></a>打包css文件</h4><ul><li><a href="https://webpack.docschina.org/loaders/css-loader/">css-loader | webpack 中文文档 (docschina.org)</a></li><li><a href="https://webpack.docschina.org/loaders/style-loader/">style-loader | webpack 中文文档 (docschina.org)</a></li><li>css代码被打包进js文件中</li><li>style-loader会把css代码插入到head下style标签内</li></ul><h4 id="打包less文件"><a href="#打包less文件" class="headerlink" title="打包less文件"></a>打包less文件</h4><p><a href="https://webpack.docschina.org/loaders/less-loader/">less-loader | webpack 中文文档 (docschina.org)</a>可以把less编译为css文件</p><ul><li>新建src/less/index.less – 设置li字体大小</li><li>把index.less引入到入口处</li><li>下载加载器来处理less文件、</li><li>webpack.config.js针对less配置</li></ul><p>webpack如何支持less打包? 需要注意什么? </p><ol><li>依赖less-loader和less模块包 </li><li>转换css后还需要css-loader和style-loader的处理</li></ol><h3 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h3><p>webpack5, 使用asset module技术实现字体文件和图片文件处理, 无需配置额外loader</p><ul><li>(document)[<a href="https://webpack.docschina.org/guides/asset-modules/">资源模块 | webpack 中文文档 (docschina.org)</a>]</li><li>以前用url-loader和file-loader来处理 现在webpack.config.js – 针对图片文件设置type: “assets“<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`diff</span></span><br><span class="line"><span class="string">module: {</span></span><br><span class="line"><span class="string">  rules: [</span></span><br><span class="line"><span class="string">    {</span></span><br><span class="line"><span class="string">      test: /\.png/,</span></span><br><span class="line"><span class="string">      type: 'assets' </span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">   ]</span></span><br><span class="line"><span class="string">},</span></span><br></pre></td></tr></tbody></table></figure>小于8KB文件, 文件转base64打包在js中, 大于8KB, 文件自动命名输出到dist下</li></ul><h5 id="webpack加载文件优缺点"><a href="#webpack加载文件优缺点" class="headerlink" title="webpack加载文件优缺点"></a>webpack加载文件优缺点</h5><p>图片翻译成了base64, 放到了js文件中 </p><ul><li>好处: 浏览器不用发请求了，直接可以读取, 速度快 </li><li>坏处: 图片太大，再转<code>base64</code>就会让图片的体积增大 30% 左右, 得不偿失</li></ul><h3 id="处理字体图标"><a href="#处理字体图标" class="headerlink" title="处理字体图标"></a>处理字体图标</h3><p>在webpack.configjs的rules里针对字体图标文件类型 设置asset/resource, 直接输出到dist下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: {</span><br><span class="line">   <span class="attr">rules</span>: [</span><br><span class="line">   {</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.(eot|svg|ttf|woff|woff2)$/</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">'asset/resource'</span>,</span><br><span class="line">    <span class="attr">generator</span>:{</span><br><span class="line"><span class="attr">filename</span>: <span class="string">'font/[name].[hash][ext]'</span></span><br><span class="line">}</span><br><span class="line">     }</span><br><span class="line">  ]</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="对js进行语法降级"><a href="#对js进行语法降级" class="headerlink" title="对js进行语法降级"></a>对js进行语法降级</h3><p>babel官网: <a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a><br>babel-loader文档: <a href="https://webpack.docschina.org/loaders/babel-loader/">https://webpack.docschina.org/loaders/babel-loader/</a></p><p>babel: 一个javascript编译器, 把高版本js语法降级处理输出兼容的低版本语法；<br>babel-loader: 可以让webpack转译打包的js代码</p><h3 id="webpack开发服务器"><a href="#webpack开发服务器" class="headerlink" title="webpack开发服务器"></a>webpack开发服务器</h3><p>webpack开发服务器, 把代码运行在内存中, 自动更新, 实时返回给浏览器显示</p><p>为什么要使用webpack开发服务器呢? </p><ol><li>打包在内存中, 速度快 </li><li>自动更新打包变化的代码, 实时返回给浏览器显示</li></ol><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>webpack-dev-server文档: <a href="https://webpack.docschina.org/configuration/dev-server/">https://webpack.docschina.org/configuration/dev-server/</a></p><ol><li>下载</li><li>package.json里配置自定义命令<code>"serve":"webpack serve"</code></li><li>启动服务器<code>yarn serve</code></li><li>改变端口号<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>={</span><br><span class="line">devServer :{</span><br><span class="line"><span class="attr">port</span>:<span class="number">3000</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="bugFix"><a href="#bugFix" class="headerlink" title="bugFix"></a>bugFix</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The <span class="string">'mode'</span> option has not been <span class="built_in">set</span>, webpack will fallback to <span class="string">'production'</span> <span class="keyword">for</span> this value.</span><br><span class="line">Set <span class="string">'mode'</span> option to <span class="string">'development'</span> or <span class="string">'production'</span> to <span class="built_in">enable</span> defaults <span class="keyword">for</span> each environment.</span><br><span class="line">You can also <span class="built_in">set</span> it to <span class="string">'none'</span> to <span class="built_in">disable</span> any default behavior. Learn more: https://webpack.js.org/configuration/mode/</span><br></pre></td></tr></tbody></table></figure><p>在package.json里配置：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"scripts"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="attr">"dev"</span><span class="punctuation">:</span> <span class="string">"webpack --mode development"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="attr">"build"</span><span class="punctuation">:</span> <span class="string">"webpack --mode production"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>在webpack.config.cjs里配置：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line"><span class="attr">mode</span>: <span class="string">"development"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>遇到报错：</p><ul><li><code> The Less implementation "undefined" not found</code>是less-loader版本高，webpack版本低。<br>解决办法是，下载低版本的less-loader</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./src/css/style.css 1:3</span><br><span class="line">Module parse failed: Unexpected token (1:3)</span><br><span class="line">You may need an appropriate loader to handle this file <span class="built_in">type</span>, currently no loaders are configured to process this file. See https://webpack.js.org/concepts<span class="comment">#loaders</span></span><br><span class="line">&gt; h1 {</span><br><span class="line">|     color: red;</span><br><span class="line">| }</span><br><span class="line"> @ ./src/main.js 7:0-24</span><br><span class="line"></span><br><span class="line">webpack 5.80.0 compiled with 1 error and 1 warning <span class="keyword">in</span> 960 ms</span><br><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br></pre></td></tr></tbody></table></figure><ul><li>是因为对一个文件同时引入了less和css文件，样式冲突了。只引用一个样式文件即可。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm i yarn -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn add webpack webpack-cli -D&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;配置script&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;webpack&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="工具使用" scheme="https://sajlle.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="webpack" scheme="https://sajlle.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ES6模块化与异步编程基础</title>
    <link href="https://sajlle.github.io/2023/04/22/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://sajlle.github.io/2023/04/22/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-21T18:04:55.000Z</published>
    <updated>2023-04-21T10:06:26.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><h3 id="啥是ES6？"><a href="#啥是ES6？" class="headerlink" title="啥是ES6？"></a>啥是ES6？</h3><p>ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学 习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。</p><span id="more"></span><h3 id="ES6-模块化规范中定义"><a href="#ES6-模块化规范中定义" class="headerlink" title="ES6 模块化规范中定义"></a>ES6 模块化规范中定义</h3><ul><li>单个js文件是独立的模块</li><li>导入其他模块成员使用<code>import</code>关键字</li><li>向外共享成员使用<code>export</code>关键字<h3 id="基于node-js学习模块化"><a href="#基于node-js学习模块化" class="headerlink" title="基于node.js学习模块化"></a>基于node.js学习模块化</h3>node.js 中默认仅支持 CommonJS 模块化规范，若想基于 node.js 体验与学习 ES6 的模块化语法，可以按照 如下两个步骤进行配置：</li><li>确保node版本不低于14.15.1</li><li>在目标文件夹运行<code>npm init</code></li><li>在生成的<code>package.json</code>文件第二行添加<code>"type":"module"</code></li></ul><h3 id="ES6-模块的基本语法"><a href="#ES6-模块的基本语法" class="headerlink" title="ES6 模块的基本语法"></a>ES6 模块的基本语法</h3><p>ES6 的模块化主要包含如下 3 种用法：<br>① 默认导出与默认导入<br>② 按需导出与按需导入<br>③ 直接导入并执行模块中的代码</p><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><ul><li>语法：<code>export default 默认导出的成员</code></li><li>每个模块中只许使用一次，多了报错<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">&nbsp; &nbsp; n1,</span><br><span class="line">&nbsp; &nbsp; show</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h4><ul><li>语法：<code>import 接收名称 from '模块标识符'</code></li><li>接收名称可以是任意名称<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m1 <span class="keyword">from</span> <span class="string">'./index.js'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1)</span><br><span class="line"><span class="comment">// { n1: 10, show: [Function: show] }</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="按需导出"><a href="#按需导出" class="headerlink" title="按需导出"></a>按需导出</h4><ul><li>语法：<code>export 导出成员</code><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s1 = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s2 = <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="按需导入"><a href="#按需导入" class="headerlink" title="按需导入"></a>按需导入</h4><p>语法：<code>import {成员} from 'identifier'</code></p><ul><li>可以使用as重命名成员</li><li>成员名称必须和导出的一致</li><li>可以和默认导入一起使用，通过info关键字完成<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> info, { s1, s2 <span class="keyword">as</span> s, say } <span class="keyword">from</span> <span class="string">'./index.js'</span></span><br><span class="line"><span class="comment">// info代表默认导入的成员</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(say)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [Function: say]</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="直接导入"><a href="#直接导入" class="headerlink" title="直接导入"></a>直接导入</h4><ul><li>适用场景：<ul><li>只想执行代码，需要代码的副作用，但是不需要代码的返回值</li></ul></li><li>直接导入并执行模块中的代码</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Promise 是一个构造函数<ul><li>我们可以创建 Promise 的实例 <code>const p = new Promise()</code> </li><li>new 出来的 Promise 实例对象，代表一个异步操作</li></ul></li><li><code>Promise.prototype</code> 上包含一个 <code>.then()</code> 方法<ul><li>每一次 new Promise() 构造函数得到的实例对象</li><li>都可以通过原型链的方式访问到 <code>.then()</code> 方法，例如 <code>p.then()</code></li></ul></li><li><code>.then()</code> 方法用来预先指定成功和失败的回调函数<ul><li>p.then(成功的回调函数，失败的回调函数)</li><li><code>p.then(result =&gt; { }, error =&gt; { })</code></li><li>调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的</li></ul></li></ul><h3 id="基于-then-fs-读取文件内容"><a href="#基于-then-fs-读取文件内容" class="headerlink" title="基于 then-fs 读取文件内容"></a>基于 then-fs 读取文件内容</h3><p>由于 node.js 官方提供的 fs 模块仅支持以回调函数的方式读取文件，不支持 Promise 的调用方式。因此，需 要先运行如下的命令，安装 then-fs 这个第三方包，从而支持我们基于 Promise 的方式读取文件的内容。<br><code>npm i then-fs</code></p><h4 id="then-fs的基本使用"><a href="#then-fs的基本使用" class="headerlink" title="then-fs的基本使用"></a>then-fs的基本使用</h4><p>调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">'then-fs'</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/1.txt'</span>, <span class="string">'utf8'</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> { <span class="variable language_">console</span>.<span class="title function_">log</span>(err) }, <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/2.txt'</span>, <span class="string">'utf8'</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> { <span class="variable language_">console</span>.<span class="title function_">log</span>(err) }, <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/3.txt'</span>, <span class="string">'utf8'</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> { <span class="variable language_">console</span>.<span class="title function_">log</span>(err) }, <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br></pre></td></tr></tbody></table></figure><p>注意：上述的代码无法保证文件的读取顺序</p><h4 id="then-方法的特性"><a href="#then-方法的特性" class="headerlink" title=".then() 方法的特性"></a><code>.then() </code>方法的特性</h4><p>如果上一个 .then() 方法中返回了一个新的 Promise 实例对象，则可以通过下一个 .then() 继续进行处理。</p><h4 id="基于-Promise-按顺序读取文件的内容"><a href="#基于-Promise-按顺序读取文件的内容" class="headerlink" title="基于 Promise 按顺序读取文件的内容"></a>基于 Promise 按顺序读取文件的内容</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/11.txt'</span>, <span class="string">'utf8'</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&nbsp; &nbsp; </span><br><span class="line">}).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/2.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">}).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/3.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">}).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>通过<code>.catch()</code>捕捉错误<ul><li>在 Promise 的链式操作中如果发生了错误，可以使用 <code>Promise.prototype.catch</code> 方法进行捕获和处理</li><li>如果不希望前面的错误导致后续的 .then 无法正常执行，则可以将 .catch 的调用提前<h3 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a><code>Promise.all()</code>方法</h3>Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then 操作（等待机制）。<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">'then-fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [</span><br><span class="line">&nbsp; &nbsp; thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/1.txt'</span>, <span class="string">'utf8'</span>),</span><br><span class="line">&nbsp; &nbsp; thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/2.txt'</span>, <span class="string">'utf8'</span>),</span><br><span class="line">&nbsp; &nbsp; thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/3.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promiseArr).<span class="title function_">then</span>(<span class="function">(<span class="params">[r1, r2, r3]</span>) =&gt;</span> {  <span class="comment">// 不输入数组会一次返回三个值，以及两个undefined</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(r1, r2, r3)</span><br><span class="line">&nbsp; &nbsp; })</span><br><span class="line">&nbsp; &nbsp; .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'err:'</span> + err.<span class="property">message</span>)) </span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race() 方法"></a><code>Promise.race()</code> 方法</h3><p>Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的 .then 操作（赛跑机制）（输出跑的最快的那个）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(promiseArr).<span class="title function_">then</span>(</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></tbody></table></figure><h3 id="基于-Promise-封装读文件的方法"><a href="#基于-Promise-封装读文件的方法" class="headerlink" title="基于 Promise 封装读文件的方法"></a>基于 Promise 封装读文件的方法</h3><p>方法的封装要求：<br>① 方法的名称要定义为 getFile<br>② 方法接收一个形参 fpath，表示要读取的文件的路径<br>③ 方法的返回值为 Promise 实例对象</p><p>如果想要创建具体的异步操作，则需要在 new Promise() 构造函数期间，传递一个 function 函数，将具体的 异步操作定义到 function 函数内部。</p><p>通过 .then() 指定的成功和失败的回调函数，可以在 function 的形参中进行接收</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>) {</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; fs.<span class="title function_">readFile</span>(fpath, <span class="string">'utf8'</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">reject</span>(err)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="title function_">resolve</span>(data)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; })</span><br><span class="line">&nbsp; &nbsp; })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">getFile</span>(<span class="string">'./files/1.txt'</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data), <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></tbody></table></figure><ul><li>导入fs模块</li><li>创建函数</li><li>返回新建的promise对象</li><li>在promise构造函数中传入一个函数，将具体操作定义到函数内部<ul><li>该函数接受两个参数，成功回调函数和失败回调函数</li><li>该参数通过then传入</li></ul></li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>这是啥？<br>async/await 是 ES8（ECMAScript 2017）引入的新语法，用来简化 Promise 异步操作。在 async/await 出 现之前，开发者只能通过链式 .then() 的方式处理 Promise 异步操作。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params"></span>){</span><br><span class="line"><span class="keyword">const</span> r1 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1) <span class="comment">// 1.txt文本内容</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">getFile</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="async-await-注意"><a href="#async-await-注意" class="headerlink" title="async/await 注意"></a>async/await 注意</h3><ul><li>如果在函数中使用了await，则函数必须被async修饰</li><li>async中，第一个await之前的代码同步执行，后面的代码异步执行<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">'then-fs'</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getFiles</span>(<span class="params"></span>) {</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'B'</span>)</span><br><span class="line">&nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp; <span class="keyword">const</span> r1 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/1.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">const</span> r2 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">'./files/2.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'C'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">getFiles</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'D'</span>)</span><br></pre></td></tr></tbody></table></figure>执行结果：<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">1111111</span><br><span class="line">22222</span><br><span class="line">C</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="EVENT-LOOP"><a href="#EVENT-LOOP" class="headerlink" title="EVENT LOOP"></a>EVENT LOOP</h2><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类：</p><ul><li>同步任务（synchronous） <ul><li>又叫做非耗时任务，指的是在主线程上排队执行的那些任务 </li><li>只有前一个任务执行完毕，才能执行后一个任务</li></ul></li><li>异步任务<ul><li>耗时任务，由js委托给宿主环境（浏览器，node等）执行</li><li>异步任务执行完毕之后，通知js主线程执行异步任务的回调函数</li></ul></li></ul><h3 id="同步任务和异步任务的执行过程"><a href="#同步任务和异步任务的执行过程" class="headerlink" title="同步任务和异步任务的执行过程"></a>同步任务和异步任务的执行过程</h3><ul><li>js主线程按顺序执行同步任务</li><li>异步任务委托宿主环境执行</li><li>已经完成的异步任务，其回调函数被放入任务队列等待执行</li><li>js执行主线程被清空之后，会读取任务队列里的回调函数，按次序执行</li><li>js主线程不断重复以上四步<h3 id="事件循环的概念"><a href="#事件循环的概念" class="headerlink" title="事件循环的概念"></a>事件循环的概念</h3>JavaScript 主线程从“任务队列”中读取异步 任务的回调函数，放到执行栈中依次执行。这 个过程是循环不断的，所以整个的这种运行机 制又称为 EventLoop（事件循环）。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">'then-fs'</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'A'</span>)</span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">'/index.js'</span>,<span class="string">'utf8'</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>  =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'C'</span>)},<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'D'</span>)</span><br><span class="line"><span class="comment">// 正确输出： A D C B</span></span><br></pre></td></tr></tbody></table></figure><ul><li>AD同步任务，从上往下执行</li><li>BC异步任务，setTimeout先执行完毕，其回调函数先被放入任务队列中，读取文件后执行完毕，其回调函数后被放入任务队列中</li><li>执行任务队列</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是：</p><ul><li>宏任务<ul><li>异步Ajax请求</li><li>setTimeout, setInterval</li><li>文件操作</li><li>其他</li></ul></li><li>微任务<ul><li>Promise.then, .catch, .finally</li><li>process.nextTick</li><li>其他</li></ul></li></ul><h3 id="宏任务和微任务的执行顺序"><a href="#宏任务和微任务的执行顺序" class="headerlink" title="宏任务和微任务的执行顺序"></a>宏任务和微任务的执行顺序</h3><p>每一个宏任务执行完之后，都会检查是否存在待执行的微任务， 如果有，则执行完所有微任务之后，再继续执行下一个宏任务。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'2'</span>)</span><br><span class="line"><span class="title function_">resolve</span>()</span><br><span class="line">}).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'3'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2431</span></span><br></pre></td></tr></tbody></table></figure><p>① 先执行所有的同步任务 : 执行第 6 行、第 12 行代码<br>② 再执行微任务 : 执行第 9 行代码<br>③ 再执行下一个宏任务 : 执行第 2 行代码</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ES6模块化&quot;&gt;&lt;a href=&quot;#ES6模块化&quot; class=&quot;headerlink&quot; title=&quot;ES6模块化&quot;&gt;&lt;/a&gt;ES6模块化&lt;/h2&gt;&lt;h3 id=&quot;啥是ES6？&quot;&gt;&lt;a href=&quot;#啥是ES6？&quot; class=&quot;headerlink&quot; title=&quot;啥是ES6？&quot;&gt;&lt;/a&gt;啥是ES6？&lt;/h3&gt;&lt;p&gt;ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学 习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ES6" scheme="https://sajlle.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>express的安装与使用</title>
    <link href="https://sajlle.github.io/2023/04/19/express%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://sajlle.github.io/2023/04/19/express%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-19T15:48:20.000Z</published>
    <updated>2023-04-19T07:50:01.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-简介"><a href="#Express-简介" class="headerlink" title="Express 简介"></a>Express 简介</h2><p>Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</p><span id="more"></span><p>对于前端程序员来说，最常见的两种服务器，分别是： </p><ul><li>Web 网站服务器：专门对外提供 Web 网页资源的服务器。 </li><li>API 接口服务器：专门对外提供 API 接口的服务器。 使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器</li></ul><h3 id="express基本使用"><a href="#express基本使用" class="headerlink" title="express基本使用"></a>express基本使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在当前目录下运行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express@版本号</span><br></pre></td></tr></tbody></table></figure><h4 id="创建基本的web服务器"><a href="#创建基本的web服务器" class="headerlink" title="创建基本的web服务器"></a>创建基本的web服务器</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>) <span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>() <span class="comment">// 创建web服务器</span></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'express server is running at https://127.0.0.1'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="监听get请求"><a href="#监听get请求" class="headerlink" title="监听get请求"></a>监听get请求</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'请求url'</span>,<span class="keyword">function</span>(<span class="params">req,res</span>){</span><br><span class="line"><span class="comment">// 请求的处理函数</span></span><br><span class="line"><span class="comment">// req 请求对象</span></span><br><span class="line"><span class="comment">// res 响应对象</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="监听post请求"><a href="#监听post请求" class="headerlink" title="监听post请求"></a>监听post请求</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">'请求url'</span>,<span class="keyword">function</span>(<span class="params">req,res</span>){</span><br><span class="line"><span class="comment">// 请求的处理函数</span></span><br><span class="line"><span class="comment">// req 请求对象</span></span><br><span class="line"><span class="comment">// res 响应对象</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="响应内容到客户端"><a href="#响应内容到客户端" class="headerlink" title="响应内容到客户端"></a>响应内容到客户端</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user'</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>({<span class="attr">name</span>: <span class="string">"Alicia"</span>})</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/user'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'请求成功'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="获取url中携带的查询参数"><a href="#获取url中携带的查询参数" class="headerlink" title="获取url中携带的查询参数"></a>获取url中携带的查询参数</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>)</span><br><span class="line"><span class="comment">// req.query 默认是空对象</span></span><br><span class="line"><span class="comment">// 客户端使用 ?name=Alicia的形式发送的参数，会被req.query访问到</span></span><br><span class="line"><span class="comment">// req.query.name = 'Alicia'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="获取url中动态参数"><a href="#获取url中动态参数" class="headerlink" title="获取url中动态参数"></a>获取url中动态参数</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user/:id'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="comment">// 可通过 :参数名 的形式，匹配动态参数值</span></span><br><span class="line"><span class="comment">// req.params默认是一个空对象，存放通过:匹配到的参数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><h4 id="express-static"><a href="#express-static" class="headerlink" title="express.static()"></a><code>express.static()</code></h4><p>express 提供了一个非常好用的函数，叫做 <code>express.static()</code>，通过它，我们可以非常方便地创建一个静态资源服务器， 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">'public'</span>))</span><br></pre></td></tr></tbody></table></figure><p>现在，你就可以访问 public 目录中的所有文件了：<br><a href="http://localhost:3000/images/bg.jpg">http://localhost:3000/images/bg.jpg</a><br><a href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a><br><a href="http://localhost:3000/js/login.js">http://localhost:3000/js/login.js</a></p><p>注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。 因此，<mark style="background: #FF5582A6;">存放静态文件的目录名不会出现在 URL 中。</mark></p><h4 id="托管多个静态资源目录"><a href="#托管多个静态资源目录" class="headerlink" title="托管多个静态资源目录"></a>托管多个静态资源目录</h4><p>如果要托管多个静态资源目录，请多次调用 express.static() 函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">'public'</span>))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">'files'</span>))</span><br></pre></td></tr></tbody></table></figure><p>访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。</p><h4 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h4><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">'/public'</span>,express.<span class="title function_">static</span>(<span class="string">'public'</span>))</span><br></pre></td></tr></tbody></table></figure><p>现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：<br><a href="http://localhost:3000/public/images/kitten.jpg">http://localhost:3000/public/images/kitten.jpg</a><br><a href="http://localhost:3000/public/css/style.css">http://localhost:3000/public/css/style.css</a><br><a href="http://localhost:3000/public/js/app.js">http://localhost:3000/public/js/app.js</a></p><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><h4 id="为什么要使用-nodemon"><a href="#为什么要使用-nodemon" class="headerlink" title="为什么要使用 nodemon"></a>为什么要使用 nodemon</h4><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。 现在，我们可以使用 <a href="https://www.npmjs.com/package/nodemon">nodemon</a> 这个工具，它能够监听项目文件 的变动，当代码被修改后，nodemon 会<mark style="background: #FF5582A6;">自动帮我们重启项目</mark>，极大方便了开发和调试</p><h4 id="安装-nodemon"><a href="#安装-nodemon" class="headerlink" title="安装 nodemon"></a>安装 nodemon</h4><p>在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-nodemon"><a href="#使用-nodemon" class="headerlink" title="使用 nodemon"></a>使用 nodemon</h4><p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 <code>node app.js</code> 命令，来启动项目。这样做的坏处是： 代码被修改之后，需要手动重启项目。 现在，我们可以将 <code>node</code> 命令替换为 <code>nodemon</code> 命令，使用 <code>nodemon app.js</code> 来启动项目。这样做的好处是：代码 被修改之后，会被 <code>nodemon</code> 监听到，从而实现自动重启项目的效果。</p><h2 id="express-路由"><a href="#express-路由" class="headerlink" title="express 路由"></a>express 路由</h2><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><p>广义上来讲，路由就是映射关系</p><h4 id="express中的路由"><a href="#express中的路由" class="headerlink" title="express中的路由"></a>express中的路由</h4><p>在 Express 中，路由指的是<mark style="background: #FF5582A6;">客户端的请求与服务器处理函数之间的映射关系</mark>。 Express 中的路由分 3 部分组成，分别是<mark style="background: #ABF7F7A6;">请求的类型、请求的 URL 地址、处理函数</mark>，格式如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>,<span class="variable constant_">HANDLER</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="Express-中的路由的例子"><a href="#Express-中的路由的例子" class="headerlink" title="Express 中的路由的例子"></a>Express 中的路由的例子</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'hello world'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'get a post request'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h4><p>每当一个请求到达服务器之后，<mark style="background: #FF5582A6;">需要先经过路由的匹配</mark>，只有匹配成功之后，才会调用对应的处理函数。 在匹配时，会按照路由的顺序进行匹配，如果<mark style="background: #FF5582A6;">请求类型和请求的 URL </mark>同时匹配成功，则 Express 会将这次请求，转 交给对应的 function 函数进行处理。<br>![[Pasted image 20230419143558.png]]</p><p>路由匹配的注意点： </p><ul><li> 按照定义的先后顺序进行匹配 </li><li> 请求类型和请求的URL同时匹配成功， 才会调用对应的处理函数</li></ul><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'hello world'</span>)})</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'post request'</span>)})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>{<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'server is running at http://127.0.0.1'</span>)})</span><br></pre></td></tr></tbody></table></figure><h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h4><p>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： </p><ul><li>创建路由模块对应的 .js 文件 </li><li>调用 express.Router() 函数创建路由对象 </li><li>向路由对象上挂载具体的路由 </li><li>使用 module.exports 向外共享路由对象 </li><li>使用 app.use() 函数注册路由模块</li></ul><h4 id="创建路由模块"><a href="#创建路由模块" class="headerlink" title="创建路由模块"></a>创建路由模块</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">'/user/list'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'get user list'</span>)</span><br><span class="line">})</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">'/user/add'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">sen</span>(<span class="string">'add new user'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></tbody></table></figure><h4 id="注册路由模块"><a href="#注册路由模块" class="headerlink" title="注册路由模块"></a>注册路由模块</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./router/user.js'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></tbody></table></figure><h4 id="为路由模块添加前缀"><a href="#为路由模块添加前缀" class="headerlink" title="为路由模块添加前缀"></a>为路由模块添加前缀</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./router/user.js'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/api'</span>, userRouter)</span><br></pre></td></tr></tbody></table></figure><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><h4 id="Express-中间件的格式"><a href="#Express-中间件的格式" class="headerlink" title="Express 中间件的格式"></a>Express 中间件的格式</h4><p>Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：<br>![[Pasted image 20230419144637.png]]<br>注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。</p><h4 id="next-函数的作用"><a href="#next-函数的作用" class="headerlink" title="next 函数的作用"></a>next 函数的作用</h4><p>next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。<br>![[Pasted image 20230419144730.png]]</p><h3 id="Express-中间件的初体验"><a href="#Express-中间件的初体验" class="headerlink" title="Express 中间件的初体验"></a>Express 中间件的初体验</h3><h4 id="定义中间件函数"><a href="#定义中间件函数" class="headerlink" title="定义中间件函数"></a>定义中间件函数</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mw</span> = (<span class="params">req,res,next</span>)=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'这是一个中间件'</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：当前业务处理完毕之后，必须调用<code>next</code>函数，把流转关系交给下个路由</p><h4 id="全局生效的中间件"><a href="#全局生效的中间件" class="headerlink" title="全局生效的中间件"></a>全局生效的中间件</h4><p>客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。 通过调用 <code>app.use(中间件函数)</code>，即可定义一个全局生效的中间件，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mw</span> = (<span class="params">req,res,next</span>)=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(mw)</span><br></pre></td></tr></tbody></table></figure><h4 id="定义全局中间件的简化形式"><a href="#定义全局中间件的简化形式" class="headerlink" title="定义全局中间件的简化形式"></a>定义全局中间件的简化形式</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h4><p>多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 <code>req</code> 或 <code>res</code> 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。<br>![[Pasted image 20230419145411.png]]</p><h4 id="定义多个全局中间件"><a href="#定义多个全局中间件" class="headerlink" title="定义多个全局中间件"></a>定义多个全局中间件</h4><p>可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行 调用，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是第一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是第二个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user'</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'Home Page'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="局部生效的中间件"><a href="#局部生效的中间件" class="headerlink" title="局部生效的中间件"></a>局部生效的中间件</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mw</span> = (<span class="params">req,res,next</span>)=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,mw, <span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'home page'</span>)</span><br><span class="line">}) <span class="comment">// mw仅仅在当前路由生效</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'home page'</span>)</span><br><span class="line">}) <span class="comment">// mw不生效</span></span><br></pre></td></tr></tbody></table></figure><h4 id="定义多个局部中间件"><a href="#定义多个局部中间件" class="headerlink" title="定义多个局部中间件"></a>定义多个局部中间件</h4><p>可以在路由中，通过如下两种等价的方式，使用多个局部中间件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,mw1,mw2,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'home page'</span>)})</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,[mw1,mw2],<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'home page'</span>)})</span><br></pre></td></tr></tbody></table></figure><h4 id="了解中间件的5个使用注意事项"><a href="#了解中间件的5个使用注意事项" class="headerlink" title="了解中间件的5个使用注意事项"></a>了解中间件的5个使用注意事项</h4><ul><li>一定要在路由之前注册中间件</li><li>客户端发送过来的请求，可以连续调用多个中间件进行处理 </li><li>执行完中间件的业务代码之后，不要忘记调用 next() 函数</li><li>为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</li></ul><h4 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h4><p>为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是： </p><ul><li>应用级别的中间件 </li><li>路由级别的中间件 </li><li>错误级别的中间件 </li><li>Express 内置的中间件</li><li>第三方的中间件</li></ul><h5 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h5><p>通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{<span class="title function_">next</span>()})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,mw1,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'home page'</span>)})</span><br></pre></td></tr></tbody></table></figure><h5 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h5><p>绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不 过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'time:'</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/'</span>,router)</span><br></pre></td></tr></tbody></table></figure><h5 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h5><p>错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 <code>(err, req, res, next)</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'服务器内部发生错误'</span>)</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'home page'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'发生了错误：'</span>+err.<span class="property">messege</span>)</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'Error'</span>+err.<span class="property">messege</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>注意：错误级别的中间件， 必须注册在所有路由之后！</p><h4 id="Express内置的中间件"><a href="#Express内置的中间件" class="headerlink" title="Express内置的中间件"></a>Express内置的中间件</h4><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验： </p><ul><li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） </li><li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>({<span class="attr">extended</span>: <span class="literal">false</span>}))</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="第三方的中间件"><a href="#第三方的中间件" class="headerlink" title="第三方的中间件"></a>第三方的中间件</h4><p>非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置 第三方中间件，从而提高项目的开发效率。 例如：在 <a href="mailto:express@4.16.0">express@4.16.0</a> 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步 骤如下：</p><ul><li>运行 npm install body-parser 安装中间件 </li><li>使用 require 导入中间件</li><li>调用 app.use() 注册并使用中间件</li></ul><p>注意：Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。</p><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><h4 id="需求描述与实现步骤"><a href="#需求描述与实现步骤" class="headerlink" title="需求描述与实现步骤"></a>需求描述与实现步骤</h4><p>自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。</p><p>实现步骤：</p><ul><li>定义中间件 </li><li>监听 <code>req</code> 的 <code>data</code> 事件 </li><li>监听 <code>req</code> 的 <code>end</code> 事件 </li><li>使用 <code>querystring</code> 模块解析请求体数据 </li><li>将解析出来的数据对象挂载为 <code>req.body</code> </li><li>将自定义中间件封装为模块</li></ul><h4 id="自定义中间件-1"><a href="#自定义中间件-1" class="headerlink" title="自定义中间件"></a>自定义中间件</h4><p>使用 app.use() 来定义全局生效的中间件，代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="监听-req-的-data-事件"><a href="#监听-req-的-data-事件" class="headerlink" title="监听 req 的 data 事件"></a>监听 req 的 data 事件</h4><p>在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。 如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触 发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">'data'</span>,chunk)=&gt;{</span><br><span class="line">str += chunk</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="监听-req-的-end-事件"><a href="#监听-req-的-end-事件" class="headerlink" title="监听 req 的 end 事件"></a>监听 req 的 end 事件</h4><p>当请求体数据接收完毕之后，会自动触发 req 的 end 事件。 因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">'end'</span>,<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-querystring-模块解析请求体数据"><a href="#使用-querystring-模块解析请求体数据" class="headerlink" title="使用 querystring 模块解析请求体数据"></a>使用 querystring 模块解析请求体数据</h4><p>Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把 查询字符串，解析成对象的格式。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"><span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br></pre></td></tr></tbody></table></figure><h4 id="将解析出来的数据对象挂载为-req-body"><a href="#将解析出来的数据对象挂载为-req-body" class="headerlink" title="将解析出来的数据对象挂载为 req.body"></a>将解析出来的数据对象挂载为 req.body</h4><p>上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">'end'</span>,<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br><span class="line">req.<span class="property">body</span> = body</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="将自定义中间件封装为模块"><a href="#将自定义中间件封装为模块" class="headerlink" title="将自定义中间件封装为模块"></a>将自定义中间件封装为模块</h4><p>为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bodyParser</span>(<span class="params">req,res,next</span>){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = bodyParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBodyParser = <span class="built_in">require</span>(<span class="string">'custom-body-parser'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myBodyParser)</span><br></pre></td></tr></tbody></table></figure><h2 id="使用-Express-写接口"><a href="#使用-Express-写接口" class="headerlink" title="使用 Express 写接口"></a>使用 Express 写接口</h2><h3 id="创建基本的服务器"><a href="#创建基本的服务器" class="headerlink" title="创建基本的服务器"></a>创建基本的服务器</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,(=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'express server running at http://127.0.0.1'</span>)</span><br><span class="line">}))</span><br></pre></td></tr></tbody></table></figure><h3 id="创建-API-路由模块"><a href="#创建-API-路由模块" class="headerlink" title="创建 API 路由模块"></a>创建 API 路由模块</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> apiRouter = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = apiRouter</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">'./apiRouter.js'</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/api'</span>,apiRouter)</span><br></pre></td></tr></tbody></table></figure><h3 id="编写-GET-接口"><a href="#编写-GET-接口" class="headerlink" title="编写 GET 接口"></a>编写 GET 接口</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">get</span>(<span class="string">'/get'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> query = req.<span class="property">query</span></span><br><span class="line">res.<span class="title function_">send</span>({</span><br><span class="line"><span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">msg</span>: <span class="string">'GET请求成功'</span>,</span><br><span class="line"><span class="attr">data</span>: query</span><br><span class="line">})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="编写-POST-接口"><a href="#编写-POST-接口" class="headerlink" title="编写 POST 接口"></a>编写 POST 接口</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">post</span>(<span class="string">'/get'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> query = req.<span class="property">query</span></span><br><span class="line">res.<span class="title function_">send</span>({</span><br><span class="line"><span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">msg</span>: <span class="string">'Post请求成功'</span>,</span><br><span class="line"><span class="attr">data</span>: query</span><br><span class="line">})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>注意：如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 <code>app.use(express.urlencoded({ extended: false }))</code></p><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><h4 id="接口的跨域问题"><a href="#接口的跨域问题" class="headerlink" title="接口的跨域问题"></a>接口的跨域问题</h4><p>刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。<br>解决接口跨域问题的方案主要有两种： </p><ul><li>CORS（主流的解决方案，推荐使用） </li><li>JSONP（有缺陷的解决方案：只支持 GET 请求）</li></ul><h4 id="使用-cors-中间件解决跨域问题"><a href="#使用-cors-中间件解决跨域问题" class="headerlink" title="使用 cors 中间件解决跨域问题"></a>使用 cors 中间件解决跨域问题</h4><p>cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。 使用步骤分为如下 3 步： </p><ul><li>运行 <code>npm install cors</code> 安装中间件 </li><li>使用 <code>const cors = require('cors')</code> 导入中间件 </li><li>在路由之前调用 <code>app.use(cors())</code> 配置中间件</li></ul><h4 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h4><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定 浏览器是否阻止前端 JS 代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头， 就可以解除浏览器端的跨域访问限制。<br>![[Pasted image 20230419152810.png]]</p><h4 id="Cors注意事项"><a href="#Cors注意事项" class="headerlink" title="Cors注意事项"></a>Cors注意事项</h4><ul><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 <code>XMLHttpRequest Level2</code> 的浏览器，才能正常访问开启了 CORS 的服 务端接口（例如：IE10+、Chrome4+、FireFox3.5+）</li></ul><h4 id="CORS-响应头部-Access-Control-Allow-Origin"><a href="#CORS-响应头部-Access-Control-Allow-Origin" class="headerlink" title="CORS 响应头部 - Access-Control-Allow-Origin"></a>CORS 响应头部 - Access-Control-Allow-Origin</h4><p>响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></tbody></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URL。 例如，下面的字段值将只允许来自 <a href="http://itcast.cn/">http://itcast.cn</a> 的请求：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Origin'</span>, url)</span><br></pre></td></tr></tbody></table></figure><p>如果指定了 Access-Control-Allow-Origin 字段的值为通配符 <code>*</code>，表示允许来自任何域的请求，示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="CORS-响应头部-Access-Control-Allow-Headers"><a href="#CORS-响应头部-Access-Control-Allow-Headers" class="headerlink" title="CORS 响应头部 - Access-Control-Allow-Headers"></a><code>CORS 响应头部 - Access-Control-Allow-Headers</code></h4><p>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头： <code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、 Content-Type</code> （值仅限于 <code>text/plain、multipart/form-data、application/x-www-form-urlencoded</code> 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 <code>Access-Control-Allow-Headers</code> 对额外 的请求头进行声明，否则这次请求会失败。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, X-Custom-Header'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="CORS-响应头部-Access-Control-Allow-Methods"><a href="#CORS-响应头部-Access-Control-Allow-Methods" class="headerlink" title="CORS 响应头部 - Access-Control-Allow-Methods"></a><code>CORS 响应头部 - Access-Control-Allow-Methods</code></h4><p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。 示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'POST, GET, DELETE, HEAD'</span>)</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Methods'</span>,<span class="string">'*'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="CORS请求的分类"><a href="#CORS请求的分类" class="headerlink" title="CORS请求的分类"></a>CORS请求的分类</h4><p>客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是： ① 简单请求 ② 预检请求</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>同时满足以下两大条件的请求，就属于简单请求： ① 请求方式：GET、POST、HEAD 三者之一<br>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、 Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</p><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>只要符合以下任何一个条件的请求，都需要进行预检请求：<br>    ① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型<br>    ② 请求头中包含自定义头部字段<br>    ③ 向服务器发送了 application/json 格式的数据<br>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一 次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><h5 id="简单请求和预检请求的区别"><a href="#简单请求和预检请求的区别" class="headerlink" title="简单请求和预检请求的区别"></a>简单请求和预检请求的区别</h5><p>简单请求的特点：客户端与服务器之间只会发生一次请求。<br>预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p><h3 id="JSONP-接口"><a href="#JSONP-接口" class="headerlink" title="JSONP 接口"></a>JSONP 接口</h3><p>概念：浏览器端通过<code>&lt;script&gt;</code>标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP。<br>特点：<br>    ① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。<br>    ② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求</p><h4 id="创建-JSONP-接口的注意事项"><a href="#创建-JSONP-接口的注意事项" class="headerlink" title="创建 JSONP 接口的注意事项"></a>创建 JSONP 接口的注意事项</h4><p>如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/jsonp'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{ })</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/get'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{})</span><br></pre></td></tr></tbody></table></figure><h4 id="实现-JSONP-接口的步骤"><a href="#实现-JSONP-接口的步骤" class="headerlink" title="实现 JSONP 接口的步骤"></a>实现 JSONP 接口的步骤</h4><p>① 获取客户端发送过来的回调函数的名字<br>② 得到要通过 JSONP 形式发送给客户端的数据<br>③ 根据前两步得到的数据，拼接出一个函数调用的字符串<br>④ 把上一步拼接得到的字符串，响应给客户端的<code>&lt;script&gt;</code>标签进行解析执行</p><h4 id="实现-JSONP-接口的具体代码"><a href="#实现-JSONP-接口的具体代码" class="headerlink" title="实现 JSONP 接口的具体代码"></a>实现 JSONP 接口的具体代码</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/jsonp'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{ </span><br><span class="line"><span class="keyword">const</span> funcName = req.<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line"><span class="keyword">const</span> data = {<span class="attr">name</span>: <span class="string">'Alicia'</span>, <span class="attr">age</span>: <span class="string">'prefer not to say'</span>}</span><br><span class="line"><span class="keyword">const</span> scriptStr = <span class="string">`<span class="subst">${funcName}</span>(<span class="subst">${<span class="built_in">JSON</span>.stringify(data)}</span>)`</span></span><br><span class="line">res.<span class="title function_">send</span>(scriptStr)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="在网页中使用-jQuery-发起-JSONP-请求"><a href="#在网页中使用-jQuery-发起-JSONP-请求" class="headerlink" title="在网页中使用 jQuery 发起 JSONP 请求"></a>在网页中使用 jQuery 发起 JSONP 请求</h4><p>调用 $.ajax() 函数，提供 JSONP 的配置选项，从而发起 JSONP 请求，示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#btnJSONP'</span>).<span class="title function_">on</span>(<span class="string">'click'</span>,<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">$.<span class="title function_">ajax</span>({</span><br><span class="line"><span class="attr">method</span>: <span class="string">'GET'</span>,</span><br><span class="line"><span class="attr">url</span>: <span class="string">'http://127.0.0.1'</span>,</span><br><span class="line"><span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Express-简介&quot;&gt;&lt;a href=&quot;#Express-简介&quot; class=&quot;headerlink&quot; title=&quot;Express 简介&quot;&gt;&lt;/a&gt;Express 简介&lt;/h2&gt;&lt;p&gt;Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="工具使用" scheme="https://sajlle.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="express" scheme="https://sajlle.github.io/tags/express/"/>
    
    <category term="路由" scheme="https://sajlle.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
    <category term="服务器" scheme="https://sajlle.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>node.js中的模块化</title>
    <link href="https://sajlle.github.io/2023/04/18/node-js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://sajlle.github.io/2023/04/18/node-js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2023-04-17T17:38:24.000Z</published>
    <updated>2023-04-18T02:14:34.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><ul><li>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） </li><li>自定义模块（用户创建的每个 .js 文件，都是自定义模块）</li><li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载<span id="more"></span><h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>) <span class="comment">// 加载内置模块</span></span><br><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">'./custom.js'</span>) <span class="comment">// 加载自定义模块</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>) <span class="comment">// 加载第三方模块</span></span><br></pre></td></tr></tbody></table></figure><h2 id="共享模块成员"><a href="#共享模块成员" class="headerlink" title="共享模块成员"></a>共享模块成员</h2>每个自定义模块中都存储了module对象，其存贮了当前模块的有关信息。<h3 id="module-exports对象"><a href="#module-exports对象" class="headerlink" title="module.exports对象"></a>module.exports对象</h3>自定义模块可通过module.exports对象将模块成员共享出去，供外界使用。<br>使用<code>require()</code>方法导入自定义模块，得到的就是<code>module.exports</code>指向的对象。<br>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。==默认情况 下，exports 和 module.exports 指向同一个对象==。最终共享的结果，还是以<mark style="background: #FF5582A6;"> module.exports </mark>指向的对象为准</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">username</span> = <span class="string">"Lee"</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {username: "Lee", age: 22}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = {</span><br><span class="line"><span class="attr">gender</span>: <span class="string">'female'</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">"Lee"</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {age: 22}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'mylene farmer'</span>,</span><br><span class="line"><span class="attr">gender</span>: <span class="string">'female'</span>,</span><br><span class="line"><span class="attr">career</span>: <span class="string">'singer'</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = <span class="string">'Lee'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {name: 'mylene farmer', gender: 'female', career: 'singer'}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'mylene farmer'</span>,</span><br><span class="line"><span class="attr">gender</span>: <span class="string">'female'</span>,</span><br><span class="line"><span class="attr">career</span>: <span class="string">'singer'</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = <span class="string">'Lee'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {name: 'mylene farmer', gender: 'female', career: 'singer'}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Node-js中的模块化规范"><a href="#Node-js中的模块化规范" class="headerlink" title="Node.js中的模块化规范"></a>Node.js中的模块化规范</h3><p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。<br>CommonJS 规定：</p><ul><li>每个模块内部，module 变量代表当前模块。</li><li>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 </li><li>加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块</li></ul><h3 id="Node-js中的第三方模块——包"><a href="#Node-js中的第三方模块——包" class="headerlink" title="Node.js中的第三方模块——包"></a>Node.js中的第三方模块——包</h3><h4 id="如何下载包"><a href="#如何下载包" class="headerlink" title="如何下载包"></a>如何下载包</h4><ul><li><a href="https://www.npmjs.com/">npm Inc官网</a> 全球最大的包共享平台，可在此搜索需要的包</li><li><a href="https://registry.npmjs.org/">常用下载地址-来自npm Inc</a> npm Inc提供的共享包的服务器地址，可在此下载需要的包</li><li>查看npm的版本：<code>npm -v</code></li></ul><h4 id="在项目中安装包"><a href="#在项目中安装包" class="headerlink" title="在项目中安装包"></a>在项目中安装包</h4><h5 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h5><p><code>npm install 包名</code>，该命令也可简写为：<code>npm i 包名</code><br>初次安装包之后，多了<code>node_modules</code>文件夹和<code>package-lock.json</code>配置文件</p><ul><li><code>node_modules</code>文件夹：存放已安装到项目中的包<ul><li><code>require()</code>导入第三方包时，就从这个目录中查找并加载包</li></ul></li><li><code>package-lock.json</code>配置文件：记录 <code>node_modules</code> 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。<h5 id="安装指定版本的包"><a href="#安装指定版本的包" class="headerlink" title="安装指定版本的包"></a>安装指定版本的包</h5>默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包 名之后，通过 @ 符号指定具体的版本，例如：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moment@2.22.2</span><br></pre></td></tr></tbody></table></figure><h5 id="包的语义化规范"><a href="#包的语义化规范" class="headerlink" title="包的语义化规范"></a>包的语义化规范</h5>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0 其中每一位数字所代表的的含义如下： </li><li>第1位数字：大版本 </li><li>第2位数字：功能版本 </li><li>第3位数字：Bug修复版本<br>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。</li></ul><h5 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h5><p>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置 信息。例如：</p><ul><li>项目的名称、版本号、描述等 </li><li>项目中都用到了哪些包  </li><li>哪些包只在开发期间会用到 </li><li>哪些包在开发和部署时都需要用到<br>在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。<mark style="background: #ABF7F7A6;">从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码</mark>。</li></ul><p>今后在项目开发中，<mark style="background: #FF5582A6;">一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中</mark>。</p><p>npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理 配置文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在执行命令所处的目录中，快速新建package.json</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></tbody></table></figure><ul><li>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。 </li><li>运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。<h6 id="dependencies-节点"><a href="#dependencies-节点" class="headerlink" title="dependencies 节点"></a>dependencies 节点</h6>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包</li></ul><p>当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。 否则会报类似于下面的错误：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于项目运行依赖该包，如果未提前安装，会报如下错误。</span></span><br><span class="line">Error: Cannot find module <span class="string">'moment'</span></span><br></pre></td></tr></tbody></table></figure><p>可运行如下命令一次安装所有包</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure><p>可运行如下命令卸载指定的包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall moment</span><br></pre></td></tr></tbody></table></figure><h6 id="devDependencies-节点"><a href="#devDependencies-节点" class="headerlink" title="devDependencies 节点"></a>devDependencies 节点</h6><p>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。 与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。</p><p>可以使用如下的命令，将包记录到 devDependencies 节点中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -D <span class="comment">#此是简写形式</span></span><br><span class="line">npm install package --save-Dev</span><br></pre></td></tr></tbody></table></figure><h5 id="解决包下载速度慢的问题"><a href="#解决包下载速度慢的问题" class="headerlink" title="解决包下载速度慢的问题"></a>解决包下载速度慢的问题</h5><ul><li><p>切换下载镜像源头</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前的下包镜像</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment"># 将下包的镜像源切换为淘宝镜像源</span></span><br><span class="line">npm config se registry=https://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 检查镜像源是否下载成功</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>nrm</code>切换镜像源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nrm</span></span><br><span class="line">npm i nrm -g</span><br><span class="line"><span class="comment"># 查看所有可用镜像</span></span><br><span class="line">nrm <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 将镜像切换为淘宝镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h4><p>使用 npm 包管理工具下载的包，共分为两大类，分别是：项目包和全局包</p><h5 id="项目包"><a href="#项目包" class="headerlink" title="项目包"></a>项目包</h5><p>那些被安装到项目的 node_modules 目录中的包，都是项目包。<br>项目包又分为两类，分别是： </p><ul><li>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到） </li><li>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li></ul><h5 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h5><p>在执行 npm install 命令时，如果提供了 <code>-g</code> 参数，则会把包安装为全局包。 全局包会被安装到 <code>C:\Users\用户目录\AppData\Roaming\npm\node_modules</code> 目录下。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i package -g</span><br><span class="line">npm uninstall package -g</span><br></pre></td></tr></tbody></table></figure><ul><li>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 </li><li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</li></ul><h5 id="5ting-toc"><a href="#5ting-toc" class="headerlink" title="5ting_toc"></a>5ting_toc</h5><p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g i5ting_toc</span><br><span class="line">i5ting_toc -f index.md -o</span><br></pre></td></tr></tbody></table></figure><h3 id="包的结构"><a href="#包的结构" class="headerlink" title="包的结构"></a>包的结构</h3><p>一个规范的包，它的组成结构，必须符合以下 3 点要求： ① 包必须以单独的目录而存在 ② 包的顶级目录下要必须包含 package.json 这个包管理配置文件 ③ package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。 注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考<a href="https://yarnpkg.com/zh-Hans/docs/package-json">该网址</a></p><h3 id="开发自己的包"><a href="#开发自己的包" class="headerlink" title="开发自己的包"></a>开发自己的包</h3><ul><li>实现功能</li><li>初始化包的基本结构<ul><li>新建包的根目录</li><li>在根目录下新建三个文件<ul><li><code>package.json</code>管理配置文件</li><li><code>index.js</code>入口文件</li><li><code>README.md</code>说明文档</li></ul></li><li>初始化<code>package.json</code></li><li><code>index.js</code>里写功能，把功能暴露出去</li><li>拆分不同的功能到不同的js文件中</li><li>编写<code>README.md</code>文件，包括安装方式、导入方式，功能介绍，开源协议等。</li></ul></li><li>发布包<ul><li>注册npm账号</li><li>执行<code>npm login</code>命令</li><li>切到包的根目录，运行<code>npm public</code>命令</li></ul></li><li>删除已经发布的包<ul><li>运行<code>npm uninstall package --force</code><ul><li>只能删除72hours之内的包</li><li>24小时内不许重新发布</li></ul></li></ul></li></ul><h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><h3 id="内置模块的加载机制"><a href="#内置模块的加载机制" class="headerlink" title="内置模块的加载机制"></a>内置模块的加载机制</h3><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。 例如，require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p><h3 id="自定义模块的加载机制"><a href="#自定义模块的加载机制" class="headerlink" title="自定义模块的加载机制"></a>自定义模块的加载机制</h3><p>使用 require() 加载自定义模块时，必须指定以 <code>./</code> 或 <code>../</code> 开头的路径标识符。<br>在加载自定义模块时，==如果没有指定 <code>./</code> 或 <code>../</code> 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。==<br>同时，在使用 <code>require()</code> 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p><ul><li>按照确切的文件名进行加载 </li><li> 补全 .js 扩展名进行加载 </li><li> 补全 .json 扩展名进行加载 </li><li> 补全 .node 扩展名进行加载 </li><li> 加载失败，终端报错</li></ul><h3 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h3><p>如果传递给 <code>require()</code> 的模块标识符不是一个内置模块，也没有以 <code>./</code> 或 <code>../</code> 开头，则 Node.js 会从当前模块的父 目录开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</p><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。 </p><p>例如，假设<code>'C:\Users\itheima\project\foo.js</code>‘ 文件里调用了 <code>require('tools')</code>，则 Node.js 会按以下顺序查找： </p><ul><li><code>C:\Users\itheima\project\node_modules\tools</code> </li><li><code>C:\Users\itheima\node_modules\tools</code></li><li><code>C:\Users\node_modules\tools</code></li><li><code>C:\node_modules\tools</code></li></ul><h3 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h3><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：<br>① 在被加载的目录下查找一个叫做 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口<br>② 如果目录里没有 <code>package.json</code> 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。<br>③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：<code>Error: Cannot find module 'xxx'</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;模块分类&quot;&gt;&lt;a href=&quot;#模块分类&quot; class=&quot;headerlink&quot; title=&quot;模块分类&quot;&gt;&lt;/a&gt;模块分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） &lt;/li&gt;
&lt;li&gt;自定义模块（用户创建的每个 .js 文件，都是自定义模块）&lt;/li&gt;
&lt;li&gt;第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Node" scheme="https://sajlle.github.io/tags/Node/"/>
    
    <category term="npm" scheme="https://sajlle.github.io/tags/npm/"/>
    
    <category term="工具使用" scheme="https://sajlle.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>git建仓折腾记</title>
    <link href="https://sajlle.github.io/2023/04/16/git%E5%BB%BA%E4%BB%93%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>https://sajlle.github.io/2023/04/16/git%E5%BB%BA%E4%BB%93%E6%8A%98%E8%85%BE%E8%AE%B0/</id>
    <published>2023-04-15T22:13:43.000Z</published>
    <updated>2023-04-15T14:17:13.598Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚刚注册GitHub账号，想要建仓，遇到了种种神奇的问题，让俺再次对GitHub的复杂提升了认识。<br>遂决定把这次建仓折腾的经过记录下来，以作备用。</p><span id="more"></span><p>注册账号掠过不提，从建仓库说起。</p><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><ul><li>输入<code>git config --global user.name 'yourname'</code>，添加用户名<ul><li><code>yourname</code>是你GitHub账号名称</li></ul></li><li>输入<code>git config --global user.email 'youremail'</code>，添加邮箱<ul><li><code>youremail</code>是GitHub注册的邮箱地址</li></ul></li><li>以上两条命令配置的文件会被写入文件夹下的.gitconfig文件中，该文件是git的全局配置文件。</li><li>如何检查是否配置成功了呢？<ul><li>输入<code>git config user.name</code> ，如果返回<code>yourname</code>，则表示配置成功</li></ul></li></ul><h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><ul><li>打开准备作为git仓库的文件夹，运行git bash</li><li>输入 <code>git init</code> 初始化仓库<ul><li>该命令会创建一个.git的隐藏目录，这个目录里包含了初始文件（很重要，不要随便移除它哦）</li></ul></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="git中的文件有四种状态"><a href="#git中的文件有四种状态" class="headerlink" title="git中的文件有四种状态"></a>git中的文件有四种状态</h4><ul><li>未管理</li><li>已管理<ul><li>未修改</li><li>已修改</li><li>已暂存</li><li>已提交<h4 id="操作未提交的文件"><a href="#操作未提交的文件" class="headerlink" title="操作未提交的文件"></a>操作未提交的文件</h4></li></ul></li><li>使用<code>git status</code>检查文件状态<ul><li>可用<code>git status -s</code>精简输出</li></ul></li><li>使用<code>git add filename</code>开始追踪一个文件</li><li>使用<code>git commit -m "message"</code>提交文件<h4 id="操作已提交的文件"><a href="#操作已提交的文件" class="headerlink" title="操作已提交的文件"></a>操作已提交的文件</h4></li><li>文件修改之后，使用<code>git add filename</code>把文件添加到暂存区</li><li>使用<code>git commit -m "message"</code>提交修改后的文件</li><li>使用<code>git checkout --filename</code>撤销修改，（所有修改均会消息，慎用）<h4 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h4></li><li>使用<code>git add .</code>一次添加多个文件到暂存区</li><li>使用<code>git reset HEAD filename</code>，从暂存区移除文件</li><li>使用<code>git commit -a -m "messge"</code> 跳过暂存，直接提交<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4></li><li><code>git rm -f filename</code>从仓库和工作区中移除文件</li><li><code>git rm --cached filename</code>从仓库中移除，工作区保留<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4>在根目录下创建<code>.gitignore</code>文件，写明要忽略的文件<br>该文件的规范如下：</li><li><code>#</code>开头的是注释</li><li><code>/</code>结尾的是目录</li><li><code>/</code>开头的是防止递归</li><li><code>！</code>开头的是取反</li><li>可以使用glob模式进行文件和文件夹的匹配<h4 id="glob模式"><a href="#glob模式" class="headerlink" title="glob模式"></a>glob模式</h4></li><li><code>*</code>匹配&gt;=0个字符</li><li><code>[abc]</code>匹配方括号中任意一个字符</li><li><code>?</code>匹配1个任意字符</li><li><code>**</code>匹配任意中间目录，例如：<code>a/**/z</code>可以匹配<code>a/z</code>，<code>a/c/z</code>等<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4></li><li><code>git log</code>查看所有提交历史</li><li><code>git log -2</code>只显示最近的2条提交历史</li><li><code>git log -2 --pretty=oneline</code>在一行上显示最近的两条提交历史</li><li><code>git log -2 --pretty=format:"%h | %an | %ar | %s "</code>以规定格式显示最近提交历史，<code>%h</code>表示简写哈希，<code>%an</code>表示作者，<code>%ar</code>表示作者修订日期，<code>%s</code>表示提交说明<h4 id="回退到指定版本"><a href="#回退到指定版本" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h4></li><li><code>git reset --hard &lt;CommitID&gt;</code>根据指定的提交ID回退到指定版本</li><li><code>git relog --pretty=oneline</code>查看命令操作历史</li><li><code>git reset --hard &lt;CommitID&gt;</code>根据最新的提交ID，跳到最新版本</li></ul><h3 id="Github远程仓库使用"><a href="#Github远程仓库使用" class="headerlink" title="Github远程仓库使用"></a>Github远程仓库使用</h3><h4 id="访问GitHub远程仓库"><a href="#访问GitHub远程仓库" class="headerlink" title="访问GitHub远程仓库"></a>访问GitHub远程仓库</h4><ul><li>获取仓库地址（ssh地址或者http地址）</li><li>复制GitHub仓库的https地址（或者ssh地址）</li><li>在git bash 中输入以下命令<code>git remote add 远程仓库名称 远程仓库地址</code>，访问远程仓库</li><li>使用<code>git push -u 仓库名称 仓库分支</code>，将内容推送到远程仓库指定分支上<h4 id="设置ssh密钥"><a href="#设置ssh密钥" class="headerlink" title="设置ssh密钥"></a>设置ssh密钥</h4>远程登陆GitHub仓库有两种方式，一种是http登陆，一种是ssh登陆。http登陆每次要输入用户名密码比较麻烦，所以常用ssh登陆。<br>ssh登陆需要设置ssh密钥，下面我们就开始配置ssh。<ul><li>打开仓库文件夹，运行git bash</li><li>输入<code>ssh-keygen -t rsa -b 4096 -C 'youremail'</code>，该命令会在指定目录设立一个.ssh文件夹，文件夹里保存了公钥和私钥。</li><li>用记事本打开.pub文件（公钥文件），复制内容，粘贴到GitHub上的ssh配置页面。</li><li>回到git bash，运行<code>ssh -T git@github.com</code>，检测ssh是否配置成功。<h4 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a>将远程仓库克隆到本地</h4></li></ul></li><li><code>git clone 远程仓库地址</code></li></ul><h4 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h4><h5 id="本地分支操作"><a href="#本地分支操作" class="headerlink" title="本地分支操作"></a>本地分支操作</h5><ul><li><code>git branch</code> 查看分支列表</li><li><code>git branch newbranch</code>创建新分支</li><li><code>git checkout newbranch</code>切到指定分支上</li><li><code>git checkout -b name</code>创建并切换到name分支上</li><li><code>git merge name</code>合并分支name到当前所在分支</li><li><code>git branch -d name </code>删除name分支<h5 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h5></li><li><code>git remote show 远程仓库名称</code> ，查看远程仓中所有分支列表</li><li>跟踪分支<ul><li><code>git checkout 远程分支名称</code>，下载远程分支到本地</li><li><code>git checkout -b 本地分支名称 远程仓库名称/远程分支名称</code>，下载远程分支到本地并重命名</li></ul></li><li>拉取远程分支最新代码<ul><li><code>git pull</code>从远程仓里拉取当前分支最新代码，保持当前分支和远程分支代码一致</li></ul></li><li>删除远程分支<ul><li><code>git push 远程仓库名称 --delete 远程分支名称</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近刚刚注册GitHub账号，想要建仓，遇到了种种神奇的问题，让俺再次对GitHub的复杂提升了认识。&lt;br&gt;遂决定把这次建仓折腾的经过记录下来，以作备用。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sajlle.github.io/tags/git/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="GitHub" scheme="https://sajlle.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>如何快速上手shell？</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bshell%EF%BC%9F/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bshell%EF%BC%9F/</id>
    <published>2023-04-15T14:52:20.000Z</published>
    <updated>2023-04-15T06:55:42.297Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本课程讲述的是Bourne Again SHell，即bash<span id="more"></span><h2 id="使用Shell"><a href="#使用Shell" class="headerlink" title="使用Shell"></a>使用Shell</h2></li><li><code>missing:~$</code> shell文本接口，主机名为<code>missing</code>，且当前的工作目录（current working directory)是<code>~</code>，<code>$</code>符号表示您不是<code>root</code>用户</li><li>shell如何解析和执行程序？<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br></pre></td></tr></tbody></table></figure><ul><li>上面的示例中，shell执行echo, 同时指定参数hello。</li><li>shell基于空格分割命令并解析，执行第一个单词代表的程序，将后续的单词作为程序可以访问的参数。</li><li>如果想传递包含空格的参数，如名为“My Photos”的文件夹，则可用单引号或者双引号或者使用转义符号<code>\</code>进行处理</li></ul></li><li>shell如何寻找<code>echo</code>?<ul><li>通过咨询<mark style="background: #FF5582A6;">环境变量</mark><code>$PATH</code></li><li><code>$PATH</code>会列出当shell接受某条指令时，进行程序搜索的路径<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></tbody></table></figure></li><li>该目录由<code>:</code>分割。上例中，shell先找了<code>usr/local/sbin</code>，又找了<code>usr/local/bin</code>，接着找<code>usr/sbin</code>，又找了<code>usr/bin</code>…</li><li>可以用<code>which</code>确定该程序名代表的是那个程序</li><li>也可绕过<code>$PATH</code>，直接指定需要执行的程序路径来执行该程序</li></ul></li></ul><h2 id="在shell中导航"><a href="#在shell中导航" class="headerlink" title="在shell中导航"></a>在shell中导航</h2><ul><li>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用&nbsp;<code>/</code>&nbsp;分割，而在Windows上是&nbsp;<code>\</code></li><li><code>/</code>&nbsp;代表的是系统的根目录</li><li>如果某个路径以&nbsp;<code>/</code>&nbsp;开头，那么它是一个&nbsp;<mark style="background: #FF5582A6;"><em>绝对路径</em></mark>，其他的都是&nbsp;<em>相对路径</em>&nbsp;。</li><li><mark style="background: #FF5582A6;">相对路径</mark>是指相对于当前工作目录的路径</li><li>当前工作目录可以使用<mark style="background: #FF5582A6;">&nbsp;<code>pwd</code>&nbsp;</mark>命令来获取。</li><li>切换目录需要使用<mark style="background: #FF5582A6;">&nbsp;<code>cd</code>&nbsp;</mark>命令</li><li><code>.</code>&nbsp;表示的是当前目录，而&nbsp;<code>..</code>&nbsp;表示<mark style="background: #FF5582A6;">上级目录</mark></li><li>当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。</li></ul><h3 id="如何查看目录？"><a href="#如何查看目录？" class="headerlink" title="如何查看目录？"></a>如何查看目录？</h3><ul><li><mark style="background: #FF5582A6;"><code>ls</code>&nbsp;</mark>命令：查看指定目录下包含哪些文件<ul><li>除非我们利用第一个参数指定目录，否则&nbsp;<code>ls</code>&nbsp;会打印当前目录下的文件。</li><li>在执行程序时使用&nbsp;<code>-h</code>&nbsp;或&nbsp;<code>--help</code>&nbsp;标记可以打印帮助信息</li><li><code>-l</code> 可以更加详细地列出目录下文件或文件夹的信息，案例如下：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span> -l /home</span><br><span class="line">drwxr-xr-x 1 missing  <span class="built_in">users</span>  4096 Jun 15  2019 missing</span><br></pre></td></tr></tbody></table></figure></li><li>第一个字符&nbsp;<code>d</code>&nbsp;表示&nbsp;<code>missing</code>&nbsp;是一个目录</li><li>接下来的九个字符，每三个字符构成一组。<ul><li>（<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。</li><li><code>-</code>&nbsp;表示该用户不具备相应的权限。</li><li><code>missing</code>，即文件所有者，有读<code>r</code>写<code>w</code>和搜索<code>x</code>的权利</li><li><code>users</code>，即用户，有读取<code>r</code>和搜索<code>x</code>的权利</li><li>其他人只有读取<code>r</code>和搜索<code>x</code>的权利</li><li>附注：<ul><li>为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。</li><li>为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）</li><li><code>/bin</code>&nbsp;目录下的程序在最后一组，即表示所有人的用户组中，均包含&nbsp;<code>x</code>&nbsp;权限，也就是说任何人都可以执行这些程序。</li></ul></li></ul></li></ul></li></ul><h3 id="shell常见命令"><a href="#shell常见命令" class="headerlink" title="shell常见命令"></a>shell常见命令</h3><ul><li><code>mv</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/mv.md">移动文件</a>，改文件名</li><li><code>pwd</code> &nbsp;print work directory 打印当前目录 显示出当前工作目录的绝对路径</li><li><code>cp</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/cp.md">拷贝文件</a> </li><li><code>mkdir</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/mkdir.md">新建文件夹</a></li><li><code>man</code> <mark style="background: #FF5582A6;">打印程序参数</mark>，输入输出信息，程序工作方式，展示用户手册。按<code>q</code>退出该程序, press ctrl+L can clear your terminal</li><li><code>ed</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/ed.md">文本编辑</a> </li><li><code>chmod</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/chmod.md">更改用户对文件的权限</a></li><li><code>cat</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/cat.md">连接且打印文件</a></li><li><code>rm</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/rm.md">删除文件</a>（不可恢复）</li><li><code>ls</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/ls.md">打印目录</a></li><li><code>cd</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/cd.md">更改目录</a> </li><li><code>echo</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/echo.md">输出字符串</a> </li><li><code>tail</code><a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/tail.md">print the last nth line</a> </li><li><code>grep</code>  <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/grep">查找文件或者字符串</a></li><li><code>tee</code>  <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/tee.md">运行程序时，将结果打印到terminal上</a><h2 id="在程序间创建链接"><a href="#在程序间创建链接" class="headerlink" title="在程序间创建链接"></a>在程序间创建链接</h2></li><li>在 shell 中，程序有两个主要的“流”：它们的<mark style="background: #FF5582A6;">输入流和输出流</mark>。<ul><li>当程序尝试读取信息时，它们会从输入流中进行读取</li><li>当程序打印信息时，它们会将信息输出到输出流中。</li><li>通常，一个程序的输入输出流都是您的终端。（键盘作为输入，显示器作为输出）</li><li>可以<mark style="background: #FF5582A6;">重定向这些流</mark>！<ul><li>最简单的重定向是&nbsp;<code>&lt; file</code>&nbsp;和&nbsp;<code>&gt; file</code>。</li><li>这两个命令可以将程序的输入输出流分别重定向到文件<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello &gt; hello.txt   // 将hello追加到hello.txt中</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello.txt  // 打印hello.txt的内容</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt  // ？</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt  // 把<span class="built_in">cat</span>输出的内容追加到hello.txt, 再把hello.txt文件的内容追加给hello2.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello2.txt  // 打印hello2.txt文件的内容</span><br><span class="line">hello</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li>还可以使用&nbsp;<code>&gt;&gt;</code>&nbsp;来<mark style="background: #FF5582A6;">向一个文件追加内容</mark><ul><li>使用管道（&nbsp;<em>pipes</em>&nbsp;），我们能够更好的利用文件重定向。</li><li><code>|</code>&nbsp;<mark style="background: #FF5582A6;">操作符</mark>允许我们将一个程序的输出和另外一个程序的输入连接起来<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span> -l / | <span class="built_in">tail</span> -n1   </span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --<span class="built_in">head</span> --silent google.com | grep --ignore-case content-length | <span class="built_in">cut</span> --delimiter=<span class="string">' '</span> -f2</span><br><span class="line">219</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="sudo-和-su，以根用户的身份操作系统"><a href="#sudo-和-su，以根用户的身份操作系统" class="headerlink" title="sudo 和 su，以根用户的身份操作系统"></a>sudo 和 su，以根用户的身份操作系统</h2><ul><li><code>root user</code>可以创建、读取、更新和删除系统中的任何文件</li><li><code>$</code>说明你以普通用户运行程序，<code>#</code>说明你以管理员身份运行程序，</li><li>使用<code>sudo su</code>命令切换为管理员</li><li>使用<code>exit</code>命令退出管理员模式</li><li>通常在用户不会以根用户的身份直接登录系统<ul><li>此时用户想要操作文件，可以使用<mark style="background: #FF5582A6;"><code>sudo</code>命令</mark></li><li><code>sudo</code>命令可以让普通用户以<code>su</code>(即super user或者root的简写)的身份进行操作</li><li>如果遇到拒绝访问（<code>permission denied</code>）错误时，常常因为您必须是根用户才能操作</li></ul></li><li>只有<code>root user</code>才能做的事情：<ul><li>向&nbsp;<mark style="background: #FF5582A6;"><code>sysfs</code>&nbsp;文件</mark>写入内容。</li><li>系统被挂载在&nbsp;<code>/sys</code>&nbsp;下，<code>sysfs</code>&nbsp;文件则暴露了一些内核（kernel）参数。</li><li><strong>注意 Windows 和 macOS 没有这个文件</strong></li><li>例如：笔记本电脑屏幕亮度写在<code>brightness</code>文件中，此文件位于<code>/sys/class/backlight</code><ul><li>在此文件中写入数值，可以更改屏幕亮度，代码如下<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">'*brightness*'</span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line">$ <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span><br><span class="line">$ sudo <span class="built_in">echo</span> 3 &gt; brightness</span><br><span class="line">An error occurred <span class="keyword">while</span> redirecting file <span class="string">'brightness'</span></span><br><span class="line">open: Permission denied</span><br></pre></td></tr></tbody></table></figure>被拒绝了，因为不是根用户，且<code>|</code>、<code>&gt;</code>、和&nbsp;<code>&lt;</code>&nbsp;是<mark style="background: #FF5582A6;">通过 shell 执行的</mark>，而不是被各个程序单独执行。&nbsp;<code>echo</code>&nbsp;等程序并不知道&nbsp;<code>|</code>&nbsp;的存在，<mark style="background: #FF5582A6;">它们只知道从自己的输入输出流中进行读写</mark>。可以这写：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 3 | sudo <span class="built_in">tee</span> brightness</span><br></pre></td></tr></tbody></table></figure>打开&nbsp;<code>/sys</code>&nbsp;文件的是<mark style="background: #FF5582A6;">&nbsp;<code>tee</code>&nbsp;</mark>这个程序，并且该程序以<mark style="background: #FF5582A6;">&nbsp;<code>root</code>&nbsp;</mark>权限在运行，因此操作可以进行。<br>注释：<code>tee</code>的作用是把内容写到 brightness 里然后再输出到公屏上。<br>注释：<code>|</code>的作用是把两个程序连接起来，差不多是等前面的程序执行完毕，再执行后面的程序</li></ul></li></ul></li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol><li> 本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>或者是 Linux 虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">me@k345:/sys/power$ <span class="built_in">cd</span> ~</span><br><span class="line">me@k345:~$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></tbody></table></figure></li><li>在&nbsp;<code>/tmp</code>&nbsp;下新建一个名为&nbsp;<code>missing</code>&nbsp;的文件夹。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~$ <span class="built_in">mkdir</span> tmp/missing</span><br><span class="line">me@k345:~$ <span class="built_in">ls</span></span><br><span class="line">tmp</span><br><span class="line">me@k345:~$ <span class="built_in">cd</span> tmp/missing</span><br></pre></td></tr></tbody></table></figure></li><li> 用&nbsp;<code>man</code>&nbsp;查看程序&nbsp;<code>touch</code>&nbsp;的使用手册。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ man <span class="built_in">touch</span></span><br></pre></td></tr></tbody></table></figure></li><li>用&nbsp;<code>touch</code>&nbsp;在&nbsp;<code>missing</code>&nbsp;文件夹中新建一个叫&nbsp;<code>semester</code>&nbsp;的文件。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ <span class="built_in">touch</span> semester</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">ls</span></span><br><span class="line">semester</span><br></pre></td></tr></tbody></table></figure></li><li>将以下内容一行一行地写入&nbsp;<code>semester</code>&nbsp;文件：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent https://missing.csail.mit.edu</span><br></pre></td></tr></tbody></table></figure><ul><li>第一行可能有点棘手，&nbsp;<code>#</code>&nbsp;在Bash中表示注释，而&nbsp;<code>!</code>&nbsp;即使被双引号（<code>"</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考&nbsp;<a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ <span class="built_in">echo</span> <span class="string">'#!/bin/sh'</span> &gt; semester</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">echo</span> curl --<span class="built_in">head</span> --silent https://missing.csail.mit.edu &gt;&gt; semester</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">cat</span> semester</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent https://missing.csnail.mit.edu</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用&nbsp;<code>ls</code>&nbsp;命令来获取信息并理解其不能执行的原因。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ ./semester</span><br><span class="line">-bash: ./semester: Permission denied</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">ls</span> -l semester</span><br><span class="line">-rw-r--r-- 1 me me 62 Dec 13 16:15 semester</span><br></pre></td></tr></tbody></table></figure></li><li>查看&nbsp;<a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/chmod.md"><code>chmod</code>&nbsp;</a>的手册(例如，使用&nbsp;<code>man chmod</code>&nbsp;命令)<br><code>man chmod</code></li><li>使用&nbsp;<code>chmod</code>&nbsp;命令改变权限，使&nbsp;<code>./semester</code>&nbsp;能够成功执行，不要使用&nbsp;<code>sh semester</code>&nbsp;来执行该程序。您的 shell 是如何知晓这个文件需要使用<mark style="background: #FF5582A6;">&nbsp;<code>sh</code>&nbsp;</mark>来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ <span class="built_in">chmod</span> 774 semester</span><br><span class="line">me@k345:~/tmp/missing$ ./semester</span><br><span class="line">HTTP/2 200</span><br><span class="line">server: GitHub.com</span><br><span class="line">content-type: text/html; charset=utf-8</span><br><span class="line">last-modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">etag: <span class="string">"638e155b-1f37"</span></span><br><span class="line">expires: Tue, 13 Dec 2022 06:00:39 GMT</span><br><span class="line">cache-control: max-age=600</span><br><span class="line">x-proxy-cache: MISS</span><br><span class="line">x-github-request-id: 1384:4AB2:A56CA:BC41A:639812AF</span><br><span class="line">accept-ranges: bytes</span><br><span class="line"><span class="built_in">date</span>: Tue, 13 Dec 2022 08:25:13 GMT</span><br><span class="line">via: 1.1 varnish</span><br><span class="line">age: 0</span><br><span class="line">x-served-by: cache-hkg17927-HKG</span><br><span class="line">x-cache: HIT</span><br><span class="line">x-cache-hits: 1</span><br><span class="line">x-timer: S1670919913.350973,VS0,VE369</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">x-fastly-request-id: a3eb30c6a4647450e4a045e388d5f9eccb08d85d</span><br><span class="line">content-length: 7991</span><br></pre></td></tr></tbody></table></figure></li><li>使用&nbsp;<code>|</code>&nbsp;和&nbsp;<code>&gt;</code>&nbsp;，将&nbsp;<code>semester</code>&nbsp;文件输出的最后更改日期信息，写入主目录下的&nbsp;<code>last-modified.txt</code>&nbsp;的文件中<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ ./semester | grep last-modified</span><br><span class="line">last-modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br><span class="line">me@k345:~/tmp/missing$ ./semester | grep last-modified &gt; ~/last-modified.txt</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">cat</span> ~/last-modified.txt</span><br><span class="line">last-modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br></pre></td></tr></tbody></table></figure></li><li>写一段命令来从&nbsp;<code>/sys</code>&nbsp;中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">me@k345:/sys/class/power_supply/battery$ <span class="built_in">cat</span> /sys/class/power_supply/battery/capacity</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本课程讲述的是Bourne Again SHell，即bash&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
    <category term="Shell" scheme="https://sajlle.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>命令行环境介绍</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-04-15T14:51:21.000Z</published>
    <updated>2023-04-15T06:57:12.345Z</updated>
    
    <content type="html"><![CDATA[<p>当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p><p>我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p><p>我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p><span id="more"></span><h1 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h1><p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用&nbsp;<code>find</code>&nbsp;搜索一个非常大的目录结构）。大多数情况下，我们可以使用&nbsp;<code>Ctrl-C</code>&nbsp;来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p><p>在上面的例子中，当我们输入&nbsp;<code>Ctrl-C</code>&nbsp;时，shell 会发送一个<code>SIGINT</code>&nbsp;信号到进程。</p><p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code>&nbsp;并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code>&nbsp;信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import signal, time</span><br><span class="line"></span><br><span class="line">def handler(signum, time):</span><br><span class="line">    print("\nI got a SIGINT, but I am not stopping")</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    time.sleep(.1)</span><br><span class="line">    print("\r{}".format(i), end="")</span><br><span class="line">    i += 1</span><br></pre></td></tr></tbody></table></figure><p>如果我们向这个程序发送两次&nbsp;<code>SIGINT</code>&nbsp;，然后再发送一次&nbsp;<code>SIGQUIT</code>，程序会有什么反应？注意&nbsp;<code>^</code>&nbsp;是我们在终端输入<code>Ctrl</code>&nbsp;时的表示形式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python sigint.py</span><br><span class="line">24^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">26^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">30^\[1]    39913 quit       python sigint.pyƒ</span><br></pre></td></tr></tbody></table></figure><p>尽管&nbsp;<code>SIGINT</code>&nbsp;和&nbsp;<code>SIGQUIT</code>&nbsp;都常常用来发出和终止程序相关的请求。<code>SIGTERM</code>&nbsp;则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a>&nbsp;命令, 它的语法是：&nbsp;<code>kill -TERM &lt;PID&gt;</code>。</p><h2 id="暂停和后台执行进程"><a href="#暂停和后台执行进程" class="headerlink" title="暂停和后台执行进程"></a>暂停和后台执行进程</h2><p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code>&nbsp;会让进程暂停。在终端中，键入&nbsp;<code>Ctrl-Z</code>&nbsp;会让 shell 发送&nbsp;<code>SIGTSTP</code>&nbsp;信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p><p>我们可以使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a>&nbsp;或&nbsp;<a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a>&nbsp;命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p><p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a>&nbsp;命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a>&nbsp;找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code>&nbsp;会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用&nbsp;<code>$!</code>&nbsp;这一特殊参数。</p><p>还有一件事情需要掌握，那就是命令中的&nbsp;<code>&amp;</code>&nbsp;后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p><p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code>&nbsp;，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a>&nbsp;(一个用来忽略&nbsp;<code>SIGHUP</code>&nbsp;的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code>&nbsp;。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p><p>下面这个简单的会话中展示来了些概念的应用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>SIGKILL</code>&nbsp;是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p><p>您可以在&nbsp;<a href="https://en.wikipedia.org/wiki/Signal_(IPC)">这里</a>&nbsp;或输入&nbsp;<a href="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a>&nbsp;或使用&nbsp;<code>kill -l</code>&nbsp;来获取更多关于信号的信息。</p><h1 id="终端多路复用"><a href="#终端多路复用" class="headerlink" title="终端多路复用"></a>终端多路复用</h1><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p><p>像&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>&nbsp;这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p><p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p><p>这让您操作远端设备时的工作流大大改善，避免了&nbsp;<code>nohup</code>&nbsp;和其他类似技巧的使用。</p><p>现在最流行的终端多路器是&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code>&nbsp;是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p><p><code>tmux</code>&nbsp;的快捷键需要我们掌握，它们都是类似&nbsp;<code>&lt;C-b&gt; x</code>&nbsp;这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下&nbsp;<code>x</code>。<code>tmux</code>&nbsp;中对象的继承结构如下：</p><ul><li><strong>会话</strong>&nbsp;- 每个会话都是一个独立的工作区，其中包含一个或多个窗口<ul><li>  <code>tmux</code>&nbsp;开始一个新的会话</li><li>  <code>tmux new -s NAME</code>&nbsp;以指定名称开始一个新的会话</li><li>  <code>tmux ls</code>&nbsp;列出当前所有会话</li><li>  在&nbsp;<code>tmux</code>&nbsp;中输入&nbsp;<code>&lt;C-b&gt; d</code>&nbsp;，将当前会话分离</li><li>  <code>tmux a</code>&nbsp;重新连接最后一个会话。您也可以通过&nbsp;<code>-t</code>&nbsp;来指定具体的会话</li></ul></li><li><strong>窗口</strong>&nbsp;- 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<ul><li>  <code>&lt;C-b&gt; c</code>&nbsp;创建一个新的窗口，使用&nbsp;<code>&lt;C-d&gt;</code>关闭</li><li>  <code>&lt;C-b&gt; N</code>&nbsp;跳转到第&nbsp;<em>N</em>&nbsp;个窗口，注意每个窗口都是有编号的</li><li>  <code>&lt;C-b&gt; p</code>&nbsp;切换到前一个窗口</li><li>  <code>&lt;C-b&gt; n</code>&nbsp;切换到下一个窗口</li><li>  <code>&lt;C-b&gt; ,</code>&nbsp;重命名当前窗口</li><li>  <code>&lt;C-b&gt; w</code>&nbsp;列出当前所有窗口</li></ul></li><li><strong>面板</strong>&nbsp;- 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<ul><li>  <code>&lt;C-b&gt; "</code>&nbsp;水平分割</li><li>  <code>&lt;C-b&gt; %</code>&nbsp;垂直分割</li><li>  <code>&lt;C-b&gt; &lt;方向&gt;</code>&nbsp;切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li><li>  <code>&lt;C-b&gt; z</code>&nbsp;切换当前面板的缩放</li><li>  <code>&lt;C-b&gt; [</code>&nbsp;开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li><li>  <code>&lt;C-b&gt; &lt;空格&gt;</code>&nbsp;在不同的面板排布间切换</li></ul></li></ul><p>扩展阅读：&nbsp;<a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a>&nbsp;是一份&nbsp;<code>tmux</code>&nbsp;快速入门教程，&nbsp;<a href="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a>&nbsp;文章则更加详细，它包含了&nbsp;<code>screen</code>&nbsp;命令。您也许想要掌握&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a>&nbsp;命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias alias_name="command_to_alias arg1 arg2"</span><br></pre></td></tr></tbody></table></figure><p>注意，&nbsp;<code>=</code>两边是没有空格的，因为&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a>&nbsp;是一个 shell 命令，它只接受一个参数。</p><p>别名有许多很方便的特性:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 创建常用命令的缩写</span><br><span class="line">alias ll="ls -lh"</span><br><span class="line"></span><br><span class="line"># 能够少输入很多</span><br><span class="line">alias gs="git status"</span><br><span class="line">alias gc="git commit"</span><br><span class="line">alias v="vim"</span><br><span class="line"></span><br><span class="line"># 手误打错命令也没关系</span><br><span class="line">alias sl=ls</span><br><span class="line"></span><br><span class="line"># 重新定义一些命令行的默认行为</span><br><span class="line">alias mv="mv -i"           # -i prompts before overwrite</span><br><span class="line">alias mkdir="mkdir -p"     # -p make parent dirs as needed</span><br><span class="line">alias df="df -h"           # -h prints human readable format</span><br><span class="line"></span><br><span class="line"># 别名可以组合使用</span><br><span class="line">alias la="ls -A"</span><br><span class="line">alias lla="la -l"</span><br><span class="line"></span><br><span class="line"># 在忽略某个别名</span><br><span class="line">\ls</span><br><span class="line"># 或者禁用别名</span><br><span class="line">unalias la</span><br><span class="line"></span><br><span class="line"># 获取别名的定义</span><br><span class="line">alias ll</span><br><span class="line"># 会打印 ll='ls -lh'</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code>&nbsp;或&nbsp;<code>.zshrc</code>，下一节我们就会讲到。</p><h1 id="配置文件（Dotfiles）"><a href="#配置文件（Dotfiles）" class="headerlink" title="配置文件（Dotfiles）"></a>配置文件（Dotfiles）</h1><p>很多程序的配置都是通过纯文本格式的被称作_点文件_的配置文件来完成的（之所以称为点文件，是因为它们的文件名以&nbsp;<code>.</code>&nbsp;开头，例如&nbsp;<code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p><p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a>&nbsp;有非常好的资源</p><p>对于&nbsp;<code>bash</code>来说，在大多数系统下，您可以通过编辑&nbsp;<code>.bashrc</code>&nbsp;或&nbsp;<code>.bash_profile</code>&nbsp;来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p><p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似&nbsp;<code>export PATH="$PATH:/path/to/program/bin"</code>&nbsp;的命令，这样才能确保这些程序能够被 shell 找到。</p><p>还有一些其他的工具也可以通过_点文件_进行配置：</p><ul><li>  <code>bash</code>&nbsp;-&nbsp;<code>~/.bashrc</code>,&nbsp;<code>~/.bash_profile</code></li><li>  <code>git</code>&nbsp;-&nbsp;<code>~/.gitconfig</code></li><li>  <code>vim</code>&nbsp;-&nbsp;<code>~/.vimrc</code>&nbsp;和&nbsp;<code>~/.vim</code>&nbsp;目录</li><li>  <code>ssh</code>&nbsp;-&nbsp;<code>~/.ssh/config</code></li><li>  <code>tmux</code>&nbsp;-&nbsp;<code>~/.tmux.conf</code></li></ul><p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其&nbsp;<strong>符号链接</strong>&nbsp;到需要的地方。这么做有如下好处：</p><ul><li>  <strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li><li>  <strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li><li>  <strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li><li>  <strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li></ul><p>配置文件中需要放些什么？您可以通过在线文档和<a href="https://en.wikipedia.org/wiki/Man_page">帮助手册</a>了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的<a href="https://github.com/search?o=desc&amp;q=dotfiles&amp;s=stars&amp;type=Repositories">dotfiles 仓库</a>&nbsp;—— 其中最受欢迎的那些可以在<a href="https://github.com/mathiasbynens/dotfiles">这里</a>找到（我们建议您不要直接复制别人的配置）。<a href="https://dotfiles.github.io/">这里</a>&nbsp;也有一些非常有用的资源。</p><p>本课程的老师们也在 GitHub 上开源了他们的配置文件：&nbsp;<a href="https://github.com/anishathalye/dotfiles">Anish</a>,&nbsp;<a href="https://github.com/jonhoo/configs">Jon</a>,&nbsp;<a href="https://github.com/jjgo/dotfiles">Jose</a>.</p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p><p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [[ "$(uname)" == "Linux" ]]; then {do_something}; fi</span><br><span class="line"></span><br><span class="line"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="line">if [[ "$SHELL" == "zsh" ]]; then {do_something}; fi</span><br><span class="line"></span><br><span class="line"># 您也可以针对特定的设备进行配置</span><br><span class="line">if [[ "$(hostname)" == "myServer" ]]; then {do_something}; fi</span><br></pre></td></tr></tbody></table></figure><p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code>&nbsp;可以这样编写：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以在日常使用的设备上创建配置文件&nbsp;<code>~/.gitconfig_local</code>&nbsp;来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p><p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在&nbsp;<code>bash</code>&nbsp;和&nbsp;<code>zsh</code>&nbsp;中同时启用一些别名，您可以把它们写在&nbsp;<code>.aliases</code>&nbsp;里，然后在这两个 shell 里应用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Test if ~/.aliases exists and source it</span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h1 id="远端设备"><a href="#远端设备" class="headerlink" title="远端设备"></a>远端设备</h1><p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p><p>通过如下命令，您可以使用&nbsp;<code>ssh</code>&nbsp;连接到其他服务器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></tbody></table></figure><p>这里我们尝试以用户名&nbsp;<code>foo</code>&nbsp;登录服务器&nbsp;<code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似&nbsp;<code>ssh bar</code>&nbsp;这样的命令来登录服务器。</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p><code>ssh</code>&nbsp;的一个经常被忽视的特性是它可以直接远程执行命令。&nbsp;<code>ssh foobar@server ls</code>&nbsp;可以直接在用foobar的命令下执行&nbsp;<code>ls</code>&nbsp;命令。 想要配合管道来使用也可以，&nbsp;<code>ssh foobar@server ls | grep PATTERN</code>&nbsp;会在本地查询远端&nbsp;<code>ls</code>&nbsp;的输出而&nbsp;<code>ls | ssh foobar@server grep PATTERN</code>&nbsp;会在远端对本地&nbsp;<code>ls</code>&nbsp;输出的结果进行查询。</p><h2 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h2><p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是&nbsp;<code>~/.ssh/id_rsa</code>&nbsp;或者&nbsp;<code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>使用&nbsp;<a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a>&nbsp;命令可以生成一对密钥：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></tbody></table></figure><p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a>&nbsp;或&nbsp;<a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a>&nbsp;，这样就不需要每次都输入该密码了。</p><p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a>&nbsp;介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行&nbsp;<code>ssh-keygen -y -f /path/to/key</code>.</p><h3 id="基于密钥的认证机制"><a href="#基于密钥的认证机制" class="headerlink" title="基于密钥的认证机制"></a>基于密钥的认证机制</h3><p><code>ssh</code>&nbsp;会查询&nbsp;<code>.ssh/authorized_keys</code>&nbsp;来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh/id_ed25519 | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys'</span><br></pre></td></tr></tbody></table></figure><p>如果支持&nbsp;<code>ssh-copy-id</code>&nbsp;的话，可以使用下面这种更简单的解决方案：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></tbody></table></figure><h2 id="通过-SSH-复制文件"><a href="#通过-SSH-复制文件" class="headerlink" title="通过 SSH 复制文件"></a>通过 SSH 复制文件</h2><p>使用 ssh 复制文件有很多方法：</p><ul><li>  <code>ssh+tee</code>, 最简单的方法是执行&nbsp;<code>ssh</code>&nbsp;命令，然后通过这样的方法利用标准输入实现&nbsp;<code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a>&nbsp;命令会将标准输出写入到一个文件；</li><li>  <a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a>&nbsp;：当需要拷贝大量的文件或目录时，使用<code>scp</code>&nbsp;命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li><li>  <a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a>&nbsp;对&nbsp;<code>scp</code>&nbsp;进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于&nbsp;<code>--partial</code>标记实现断点续传。<code>rsync</code>&nbsp;的语法和<code>scp</code>类似；</li></ul><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用&nbsp;<code>localhost:PORT</code>&nbsp;或&nbsp;<code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p><p>此时就需要进行&nbsp;_端口转发_。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p><p><strong>本地端口转发</strong><img src="https://i.stack.imgur.com/a28N8.png%C2%A0" alt="Local Port Forwarding" title="本地端口转发"></p><p><strong>远程端口转发</strong><img src="https://i.stack.imgur.com/4iK3b.png%C2%A0" alt="Remote Port Forwarding" title="远程端口转发"></p><p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听&nbsp;<code>8888</code>&nbsp;端口。 然后，建立从本地端口&nbsp;<code>9999</code>&nbsp;的转发，使用&nbsp;<code>ssh -L 9999:localhost:8888 foobar@remote_server</code>&nbsp;。这样只需要访问本地的&nbsp;<code>localhost:9999</code>&nbsp;即可。</p><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias my_server="ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span><br></pre></td></tr></tbody></table></figure><p>不过，更好的方法是使用&nbsp;<code>~/.ssh/config</code>.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"></span><br><span class="line"># 在配置文件中也可以使用通配符</span><br><span class="line">Host *.mit.edu</span><br><span class="line">    User foobaz</span><br></pre></td></tr></tbody></table></figure><p>这么做的好处是，使用&nbsp;<code>~/.ssh/config</code>&nbsp;文件来创建别名，类似&nbsp;<code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p><p>注意，<code>~/.ssh/config</code>&nbsp;文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p><p>服务器侧的配置通常放在&nbsp;<code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p><p>有时将一个远端文件夹挂载到本地会比较方便，&nbsp;<a href="https://github.com/libfuse/sshfs">sshfs</a>&nbsp;可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p><h1 id="Shell-amp-框架"><a href="#Shell-amp-框架" class="headerlink" title="Shell &amp; 框架"></a>Shell &amp; 框架</h1><p>在 shell 工具和脚本那节课中我们已经介绍了&nbsp;<code>bash</code>&nbsp;shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。</p><p>例如，<code>zsh</code>&nbsp;shell 是&nbsp;<code>bash</code>&nbsp;的超集并提供了一些方便的功能：</p><ul><li>  智能替换,&nbsp;<code>**</code></li><li>  行内替换/通配符扩展</li><li>  拼写纠错</li><li>  更好的 tab 补全和选择</li><li>  路径展开 (<code>cd /u/lo/b</code>&nbsp;会被展开为&nbsp;<code>/usr/local/bin</code>)</li></ul><p><strong>框架</strong>&nbsp;也可以改进您的 shell。比较流行的通用框架包括<a href="https://github.com/sorin-ionescu/prezto">prezto</a>&nbsp;或&nbsp;<a href="https://ohmyz.sh/">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh 语法高亮</a>&nbsp;或&nbsp;<a href="https://github.com/zsh-users/zsh-history-substring-search">zsh 历史子串查询</a>。 像&nbsp;<a href="https://fishshell.com/">fish</a>&nbsp;这样的 shell 包含了很多用户友好的功能，其中一些特性包括：</p><ul><li>  向右对齐</li><li>  命令语法高亮</li><li>  历史子串查询</li><li>  基于手册页面的选项补全</li><li>  更智能的自动补全</li><li>  提示符主题</li></ul><p>需要注意的是，使用这些框架可能会降低您 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p><h1 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h1><p>和自定义 shell 一样，花点时间选择适合您的&nbsp;<strong>终端模拟器</strong>并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间<a href="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">比较</a>的信息）</p><p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p><ul><li>  字体选择</li><li>  彩色主题</li><li>  快捷键</li><li>  标签页/面板支持</li><li>  回退配置</li><li>  性能（像&nbsp;<a href="https://github.com/jwilm/alacritty">Alacritty</a>&nbsp;或者&nbsp;<a href="https://sw.kovidgoyal.net/kitty/">kitty</a>&nbsp;这种比较新的终端，它们支持GPU加速）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。&lt;/p&gt;
&lt;p&gt;我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。&lt;/p&gt;
&lt;p&gt;我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
    <category term="Shell" scheme="https://sajlle.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Vim编辑器使用指南</title>
    <link href="https://sajlle.github.io/2023/04/15/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://sajlle.github.io/2023/04/15/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2023-04-15T14:50:57.000Z</published>
    <updated>2023-04-15T06:58:35.748Z</updated>
    
    <content type="html"><![CDATA[<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的 Word 与 Visual Studio Code）。</p><span id="more"></span><p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p><ul><li>  阅读教程（比如这节课以及我们为您提供的资源）</li><li>  坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li><li>  随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有</li></ul><p>如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如<mark style="background: #FFB8EBA6;">打开和编辑文件、保存与退出、浏览缓冲区</mark>。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p><h1 id="该学哪个编辑器？"><a href="#该学哪个编辑器？" class="headerlink" title="该学哪个编辑器？"></a>该学哪个编辑器？</h1><p>程序员们对自己正在使用的文本编辑器通常有着&nbsp;<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98">非常强的执念</a>。</p><p>现在最流行的编辑器是什么？<a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow 的用户并不能代表所有程序员）显示，<a href="https://code.visualstudio.com/">Visual Studio Code</a>&nbsp;是目前最流行的代码编辑器。而&nbsp;<a href="https://www.vim.org/">Vim</a>&nbsp;则是最流行的基于命令行的编辑器。</p><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976 年的 Vi 编辑器，到现在还在 不断开发中。Vim 有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140 万人安装了&nbsp;<a href="https://github.com/VSCodeVim/Vim">Vim emulation for VS code</a>）。即使你最后使用 其他编辑器，Vim 也值得学习。</p><p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim 的设计哲学，教你基础知识， 并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p><h1 id="Vim-的哲学"><a href="#Vim-的哲学" class="headerlink" title="Vim 的哲学"></a>Vim 的哲学</h1><p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim 是一个_多模态_编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p><p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p><h1 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h1><p>Vim 的设计以大多数时间都花在<mark style="background: #FFB8EBA6;">阅读、浏览和进行少量编辑改动</mark>为基础，因此它具有多种操作模式：</p><ul><li>  <strong>正常模式</strong>：在文件中四处移动光标进行修改</li><li>  <strong>插入模式</strong>：插入文本 （press <code>i</code> to enter , press <code>esc</code> to quit</li><li>  <strong>替换模式</strong>：替换文本 </li><li>  <strong>可视化模式</strong>（一般，行，块）：选中文本块</li><li>  <strong>命令模式</strong>：用于执行命令</li></ul><p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code>&nbsp;在插入模式会插入字母&nbsp;<code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p><p>在默认设置下，Vim 会在左下角显示当前的模式。Vim 启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。</p><p>你可以按下&nbsp;<code>&lt;ESC&gt;</code>（<mark style="background: #FFB8EBA6;">退出键）从任何其他模式返回正常模式</mark>。在正常模式，键入&nbsp;<code>i</code>&nbsp;进入插入 模式，<code>R</code>&nbsp;进入替换模式，<code>v</code>&nbsp;进入可视（一般）模式，<code>V</code>&nbsp;进入可视（行）模式，<code>&lt;C-v&gt;</code>&nbsp;（Ctrl-V, 有时也写作&nbsp;<code>^V</code>）进入可视（块）模式，<code>:</code>&nbsp;进入命令模式。</p><p>因为你会在使用 Vim 时大量使用&nbsp;<code>&lt;ESC&gt;</code>&nbsp;键，所以可以考虑把大小写锁定键重定义成&nbsp;<code>&lt;ESC&gt;</code>&nbsp;键（<a href="https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS">MacOS 教程</a>）。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h2><p>在正常模式，键入&nbsp;<code>i</code>&nbsp;进入插入模式。现在 Vim 跟很多其他的编辑器一样，直到你键入&nbsp;<code>&lt;ESC&gt;</code>&nbsp;返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p><h2 id="缓存，-标签页，-窗口"><a href="#缓存，-标签页，-窗口" class="headerlink" title="缓存， 标签页， 窗口"></a>缓存， 标签页， 窗口</h2><p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在_多个_窗口打开，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用，比如在查看同一个文件的不同部分的时候。</p><p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>在正常模式下键入&nbsp;<code>:</code>&nbsp;进入命令行模式。 在键入&nbsp;<code>:</code>&nbsp;后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能，包括<mark style="background: #FFB8EBA6;">打开，保存，关闭文件</mark>，以及&nbsp;<a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p><ul><li>  <code>:q</code>&nbsp;退出（关闭窗口）</li><li>  <code>:w</code>&nbsp;保存（写）</li><li>  <code>:wq</code>&nbsp;保存然后退出</li><li>  <code>:e {文件名}</code>&nbsp;打开要编辑的文件</li><li>  <code>:ls</code>&nbsp;显示打开的缓存</li><li><code>:help {标题}</code>&nbsp;打开帮助文档<ul><li>  <code>:help :w</code>&nbsp;打开&nbsp;<code>:w</code>&nbsp;命令的帮助文档</li><li>  <code>:help w</code>&nbsp;打开&nbsp;<code>w</code>&nbsp;移动的帮助文档</li></ul></li></ul><h1 id="Vim-的接口其实是一种编程语言"><a href="#Vim-的接口其实是一种编程语言" class="headerlink" title="Vim 的接口其实是一种编程语言"></a>Vim 的接口其实是一种编程语言</h1><p>Vim 最重要的设计思想是 Vim 的界面本身是一个程序语言。键入操作（以及他们的助记名） 本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。</p><ul><li>  基本移动:&nbsp;<code>hjkl</code>&nbsp;（左， 下， 上， 右）</li><li>  词：&nbsp;<code>w</code>&nbsp;（下一个词），&nbsp;<code>b</code>&nbsp;（词初），&nbsp;<code>e</code>&nbsp;（词尾）</li><li>  行：&nbsp;<code>0</code>&nbsp;（行初），&nbsp;<code>^</code>&nbsp;（第一个非空格字符），&nbsp;<code>$</code>&nbsp;（行尾）</li><li>  屏幕：&nbsp;<code>H</code>&nbsp;（屏幕首行），&nbsp;<code>M</code>&nbsp;（屏幕中间），&nbsp;<code>L</code>&nbsp;（屏幕底部）</li><li>  翻页：&nbsp;<code>Ctrl-u</code>&nbsp;（上翻），&nbsp;<code>Ctrl-d</code>&nbsp;（下翻）</li><li>  文件：&nbsp;<code>gg</code>&nbsp;（文件头），&nbsp;<code>G</code>&nbsp;（文件尾）</li><li>  行数：&nbsp;<code>:{行数}&lt;CR&gt;</code>&nbsp;或者&nbsp;<code>{行数}G</code>&nbsp;({行数}为行数)</li><li>  杂项：&nbsp;<code>%</code>&nbsp;（找到配对，比如括号或者 /* */ 之类的注释对）</li><li>查找：&nbsp;<code>f{字符}</code>，&nbsp;<code>t{字符}</code>，&nbsp;<code>F{字符}</code>，&nbsp;<code>T{字符}</code><ul><li>  查找/到 向前/向后 在本行的{字符}</li><li>  <code>,</code>&nbsp;/&nbsp;<code>;</code>&nbsp;用于导航匹配</li></ul></li><li>  搜索:&nbsp;<code>/{正则表达式}</code>,&nbsp;<code>n</code>&nbsp;/&nbsp;<code>N</code>&nbsp;用于导航匹配</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>可视化模式:</p><ul><li>  可视化：<code>v</code></li><li>  可视化行：&nbsp;<code>V</code></li><li>  可视化块：<code>Ctrl+v</code></li></ul><p>可以用移动命令来选中。</p><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p><ul><li><code>i</code>&nbsp;进入插入模式<ul><li>  但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li>  <code>O</code>&nbsp;/&nbsp;<code>o</code>&nbsp;在之上/之下插入行</li><li><code>d{移动命令}</code>&nbsp;删除 {移动命令}<ul><li>  例如，<code>dw</code>&nbsp;删除词,&nbsp;<code>d$</code>&nbsp;删除到行尾,&nbsp;<code>d0</code>&nbsp;删除到行头。</li></ul></li><li><code>c{移动命令}</code>&nbsp;改变 {移动命令}<ul><li>  例如，<code>cw</code>&nbsp;改变词</li><li>  比如&nbsp;<code>d{移动命令}</code>&nbsp;再&nbsp;<code>i</code></li></ul></li><li>  <code>x</code>&nbsp;删除字符（等同于&nbsp;<code>dl</code>）</li><li>  <code>s</code>&nbsp;替换字符（等同于&nbsp;<code>xi</code>）</li><li>可视化模式 + 操作<ul><li>  选中文字,&nbsp;<code>d</code>&nbsp;删除 或者&nbsp;<code>c</code>&nbsp;改变</li></ul></li><li>  <code>u</code>&nbsp;撤销,&nbsp;<code>&lt;C-r&gt;</code>&nbsp;重做</li><li>  <code>y</code>&nbsp;复制 / “yank” （其他一些命令比如&nbsp;<code>d</code>&nbsp;也会复制）</li><li>  <code>p</code>&nbsp;粘贴</li><li>  更多值得学习的: 比如&nbsp;<code>~</code>&nbsp;改变字符的大小写</li></ul><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p><ul><li>  <code>3w</code>&nbsp;向前移动三个词</li><li>  <code>5j</code>&nbsp;向下移动5行</li><li>  <code>7dw</code>&nbsp;删除7个词</li></ul><h2 id="修饰语"><a href="#修饰语" class="headerlink" title="修饰语"></a>修饰语</h2><p>你可以用修饰语改变“名词”的意义。修饰语有&nbsp;<code>i</code>，表示“内部”或者“在内“，和&nbsp;<code>a</code>， 表示”周围“。</p><ul><li>  <code>ci(</code>&nbsp;改变当前括号内的内容</li><li>  <code>ci[</code>&nbsp;改变当前方括号内的内容</li><li>  <code>da'</code>&nbsp;删除一个单引号字符串， 包括周围的单引号</li></ul><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>这里是一个有问题的&nbsp;<a href="https://en.wikipedia.org/wiki/Fizz_buzz">fizz buzz</a>&nbsp;实现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fizz_buzz(limit):</span><br><span class="line">    for i in range(limit):</span><br><span class="line">        if i % 3 == 0:</span><br><span class="line">            print('fizz')</span><br><span class="line">        if i % 5 == 0:</span><br><span class="line">            print('fizz')</span><br><span class="line">        if i % 3 and i % 5:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    fizz_buzz(10)</span><br></pre></td></tr></tbody></table></figure><p>我们会修复以下问题：</p><ul><li>  主函数没有被调用</li><li>  从 0 而不是 1 开始f</li><li>  在 15 的整数倍的时候在不用行打印 “fizz” 和 “buzz”</li><li>  在 5 的整数倍的时候打印 “fizz”</li><li>采用硬编码的参数 10 而不是从命令控制行读取参数</li><li>主函数没有被调用<ul><li>  <code>G</code>&nbsp;文件尾</li><li>  <code>o</code>&nbsp;向下打开一个新行</li><li>  输入 “if&nbsp;<strong>name</strong>&nbsp;…”</li></ul></li><li>从 0 而不是 1 开始<ul><li>  搜索&nbsp;<code>/range</code></li><li>  <code>ww</code>&nbsp;向前移动两个词</li><li>  <code>i</code>&nbsp;插入文字， “1, “</li><li>  <code>ea</code>&nbsp;在 limit 后插入， “+1”</li></ul></li><li>在新的一行 “fizzbuzz”<ul><li>  <code>jj$i</code>&nbsp;插入文字到行尾</li><li>  加入 “, end=’’”</li><li>  <code>jj.</code>&nbsp;重复第二个打印</li><li>  <code>jjo</code>&nbsp;在 if 打开一行</li><li>  加入 “else: print()”</li></ul></li><li>fizz fizz<ul><li>  <code>ci'</code>&nbsp;变到 fizz</li></ul></li><li>命令控制行参数<ul><li>  <code>ggO</code>&nbsp;向上打开</li><li>  “import sys”</li><li>  <code>/10</code></li><li>  <code>ci(</code>&nbsp;to “int(sys.argv[1])”</li></ul></li></ul><p>展示详情请观看课程视频。比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p><h1 id="自定义-Vim"><a href="#自定义-Vim" class="headerlink" title="自定义 Vim"></a>自定义 Vim</h1><p>Vim 由一个位于&nbsp;<code>~/.vimrc</code>&nbsp;的文本配置文件（包含 Vim 脚本命令）。你可能会启用很多基本 设置。</p><p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。&nbsp;<strong>在<a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a>&nbsp;下载我们的设置，然后将它保存成&nbsp;<code>~/.vimrc</code>.</strong></p><p>Vim 能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在 GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>,&nbsp;<a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a>&nbsp;(uses&nbsp;<a href="https://neovim.io/">neovim</a>),&nbsp;<a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它，然后采用对你有用的部分。</p><h1 id="扩展-Vim"><a href="#扩展-Vim" class="headerlink" title="扩展 Vim"></a>扩展 Vim</h1><p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你_不_需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。你可以使用内置的插件管理系统。只需要创建一个&nbsp;<code>~/.vim/pack/vendor/start/</code>&nbsp;的文件夹，然后把插件放到这里（比如通过&nbsp;<code>git clone</code>）。</p><p>以下是一些我们最爱的插件：</p><ul><li>  <a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li><li>  <a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li><li>  <a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li><li>  <a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li></ul><p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>,&nbsp;<a href="https://github.com/jonhoo/configs">Jon</a>,&nbsp;<a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览&nbsp;<a href="https://vimawesome.com/">Vim Awesome</a>&nbsp;来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim plugins”。</p><h1 id="其他程序的-Vim-模式"><a href="#其他程序的-Vim-模式" class="headerlink" title="其他程序的 Vim 模式"></a>其他程序的 Vim 模式</h1><p>很多工具提供了 Vim 模式。这些 Vim 模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim 功能，但是大多数对基本功能支持的很好。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>如果你是一个 Bash 用户，用&nbsp;<code>set -o vi</code>。如果你用 Zsh：<code>bindkey -v</code>。Fish 用&nbsp;<code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以&nbsp;<code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如，<code>git</code>&nbsp;会使用这个编辑器来编辑 commit 信息。</p><h2 id="Readline"><a href="#Readline" class="headerlink" title="Readline"></a>Readline</h2><p>很多程序使用&nbsp;<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a>&nbsp;库来作为 它们的命令控制行界面。Readline 也支持基本的 Vim 模式， 可以通过在&nbsp;<code>~/.inputrc</code>&nbsp;添加如下行开启：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></tbody></table></figure><p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>甚至有 Vim 的网页浏览快捷键&nbsp;<a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的&nbsp;<a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a>&nbsp;和用于 Firefox 的&nbsp;<a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在&nbsp;<a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a>&nbsp;中用 Vim 快捷键。&nbsp;<a href="https://reversed.top/2016-08-13/big-list-of-vim-like-software">这个列表</a>&nbsp;中列举了支持类 vim 键位绑定的软件。</p><h1 id="Vim-进阶"><a href="#Vim-进阶" class="headerlink" title="Vim 进阶"></a>Vim 进阶</h1><p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你 可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p><code>:s</code>&nbsp;（替换）命令（<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p><ul><li><code>%s/foo/bar/g</code><ul><li>  在整个文件中将 foo 全局替换成 bar</li></ul></li><li><code>%s/\[.*\](\(.*\))/\1/g</code><ul><li>  将有命名的 Markdown 链接替换成简单 URLs</li></ul></li></ul><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><ul><li>  用&nbsp;<code>:sp</code>&nbsp;/&nbsp;<code>:vsp</code>&nbsp;来分割窗口</li><li>  同一个缓存可以在多个窗口中显示。</li></ul><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ul><li>  <code>q{字符}</code>&nbsp;来开始在寄存器<code>{字符}</code>中录制宏</li><li>  <code>q</code>停止录制</li><li>  <code>@{字符}</code>&nbsp;重放宏</li><li>  宏的执行遇错误会停止</li><li>  <code>{计数}@{字符}</code>执行一个宏{计数}次</li><li>宏可以递归<ul><li>  首先用<code>q{字符}q</code>清除宏</li><li>  录制该宏，用&nbsp;<code>@{字符}</code>&nbsp;来递归调用该宏 （在录制完成之前不会有任何操作）</li></ul></li><li>例子：将 xml 转成 json (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">file</a>)<ul><li>  一个有 “name” / “email” 键对象的数组</li><li>  用一个 Python 程序？</li><li>用 sed / 正则表达式<ul><li>  <code>g/people/d</code></li><li>  <code>%s/&lt;person&gt;/{/g</code></li><li>  <code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/"name": "\1",/g</code></li><li>  …</li></ul></li><li>Vim 命令 / 宏<ul><li>  <code>Gdd</code>,&nbsp;<code>ggdd</code>&nbsp;删除第一行和最后一行</li><li>格式化最后一个元素的宏 （寄存器&nbsp;<code>e</code>）<ul><li>  跳转到有&nbsp;<code>&lt;name&gt;</code>&nbsp;的行</li><li>  <code>qe^r"f&gt;s": "&lt;ESC&gt;f&lt;C"&lt;ESC&gt;q</code></li></ul></li><li>格式化一个的宏<ul><li>  跳转到有&nbsp;<code>&lt;person&gt;</code>&nbsp;的行</li><li>  <code>qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q</code></li></ul></li><li>格式化一个标签然后转到另外一个的宏<ul><li>  跳转到有&nbsp;<code>&lt;person&gt;</code>&nbsp;的行</li><li>  <code>qq@pjq</code></li></ul></li><li>执行宏到文件尾<ul><li>  <code>999@q</code></li></ul></li><li>  手动移除最后的&nbsp;<code>,</code>&nbsp;然后加上&nbsp;<code>[</code>&nbsp;和&nbsp;<code>]</code>&nbsp;分隔符</li></ul></li></ul></li></ul><h1 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h1><ul><li>  <code>vimtutor</code>&nbsp;是一个 Vim 安装时自带的教程</li><li>  <a href="https://vim-adventures.com/">Vim Adventures</a>&nbsp;是一个学习使用 Vim 的游戏</li><li>  <a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a></li><li>  <a href="https://vimways.org/2019/">Vim Advent Calendar</a>&nbsp;有很多 Vim 小技巧</li><li>  <a href="http://www.vimgolf.com/">Vim Golf</a>&nbsp;是用 Vim 的用户界面作为程序语言的&nbsp;<a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li><li>  <a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a></li><li>  <a href="http://vimcasts.org/">Vim Screencasts</a></li><li>  <a href="https://pragprog.com/titles/dnvim2/">Practical Vim</a>（书籍）</li></ul><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution">习题解答</a></p><ol><li> 完成&nbsp;<code>vimtutor</code>。备注：它在一个&nbsp;<a href="https://en.wikipedia.org/wiki/VT100">80x24</a>（80 列，24 行） 终端窗口看起来效果最好。</li><li> 下载我们提供的&nbsp;<a href="https://missing-semester-cn.github.io/2020/files/vimrc">vimrc</a>，然后把它保存到&nbsp;<code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。</li><li>安装和配置一个插件：&nbsp;<a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>.<ol><li> 用&nbsp;<code>mkdir -p ~/.vim/pack/vendor/start</code>&nbsp;创建插件文件夹</li><li> 下载这个插件：&nbsp;<code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code></li><li> 阅读这个插件的&nbsp;<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件，打开 Vim, 然后用 Vim 命令控制行开始&nbsp;<code>:CtrlP</code>.</li><li> 自定义 CtrlP：添加&nbsp;<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a>&nbsp;到你的&nbsp;<code>~/.vimrc</code>&nbsp;来用按 Ctrl-P 打开 CtrlP</li></ol></li><li> 练习使用 Vim, 在你自己的机器上重做&nbsp;<a href="https://missing-semester-cn.github.io/2020/editors/#demo">演示</a>。</li><li> 下个月用 Vim 完成_所有的_文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”时， 尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题，可以来我们的答疑时间或者给我们发邮件。</li><li> 在其他工具中设置 Vim 快捷键 （见上面的操作指南）。</li><li> 进一步自定义你的&nbsp;<code>~/.vimrc</code>&nbsp;和安装更多插件。</li><li> （高阶）用 Vim 宏将 XML 转换到 JSON (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">例子文件</a>)。 尝试着先完全自己做，但是在你卡住的时候可以查看上面<a href="https://missing-semester-cn.github.io/2020/editors/#macros">宏</a>&nbsp;章节。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的 Word 与 Visual Studio Code）。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
    <category term="Vim" scheme="https://sajlle.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>git基础命令大全</title>
    <link href="https://sajlle.github.io/2023/04/15/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://sajlle.github.io/2023/04/15/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2023-04-15T14:50:26.000Z</published>
    <updated>2023-04-15T07:00:48.934Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读&nbsp;<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>！</p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>  <code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li><li>  <code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为&nbsp;<code>.git</code>&nbsp;的目录下</li><li>  <code>git status</code>: 显示当前的仓库状态</li><li>  <code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li><li><code>git commit</code>: 创建一个新的提交<ul><li>  如何编写&nbsp;<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>  为何要&nbsp;<a href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></li><li>  <code>git log</code>: 显示历史日志</li><li>  <code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li><li>  <code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li><li>  <code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li><li>  <code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</li></ul><h2 id="分支和合并"><a href="#分支和合并" class="headerlink" title="分支和合并"></a>分支和合并</h2><ul><li>  <code>git branch</code>: 显示分支</li><li>  <code>git branch &lt;name&gt;</code>: 创建分支</li><li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支<ul><li>  相当于&nbsp;<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li>  <code>git merge &lt;revision&gt;</code>: 合并到当前分支</li><li>  <code>git mergetool</code>: 使用工具来处理合并冲突</li><li>  <code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li></ul><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><ul><li>  <code>git remote</code>: 列出远端</li><li>  <code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li><li>  <code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li><li>  <code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li><li>  <code>git fetch</code>: 从远端获取对象/索引</li><li>  <code>git pull</code>: 相当于&nbsp;<code>git fetch; git merge</code></li><li>  <code>git clone</code>: 从远端下载仓库</li></ul><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li>  <code>git commit --amend</code>: 编辑提交的内容或信息</li><li>  <code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li><li>  <code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li><li>  <code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作</li></ul><h1 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h1><ul><li>  <code>git config</code>: Git 是一个&nbsp;<a href="https://git-scm.com/docs/git-config">高度可定制的</a>&nbsp;工具</li><li>  <code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li><li>  <code>git add -p</code>: 交互式暂存</li><li>  <code>git rebase -i</code>: 交互式变基</li><li>  <code>git blame</code>: 查看最后修改某行的人</li><li>  <code>git stash</code>: 暂时移除工作目录下的修改内容</li><li>  <code>git bisect</code>: 通过二分查找搜索历史记录</li><li>  <code>.gitignore</code>:&nbsp;<a href="https://git-scm.com/docs/gitignore">指定</a>&nbsp;故意不追踪的文件</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li>  <strong>图形用户界面</strong>: Git 的&nbsp;<a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a>&nbsp;有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li><li>  <strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>,&nbsp;<a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>这样的框架中一般以及集成了这一功能</li><li>  <strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a>&nbsp;是 Vim 中集成 GIt 的常用插件</li><li>  <strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a>&nbsp;<a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a>&nbsp;<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li><li>  <strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中您需要使用一个被称作<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</li><li>  <strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像&nbsp;<a href="https://about.gitlab.com/">GitLab</a>&nbsp;和&nbsp;<a href="https://bitbucket.org/">BitBucket</a>&nbsp;这样的平台。</li></ul><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li>  <a href="https://git-scm.com/book/en/v2">Pro Git</a>&nbsp;，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li><li>  <a href="https://ohshitgit.com/">Oh Shit, Git!?!</a>&nbsp;，简短的介绍了如何从 Git 错误中恢复；</li><li>  <a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a>&nbsp;，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li><li>  <a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li><li>  <a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li><li>  <a href="https://learngitbranching.js.org/">Learn Git Branching</a>&nbsp;通过基于浏览器的游戏来学习 Git ；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;推荐阅读&amp;nbsp;&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot;&gt;Pro Git 中文版&lt;/a&gt;！&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sajlle.github.io/tags/git/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
  </entry>
  
  <entry>
    <title>git原理详解</title>
    <link href="https://sajlle.github.io/2023/04/15/git%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sajlle.github.io/2023/04/15/git%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-15T14:50:00.000Z</published>
    <updated>2023-04-15T06:59:33.899Z</updated>
    
    <content type="html"><![CDATA[<p>版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p><p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p><span id="more"></span><p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p><ul><li>  当前模块是谁编写的？</li><li>  这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li><li>  最近的1000个版本中，何时/为什么导致了单元测试失败？</li></ul><p>尽管版本控制系统有很多， 其事实上的标准则是&nbsp;<strong>Git</strong>&nbsp;。而这篇&nbsp;<a href="https://xkcd.com/1597/">XKCD 漫画</a>&nbsp;则反映出了人们对 Git 的评价：</p><p><img src="https://imgs.xkcd.com/comics/git.png" alt="xkcd 1597"></p><p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p><p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p><h1 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h1><p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = "hello world")</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = "git is wonderful")</span><br></pre></td></tr></tbody></table></figure><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p><h2 id="历史记录建模：关联快照"><a href="#历史记录建模：关联快照" class="headerlink" title="历史记录建模：关联快照"></a>历史记录建模：关联快照</h2><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git 并没有采用这样的模型。</p><p>在 Git 中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p><p>在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></tbody></table></figure><p>上面是一个 ASCII 码构成的简图，其中的&nbsp;<code>o</code>&nbsp;表示一次提交（快照）。</p><p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></tbody></table></figure><p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p><h2 id="数据模型及其伪代码表示"><a href="#数据模型及其伪代码表示" class="headerlink" title="数据模型及其伪代码表示"></a>数据模型及其伪代码表示</h2><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct {</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一种简洁的历史模型。</p><h2 id="对象和内存寻址"><a href="#对象和内存寻址" class="headerlink" title="对象和内存寻址"></a>对象和内存寻址</h2><p>Git 中的对象可以是 blob、树或提交：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></tbody></table></figure><p>Git 在储存数据时，所有的对象都会基于它们的&nbsp;<a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a>&nbsp;进行寻址。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></tbody></table></figure><p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p><p>例如，<a href="https://missing-semester-cn.github.io/2020/version-control/#snapshots">上面</a>例子中的树（可以通过&nbsp;<code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code>&nbsp;来进行可视化），看上去是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></tbody></table></figure><p>树本身会包含一些指向其他内容的指针，例如&nbsp;<code>baz.txt</code>&nbsp;(blob) 和&nbsp;<code>foo</code>&nbsp;(树)。如果我们用&nbsp;<code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></tbody></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p><p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code>&nbsp;引用通常会指向主分支的最新一次提交。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></tbody></table></figure><p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p><p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code>&nbsp;和&nbsp;<code>引用</code>。</p><p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的&nbsp;<code>git</code>&nbsp;命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p><p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交&nbsp;<code>5d83f9e</code>&nbsp;时，有什么命令可以完成该操作（针对这个具体问题，您可以使用&nbsp;<code>git checkout master; git reset --hard 5d83f9e</code>）</p><h1 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h1><p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p><p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p><p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。&lt;/p&gt;
&lt;p&gt;为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sajlle.github.io/tags/git/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
  </entry>
  
  <entry>
    <title>数据抽象</title>
    <link href="https://sajlle.github.io/2023/04/15/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
    <id>https://sajlle.github.io/2023/04/15/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</id>
    <published>2023-04-15T14:41:43.000Z</published>
    <updated>2023-04-15T07:23:26.378Z</updated>
    
    <content type="html"><![CDATA[<p>我们在第一章集中讨论了计算过程和函数在程序设计中的作用。 我们了解了如何使用原始数据(数字)和原始操作(算术)，如何通过组合和控制来形成复合函数，以及如何通过给过程命名来创建函数抽象。 我们还发现，高阶函数增强了语言的能力，使我们能够根据通用的计算方法进行操作，从而进行推理。 这就是编程的精髓所在。</p><p>本章的重点是数据。 我们在这里研究的技术将允许我们表示和操作许多不同领域的信息。 由于互联网的爆炸式增长，我们所有人都可以在网上免费获得大量的结构化信息，计算可以应用于各种各样的不同问题。 有效使用内置和用户定义的数据类型是数据处理应用程序的基础。</p><span id="more"></span><h3 id="2-1-1-原生数据类型"><a href="#2-1-1-原生数据类型" class="headerlink" title="2.1.1 原生数据类型"></a>2.1.1 原生数据类型<a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.1-yin-yan#2.1.1-yuan-sheng-shu-ju-lei-xing"></a></h3><p>Python中的每个值都有一个类来决定它是什么类型的值。共享类的值也共享行为。例如，整数1和2都是int类的实例。这两个值可以进行类似的处理。例如，它们都可以被求反或添加到另一个整数。内置的type函数允许我们检查包含任何值的类。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">2</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>到目前为止，我们使用的值都是Python语言中内置的少数原生数据类型的实例。原生数据类型具有以下属性：</p><ul><li>  1.有些表达式的计算结果是原生类型的值，称为==字面量==。</li><li>  2.有一些内置函数和操作符来操作原生类型的值。</li></ul><p>int类是用来表示整数的原生数据类型。整型字面值(相邻数字序列)计算为整型值，数学运算符操作这些值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12</span> + <span class="number">3000000000000000000000000</span></span><br><span class="line"><span class="number">3000000000000000000000012</span></span><br></pre></td></tr></tbody></table></figure><p>Python包含三种原生数字类型:==整数(int)、浮点数(float)和复数(complex)。==</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1.5</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'float'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>+<span class="number">1j</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'complex'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>浮点数。</strong> float这个名字来自于Python和许多其他编程语言中实数的表示方式:“==浮点”==表示。 虽然数字如何表示的细节不是本文的主题，但了解int和float对象之间的一些高级区别是很重要的。 特别是，==int对象精确地表示整数==，没有任何近似值或对其大小的限制。 另一方面，浮动对象可以表示范围很广的小数，但==并不是所有的数字都可以精确地表示==，==有最小值和最大值==。 因此，浮点数应该被看作是实数的近似值。 这些近似的精确度是有限的。 组合浮点值会导致近似误差; 如果不是为了近似，下面的两个表达式都将计算为7。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> / <span class="number">3</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">3</span> * <span class="number">7</span> * <span class="number">3</span></span><br><span class="line"><span class="number">6.999999999999999</span></span><br></pre></td></tr></tbody></table></figure><p>虽然上面合并了整型值，但一个整型除以另一个整型会得到一个浮点值：两个整型除以的实际比率的截断有限近似值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'float'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="number">0.3333333333333333</span></span><br></pre></td></tr></tbody></table></figure><p>当我们进行等式检验时，这种近似的问题就出现了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span> == <span class="number">0.333333333333333312345</span> <span class="comment"># Beware of float approximation</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>int和float类之间的这些细微差别对编写程序有广泛的影响，因此程序员必须记住这些细节。 幸运的是，只有少数几种本机数据类型，这就限制了精通一门编程语言所需的记忆量。 此外，这些相同的细节在许多编程语言中都是一致的，由<a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754浮点标准</a>等社区指南强制执行。</p><p><strong>非数字类型。</strong> 值可以表示许多其他类型的数据，比如声音、图像、位置、web地址、网络连接等等。 少数是用本地数据类型表示的，例如bool类用于值True和False。 大多数值的类型必须由程序员使用，我们将在本章中开发的组合和抽象方法来定义。</p><p>下面几节将更多地介绍Python的原生数据类型，重点介绍它们在创建有用的数据抽象中所扮演的角色。 对于那些对进一步细节感兴趣的人，在线书籍<a href="http://getpython3.com/diveintopython3/native-datatypes.html">Dive Into Python 3</a>中关于原生数据类型的一章给出了所有Python原生数据类型以及如何操作它们的实用概述，包括大量的使用示例和实用技巧。</p><h3 id="2-2-数据抽象"><a href="#2-2-数据抽象" class="headerlink" title="2.2 数据抽象"></a>2.2 数据抽象</h3><p>当我们考虑世界上我们想要在程序中表示的大量事物时，我们发现它们中的大多数都有复合结构。 例如，地理位置包含纬度和经度坐标。 为了表示位置，我们希望我们的编程语言能够将纬度和经度结合在一起形成一对，这是一个复合数据值，我们的程序可以将其作为单个概念单元进行操作，但它也有两个可以单独考虑的部分。</p><p>==复合数据的使用使我们能够增加程序的模块化==。 如果我们可以将地理位置作为整体值来操作，那么我们就可以将程序中使用位置计算的部分从这些位置如何表示的细节中屏蔽掉。 将处理数据如何表示的程序部分与处理数据如何操作的程序部分隔离开来的通用技术是一种强大的设计方法论，称为数据抽象。 ==数据抽象使程序更容易设计、维护和修改==。</p><p>数据抽象在性质上与功能抽象相似。 当我们创建一个函数抽象时，函数如何实现的细节可以被抑制，并且特定的函数本身可以被具有相同总体行为的任何其他函数所替代。 换句话说，==我们可以进行抽象，将函数的使用方式与函数如何实现的细节分离开来。== 类似地，数据抽象将如何使用复合数据值与如何构造复合数据值的细节分离开来。</p><p>==数据抽象的基本思想是对程序进行结构化==，以便它们能够对抽象数据进行操作。 也就是说，我们的程序应该以这样一种方式使用数据，即尽可能少地对数据做出假设。 同时，一个具体的数据表示被定义为程序的独立部分。</p><p>程序的这两个部分，==操作抽象数据的部分和定义具体表示的部分，由一组根据具体表示实现抽象数据的函数连接起来。== 为了说明这种技术，我们将考虑如何设计一组用于处理有理数的函数。</p><h4 id="2-2-1-示例-有理数"><a href="#2-2-1-示例-有理数" class="headerlink" title="2.2.1 示例:有理数"></a>2.2.1 示例:<a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.1-shi-li-you-li-shu">有理数</a></h4><p>有理数是整数的比率，有理数是实数的一个重要子类。有理数，如1/3或17/29通常写成：<code>&lt;numerator&gt;/&lt;denominator&gt;</code><br>&lt;分子&gt;和&lt;分母&gt;都是整数值的占位符。这两部分都需要准确地描述有理数的值。实际上，整数的除法会产生一个浮点近似值，从而失去整数的精确精度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="number">0.3333333333333333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span> == <span class="number">0.333333333333333300000</span> <span class="comment"># Dividing integers yields an approximation</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>然而，我们可以通过结合分子和分母来创建有理数的精确表示。</p><p>通过使用函数抽象，我们知道，在实现程序的某些部分之前，我们可以开始高效地编程。 让我们先假设我们已经有了一种从分子和分母构造有理数的方法。 我们还假设，给定一个有理数，我们有一种选择其分子和分母成分的方法。 让我们进一步假设构造函数和选择器可以使用以下三个函数：</p><ul><li>  1.rational(n, d)返回分子n、分母d的有理数。</li><li>  2.number (x)返回有理数x的分子。</li><li>3.denom(x)返回有理数x的分母。</li></ul><p>==我们在这里使用的是一个设计程序的强大策略：一厢情愿== 我们还没有阐述一个有理数是如何表示的，或者numer, denom, rational函数是如何实现的。即便如此，如果我们确实定义了这三个函数，我们就可以进行加法、乘法、打印和测试有理数是否相等：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    nx, dx = numer(x), denom(x)</span><br><span class="line">    ny, dy = numer(y), denom(y)</span><br><span class="line">    <span class="keyword">return</span> rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mul_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> rational(numer(x) * numer(y), denom(x) * denom(y))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(numer(x), <span class="string">'/'</span>, denom(x))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rationals_are_equal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> numer(x) * denom(y) == numer(y) * denom(x)</span><br></pre></td></tr></tbody></table></figure><p>现在，我们已经根据选择器函数number和denom以及构造器函数rational定义了有理数的操作，但我们还没有定义这些函数。我们需要的是一种把分子和分母结合成复合值的方法。</p><h4 id="2-2-2-复合结构"><a href="#2-2-2-复合结构" class="headerlink" title="2.2.2 复合结构"></a>2.2.2 <a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.2-dui">复合结构</a></h4><p>为了使我们能够实现数据抽象的具体级别，Python提供了一个称为列表的复合结构，可以通过将表达式放在用逗号分隔的方括号中来构造。这样的表达式称为列表字面量。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = pair</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>访问列表中元素的第二种方法是通过元素选择操作符，也使用方括号表示。与列表文字不同，直接跟在另一个表达式后面的方括号表达式并不求值为列表值，而是从前一个表达式的值中选择元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair[<span class="number">0</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair[<span class="number">1</span>]</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>Python中的列表(以及大多数其他编程语言中的序列)是0索引的，这意味着索引0选择第一个元素，索引1选择第二个元素，以此类推。支持这种索引约定的一种直观感觉是，索引表示元素从列表开始的偏移量。</p><p>元素选择操作符的等效函数称为getitem，它还使用0索引位置从列表中选择元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> getitem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getitem(pair, <span class="number">0</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getitem(pair, <span class="number">1</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>在Python中，双元素列表并不是表示对的唯一方法。将两个值捆绑成一个值的任何方式都可以被认为是一对。列表是一种常见的方法。列表也可以包含两个以上的元素，我们将在本章后面讨论。</p><p><strong>表示有理数。</strong>我们现在可以用一对整数表示一个有理数：一个分子和一个分母。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>): </span><br><span class="line">    <span class="keyword">return</span> [n, d]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">numer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">denom</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><p>再加上我们前面定义的算术运算，我们可以用我们定义的函数来处理有理数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = rational(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(half)</span><br><span class="line"><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>third = rational(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(mul_rationals(half, third))</span><br><span class="line"><span class="number">1</span> / <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(add_rationals(third, third))</span><br><span class="line"><span class="number">6</span> / <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure><p>如上例所示，我们的有理数实现不会将有理数减少到最低项。我们可以通过改变rational的实现来弥补这个缺陷。如果我们有一个计算两个整数的最大公分母的函数，我们可以使用它在构造对之前将分子和分母降为最低项。与许多有用的工具一样，这样的函数已经存在于Python库中。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> gcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>):  </span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> (n//g, d//g)</span><br></pre></td></tr></tbody></table></figure><p>层除法运算符，//表示整数除法，它将除法结果的小数部分舍入。因为我们知道g能将n和d都整除，所以在这种情况下整数除法是正确的。这个修改过的rational实现确保了用最低的术语表达rational。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(add_rationals(third, third))</span><br><span class="line"><span class="number">2</span> / <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>这种改进是通过改变构造函数而不改变任何实现实际算术操作的函数来实现的。</p><h4 id="2-2-3-抽象障碍"><a href="#2-2-3-抽象障碍" class="headerlink" title="2.2.3 抽象障碍"></a>2.2.3 <a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.3-chou-xiang-de-zhang-ai">抽象障碍</a></h4><p>在继续讨论复合数据和数据抽象的更多示例之前，让我们考虑一下有理数示例所提出的一些问题。 我们用构造函数rational和选择器number和denom来定义操作。 一般来说，数据抽象的基本思想是识别一组基本的操作，根据这些操作，某种类型的值的所有操作都将被表示出来，然后在操作数据时只使用这些操作。 通过以这种方式限制操作的使用，在不改变程序行为的情况下更容易改变抽象数据的表示。</p><p>当程序的某个部分可以使用较高级别的函数而不是使用较低级别的函数时，就会发生抽象障碍冲突。例如，一个计算有理数平方的函数最好使用mul_rational来实现，它不假设任何关于有理数实现的事情。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_rational</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> mul_rational(x, x)</span><br></pre></td></tr></tbody></table></figure><p>直接引用分子和分母会违反一个抽象障碍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_rational_violating_once</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> rational(numer(x) * numer(x), denom(x) * denom(x))</span><br></pre></td></tr></tbody></table></figure><p>假设用两元素列表来表示有理数会违反两个抽象障碍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_rational_violating_twice</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> [x[<span class="number">0</span>] * x[<span class="number">0</span>], x[<span class="number">1</span>] * x[<span class="number">1</span>]]</span><br></pre></td></tr></tbody></table></figure><p>抽象障碍使程序更容易维护和修改。 依赖于特定表示的函数越少，当人们想要改变这种表示时，所需要的更改就越少。 square_rational的所有这些实现都有正确的行为，但只有第一个实现对未来的更改是健壮的。 即使我们改变了有理数的表示形式，square_rational函数也不需要更新。 相比之下，square_rational_violating_once在选择器或构造器签名发生更改时需要更改，而square_rational_violating_twice在有理数的实现发生更改时需要更新。</p><h4 id="2-2-4-数据属性"><a href="#2-2-4-数据属性" class="headerlink" title="2.2.4 数据属性"></a>2.2.4 <a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.4-shu-ju-shu-xing">数据属性</a></h4><p>抽象障碍塑造了我们思考数据的方式。 有理数的有效表示不受任何特定实现的限制(如双元素列表); 它是一个由rational返回的值，可以传递给number和denom。 此外，构造函数和选择器之间必须保持适当的关系。 也就是说，如果我们从整数n和d构造一个有理数x，那么number (x)/denom(x)等于n/d。</p><p>一般来说，我们可以使用选择器和构造器的集合，以及一些行为条件来表达抽象数据。 只要满足行为条件(如上面的分割属性)，选择器和构造器就构成了一种数据的有效表示。 抽象障碍下面的实现细节可能会改变，但如果行为没有改变，那么数据抽象仍然有效，使用该数据抽象编写的任何程序都将保持正确。</p><p>这个观点可以广泛地应用，包括我们用来实现有理数的对值。 实际上，我们从未详细说明什么是pair，只是说该语言提供了创建和操作带有两个元素的列表的方法。 我们需要实现pair的行为是将两个值粘合在一起。 作为一种行为条件，</p><ul><li>  如果由值x和y构造一对p，则select(p, 0)返回x, select(p, 1)返回y。</li></ul><p>我们实际上并不需要list类型来创建pair。相反，我们可以实现两个函数pair和select来满足这个描述，就像实现一个两个元素的列表一样。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pair</span>(<span class="params">x, y</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">"""Return a function that represents a pair."""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> get</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">p, i</span>):</span><br><span class="line">    <span class="string">"""Return the element at index i of pair p."""</span></span><br><span class="line">        <span class="keyword">return</span> p(i)</span><br></pre></td></tr></tbody></table></figure><p>通过这个实现，我们可以创建和操作对。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = pair(<span class="number">20</span>, <span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select(p, <span class="number">0</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select(p, <span class="number">1</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></figure><p>这种高阶函数的使用与我们对数据应该是什么的直观概念完全不同。 然而，这些函数足以在程序中表示对。 函数足以表示复合数据。</p><p>展示pair的函数表示的意义并不在于Python实际上是这样工作的(出于效率原因，列表实现得更直接)，而是它可以这样工作。 函数表示虽然晦涩，但却是表示成对的一种完全合适的方式，因为它满足成对需要满足的唯一条件。 数据抽象的实践使我们能够轻松地在表示之间切换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在第一章集中讨论了计算过程和函数在程序设计中的作用。 我们了解了如何使用原始数据(数字)和原始操作(算术)，如何通过组合和控制来形成复合函数，以及如何通过给过程命名来创建函数抽象。 我们还发现，高阶函数增强了语言的能力，使我们能够根据通用的计算方法进行操作，从而进行推理。 这就是编程的精髓所在。&lt;/p&gt;
&lt;p&gt;本章的重点是数据。 我们在这里研究的技术将允许我们表示和操作许多不同领域的信息。 由于互联网的爆炸式增长，我们所有人都可以在网上免费获得大量的结构化信息，计算可以应用于各种各样的不同问题。 有效使用内置和用户定义的数据类型是数据处理应用程序的基础。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>功能抽象</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%8A%9F%E8%83%BD%E6%8A%BD%E8%B1%A1/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%8A%9F%E8%83%BD%E6%8A%BD%E8%B1%A1/</id>
    <published>2023-04-15T14:37:16.000Z</published>
    <updated>2023-04-15T06:38:19.831Z</updated>
    
    <content type="html"><![CDATA[<p>Every powerful language has three such mechanisms:</p><ul><li>  <strong>primitive expressions and statements</strong>, which represent the simplest building blocks that the language provides,</li><li>  <strong>means of combination</strong>, by which compound elements are built from simpler ones, and</li><li>  <strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.<br>data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.</li></ul><span id="more"></span><p>以下指南改编自<a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>，它可作为所有（非叛逆的）Python 程序员的指南。一组共享的约定使开发人员社区成员之间的沟通更加顺畅。作为遵循这些约定的副作用，您会发现您的代码在内部变得更加一致。</p><ol><li> 函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li><li> 函数名称通常会引起解释器应用于参数的操作（例如print、add、square）或产生的数量的名称（例如max、abs、sum）。</li><li> 参数名称是小写的，单词之间用下划线分隔。首选单字名称。</li><li> 参数名称应该唤起参数在函数中的作用，而不仅仅是允许的参数类型。</li><li> 当作用明显时，单字母参数名称是可以接受的，但要避免使用“l”（小写 ell）、“O”（大写 oh）或“I”（大写 i），以免与数字混淆。</li></ol><p>换句话说，函数定义应该能够抑制细节。函数的使用者可能并没有自己编写函数，而是可能作为“黑盒子”从另一个程序员那里得到的。程序员不需要知道函数是如何实现的就可以使用它。Python 库具有此属性。许多开发人员使用那里定义的函数，但很少有人检查他们的实现。</p><p><strong>功能抽象的各个方面</strong><br>要掌握功能抽象的使用，考虑其三个核心属性通常很有用。函数的&nbsp;_域(domain_是它可以接受的参数集。函数的_范围range_是它可以返回的值的集合。函数的_意图intent_是它计算输入和输出之间的关系（以及它可能产生的任何副作用）。通过领域、范围和意图理解功能抽象对于在复杂程序中正确使用它们至关重要。</p><p>例如，我们用来实现sum_squares的任何平方函数 都应该具有以下属性：</p><ul><li>  domain是任何单个实数。</li><li>  range是任何非负实数。</li><li>  intent是输出是输入的平方。</li></ul><p>这些==属性不指定意图是如何执行的==；这个细节被抽象掉了。</p><p>在除法方面，Python 提供了两个中缀运算符：/和&nbsp;//。前者是正常除法，因此即使除数平均除以被除数，它也会产生_浮点数或十进制值：_</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>  /  <span class="number">4</span> </span><br><span class="line"><span class="number">1.25</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span>  /  <span class="number">4</span> </span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></tbody></table></figure><p>另一方面，// 运算符将结果向下舍入为整数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>  //  <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>- <span class="number">5</span>  //  <span class="number">4</span> </span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>这两个运算符是truediv和floordiv&nbsp;函数的简写。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span>  operator  <span class="keyword">import</span>  truediv ,  floordiv </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>truediv ( <span class="number">5</span> ,  <span class="number">4</span> ) </span><br><span class="line"><span class="number">1.25</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floordiv ( <span class="number">5</span> ,  <span class="number">4</span> ) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>您应该在程序中随意使用中缀运算符和圆括号。对于简单的数学运算，惯用的 Python 更喜欢运算符而不是调用表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Every powerful language has three such mechanisms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;primitive expressions and statements&lt;/strong&gt;, which represent the simplest building blocks that the language provides,&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;means of combination&lt;/strong&gt;, by which compound elements are built from simpler ones, and&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;means of abstraction&lt;/strong&gt;, by which compound elements can be named and manipulated as units.&lt;br&gt;data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>链表初探</title>
    <link href="https://sajlle.github.io/2023/04/15/%E9%93%BE%E8%A1%A8%E5%88%9D%E6%8E%A2/"/>
    <id>https://sajlle.github.io/2023/04/15/%E9%93%BE%E8%A1%A8%E5%88%9D%E6%8E%A2/</id>
    <published>2023-04-15T14:34:11.000Z</published>
    <updated>2023-04-15T06:35:50.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表操作类型"><a href="#链表操作类型" class="headerlink" title="链表操作类型"></a>链表操作类型</h1><ul><li>添加第n个节点</li><li>删除第n个节点</li><li>删除头部节点</li><li>删除尾部节点</li><li>插入头部节点</li><li>插入尾部节点<span id="more"></span></li></ul><h1 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h1><h2 id="Linked-Lists"><a href="#Linked-Lists" class="headerlink" title="Linked Lists"></a>Linked Lists</h2><p>We’ve learned that a Python list is one way to store sequential values. Another type of list is a linked list. A Python list stores all of its elements in a single object, and each element can be accessed by using its index. A linked list, on the other hand, is a recursive object that only stores two things: its first value and a reference to the rest of the list, which is another linked list.</p><p>We can implement a class,&nbsp;<code>Link</code>, that represents a linked list object. Each instance of&nbsp;<code>Link</code>&nbsp;has two instance attributes,&nbsp;<code>first</code>&nbsp;and&nbsp;<code>rest</code>.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Link:</span><br><span class="line">    """A linked list.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; s = Link(1)</span><br><span class="line">    &gt;&gt;&gt; s.first</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; s.rest is Link.empty</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))</span><br><span class="line">    &gt;&gt;&gt; s.first = 5</span><br><span class="line">    &gt;&gt;&gt; s.rest.first = 6</span><br><span class="line">    &gt;&gt;&gt; s.rest.rest = Link.empty</span><br><span class="line">    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)</span><br><span class="line">    Link(5, Link(6))</span><br><span class="line">    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))</span><br><span class="line">    &gt;&gt;&gt; s</span><br><span class="line">    Link(5, Link(7, Link(Link(8, Link(9)))))</span><br><span class="line">    &gt;&gt;&gt; print(s)                             # Prints str(s)</span><br><span class="line">    &lt;5 7 &lt;8 9&gt;&gt;</span><br><span class="line">    """</span><br><span class="line">    empty = ()</span><br><span class="line"></span><br><span class="line">    def __init__(self, first, rest=empty):</span><br><span class="line">        assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">        self.first = first</span><br><span class="line">        self.rest = rest</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        if self.rest is not Link.empty:</span><br><span class="line">            rest_repr = ', ' + repr(self.rest)</span><br><span class="line">        else:</span><br><span class="line">            rest_repr = ''</span><br><span class="line">        return 'Link(' + repr(self.first) + rest_repr + ')'</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        string = '&lt;'</span><br><span class="line">        while self.rest is not Link.empty:</span><br><span class="line">            string += str(self.first) + ' '</span><br><span class="line">            self = self.rest</span><br><span class="line">        return string + str(self.first) + '&gt;'</span><br></pre></td></tr></tbody></table></figure><p>A valid linked list can be one of the following:</p><ol><li> An empty linked list (<code>Link.empty</code>)</li><li> A&nbsp;<code>Link</code>&nbsp;object containing the first value of the linked list and a reference to the rest of the linked list</li></ol><p>What makes a linked list recursive is that the&nbsp;<code>rest</code>&nbsp;attribute of a single&nbsp;<code>Link</code>&nbsp;instance is another linked list! In the big picture, each&nbsp;<code>Link</code>&nbsp;instance stores a single value of the list. When multiple&nbsp;<code>Link</code>s are linked together through each instance’s&nbsp;<code>rest</code>&nbsp;attribute, an entire sequence is formed.</p><blockquote><p><em>Note</em>: This definition means that the&nbsp;<code>rest</code>&nbsp;attribute of any&nbsp;<code>Link</code>&nbsp;instance&nbsp;<em>must</em>&nbsp;be either&nbsp;<code>Link.empty</code>&nbsp;or another&nbsp;<code>Link</code>&nbsp;instance! This is enforced in&nbsp;<code>Link.__init__</code>, which raises an&nbsp;<code>AssertionError</code>&nbsp;if the value passed in for&nbsp;<code>rest</code>&nbsp;is neither of these things.</p></blockquote><p>To check if a linked list is empty, compare it against the class attribute&nbsp;<code>Link.empty</code>. For example, the function below prints out whether or not the link it is handed is empty:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_empty(link):</span><br><span class="line">    if link is Link.empty:</span><br><span class="line">        print('This linked list is empty!')</span><br><span class="line">    else:</span><br><span class="line">        print('This linked list is not empty!')</span><br></pre></td></tr></tbody></table></figure><h1 id="链表题目"><a href="#链表题目" class="headerlink" title="链表题目"></a>链表题目</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store_digits</span>(<span class="params">n</span>): </span><br><span class="line"><span class="string">"""Stores the digits of a positive number n in a linked list. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s = store_digits(1) </span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s </span></span><br><span class="line"><span class="string">Link(1) </span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>store_digits(2345) </span></span><br><span class="line"><span class="string">Link(2, Link(3, Link(4, Link(5)))) </span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>store_digits(876) </span></span><br><span class="line"><span class="string">Link(8, Link(7, Link(6)))</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line">res = Link.empty</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">res = Link(n%<span class="number">10</span>,res)</span><br><span class="line">n = n//<span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h3 id="Q2-Convert-Link"><a href="#Q2-Convert-Link" class="headerlink" title="Q2: Convert Link"></a>Q2: Convert Link</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_link</span>(<span class="params">link</span>):</span><br><span class="line">    <span class="string">"""Takes a linked list and returns a Python list with the same elements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; link = Link(1, Link(2, Link(3, Link(4))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; convert_link(link)</span></span><br><span class="line"><span class="string">    [1, 2, 3, 4]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; convert_link(Link.empty)</span></span><br><span class="line"><span class="string">    []</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">while</span> link != Link.empty:</span><br><span class="line">    s.append(link.first)</span><br><span class="line">    link = link.rest</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Q3-Every-Other"><a href="#Q3-Every-Other" class="headerlink" title="Q3: Every Other"></a>Q3: Every Other</h3><p>Implement&nbsp;<code>every_other</code>, which takes a linked list&nbsp;<code>s</code>. It mutates&nbsp;<code>s</code>&nbsp;such that all of the odd-indexed elements (using 0-based indexing) are removed from the list. For example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="string">'a'</span>, Link(<span class="string">'b'</span>, Link(<span class="string">'c'</span>, Link(<span class="string">'d'</span>))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>every_other(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.first</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest.first</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest.rest <span class="keyword">is</span> Link.empty</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>If&nbsp;<code>s</code>&nbsp;contains fewer than two elements,&nbsp;<code>s</code>&nbsp;remains unchanged.<br>Do not return anything!&nbsp;<code>every_other</code>&nbsp;should mutate the original list.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">every_other</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""Mutates a linked list so that all the odd-indiced elements are removed</span></span><br><span class="line"><span class="string">    (using 0-based indexing).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link(4))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; every_other(s)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Link(1, Link(3))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; odd_length = Link(5, Link(3, Link(1)))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; every_other(odd_length)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; odd_length</span></span><br><span class="line"><span class="string">    Link(5, Link(1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; singleton = Link(4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; every_other(singleton)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; singleton</span></span><br><span class="line"><span class="string">    Link(4)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">is</span> Link.empty <span class="keyword">or</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">s.rest = s.rest.rest</span><br><span class="line">every_other(s.rest)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;链表操作类型&quot;&gt;&lt;a href=&quot;#链表操作类型&quot; class=&quot;headerlink&quot; title=&quot;链表操作类型&quot;&gt;&lt;/a&gt;链表操作类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;添加第n个节点&lt;/li&gt;
&lt;li&gt;删除第n个节点&lt;/li&gt;
&lt;li&gt;删除头部节点&lt;/li&gt;
&lt;li&gt;删除尾部节点&lt;/li&gt;
&lt;li&gt;插入头部节点&lt;/li&gt;
&lt;li&gt;插入尾部节点&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构" scheme="https://sajlle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://sajlle.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
