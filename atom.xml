<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alicia&#39;s Blog</title>
  
  <subtitle>a way to get closer to technique</subtitle>
  <link href="https://sajlle.github.io/atom.xml" rel="self"/>
  
  <link href="https://sajlle.github.io/"/>
  <updated>2023-04-19T07:50:01.046Z</updated>
  <id>https://sajlle.github.io/</id>
  
  <author>
    <name>Alicia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>express的安装与使用</title>
    <link href="https://sajlle.github.io/2023/04/19/express%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://sajlle.github.io/2023/04/19/express%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-19T15:48:20.000Z</published>
    <updated>2023-04-19T07:50:01.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-简介"><a href="#Express-简介" class="headerlink" title="Express 简介"></a>Express 简介</h2><p>Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</p><span id="more"></span><p>对于前端程序员来说，最常见的两种服务器，分别是： </p><ul><li>Web 网站服务器：专门对外提供 Web 网页资源的服务器。 </li><li>API 接口服务器：专门对外提供 API 接口的服务器。 使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器</li></ul><h3 id="express基本使用"><a href="#express基本使用" class="headerlink" title="express基本使用"></a>express基本使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在当前目录下运行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express@版本号</span><br></pre></td></tr></tbody></table></figure><h4 id="创建基本的web服务器"><a href="#创建基本的web服务器" class="headerlink" title="创建基本的web服务器"></a>创建基本的web服务器</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>) <span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>() <span class="comment">// 创建web服务器</span></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'express server is running at https://127.0.0.1'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="监听get请求"><a href="#监听get请求" class="headerlink" title="监听get请求"></a>监听get请求</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'请求url'</span>,<span class="keyword">function</span>(<span class="params">req,res</span>){</span><br><span class="line"><span class="comment">// 请求的处理函数</span></span><br><span class="line"><span class="comment">// req 请求对象</span></span><br><span class="line"><span class="comment">// res 响应对象</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="监听post请求"><a href="#监听post请求" class="headerlink" title="监听post请求"></a>监听post请求</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">'请求url'</span>,<span class="keyword">function</span>(<span class="params">req,res</span>){</span><br><span class="line"><span class="comment">// 请求的处理函数</span></span><br><span class="line"><span class="comment">// req 请求对象</span></span><br><span class="line"><span class="comment">// res 响应对象</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="响应内容到客户端"><a href="#响应内容到客户端" class="headerlink" title="响应内容到客户端"></a>响应内容到客户端</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user'</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>({<span class="attr">name</span>: <span class="string">"Alicia"</span>})</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/user'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'请求成功'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="获取url中携带的查询参数"><a href="#获取url中携带的查询参数" class="headerlink" title="获取url中携带的查询参数"></a>获取url中携带的查询参数</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>)</span><br><span class="line"><span class="comment">// req.query 默认是空对象</span></span><br><span class="line"><span class="comment">// 客户端使用 ?name=Alicia的形式发送的参数，会被req.query访问到</span></span><br><span class="line"><span class="comment">// req.query.name = 'Alicia'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="获取url中动态参数"><a href="#获取url中动态参数" class="headerlink" title="获取url中动态参数"></a>获取url中动态参数</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user/:id'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="comment">// 可通过 :参数名 的形式，匹配动态参数值</span></span><br><span class="line"><span class="comment">// req.params默认是一个空对象，存放通过:匹配到的参数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><h4 id="express-static"><a href="#express-static" class="headerlink" title="express.static()"></a><code>express.static()</code></h4><p>express 提供了一个非常好用的函数，叫做 <code>express.static()</code>，通过它，我们可以非常方便地创建一个静态资源服务器， 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">'public'</span>))</span><br></pre></td></tr></tbody></table></figure><p>现在，你就可以访问 public 目录中的所有文件了：<br><a href="http://localhost:3000/images/bg.jpg">http://localhost:3000/images/bg.jpg</a><br><a href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a><br><a href="http://localhost:3000/js/login.js">http://localhost:3000/js/login.js</a></p><p>注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。 因此，<mark style="background: #FF5582A6;">存放静态文件的目录名不会出现在 URL 中。</mark></p><h4 id="托管多个静态资源目录"><a href="#托管多个静态资源目录" class="headerlink" title="托管多个静态资源目录"></a>托管多个静态资源目录</h4><p>如果要托管多个静态资源目录，请多次调用 express.static() 函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">'public'</span>))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">'files'</span>))</span><br></pre></td></tr></tbody></table></figure><p>访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。</p><h4 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h4><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">'/public'</span>,express.<span class="title function_">static</span>(<span class="string">'public'</span>))</span><br></pre></td></tr></tbody></table></figure><p>现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：<br><a href="http://localhost:3000/public/images/kitten.jpg">http://localhost:3000/public/images/kitten.jpg</a><br><a href="http://localhost:3000/public/css/style.css">http://localhost:3000/public/css/style.css</a><br><a href="http://localhost:3000/public/js/app.js">http://localhost:3000/public/js/app.js</a></p><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><h4 id="为什么要使用-nodemon"><a href="#为什么要使用-nodemon" class="headerlink" title="为什么要使用 nodemon"></a>为什么要使用 nodemon</h4><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。 现在，我们可以使用 <a href="https://www.npmjs.com/package/nodemon">nodemon</a> 这个工具，它能够监听项目文件 的变动，当代码被修改后，nodemon 会<mark style="background: #FF5582A6;">自动帮我们重启项目</mark>，极大方便了开发和调试</p><h4 id="安装-nodemon"><a href="#安装-nodemon" class="headerlink" title="安装 nodemon"></a>安装 nodemon</h4><p>在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-nodemon"><a href="#使用-nodemon" class="headerlink" title="使用 nodemon"></a>使用 nodemon</h4><p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 <code>node app.js</code> 命令，来启动项目。这样做的坏处是： 代码被修改之后，需要手动重启项目。 现在，我们可以将 <code>node</code> 命令替换为 <code>nodemon</code> 命令，使用 <code>nodemon app.js</code> 来启动项目。这样做的好处是：代码 被修改之后，会被 <code>nodemon</code> 监听到，从而实现自动重启项目的效果。</p><h2 id="express-路由"><a href="#express-路由" class="headerlink" title="express 路由"></a>express 路由</h2><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><p>广义上来讲，路由就是映射关系</p><h4 id="express中的路由"><a href="#express中的路由" class="headerlink" title="express中的路由"></a>express中的路由</h4><p>在 Express 中，路由指的是<mark style="background: #FF5582A6;">客户端的请求与服务器处理函数之间的映射关系</mark>。 Express 中的路由分 3 部分组成，分别是<mark style="background: #ABF7F7A6;">请求的类型、请求的 URL 地址、处理函数</mark>，格式如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>,<span class="variable constant_">HANDLER</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="Express-中的路由的例子"><a href="#Express-中的路由的例子" class="headerlink" title="Express 中的路由的例子"></a>Express 中的路由的例子</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'hello world'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'get a post request'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h4><p>每当一个请求到达服务器之后，<mark style="background: #FF5582A6;">需要先经过路由的匹配</mark>，只有匹配成功之后，才会调用对应的处理函数。 在匹配时，会按照路由的顺序进行匹配，如果<mark style="background: #FF5582A6;">请求类型和请求的 URL </mark>同时匹配成功，则 Express 会将这次请求，转 交给对应的 function 函数进行处理。<br>![[Pasted image 20230419143558.png]]</p><p>路由匹配的注意点： </p><ul><li> 按照定义的先后顺序进行匹配 </li><li> 请求类型和请求的URL同时匹配成功， 才会调用对应的处理函数</li></ul><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'hello world'</span>)})</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'post request'</span>)})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>{<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'server is running at http://127.0.0.1'</span>)})</span><br></pre></td></tr></tbody></table></figure><h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h4><p>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： </p><ul><li>创建路由模块对应的 .js 文件 </li><li>调用 express.Router() 函数创建路由对象 </li><li>向路由对象上挂载具体的路由 </li><li>使用 module.exports 向外共享路由对象 </li><li>使用 app.use() 函数注册路由模块</li></ul><h4 id="创建路由模块"><a href="#创建路由模块" class="headerlink" title="创建路由模块"></a>创建路由模块</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">'/user/list'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'get user list'</span>)</span><br><span class="line">})</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">'/user/add'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">sen</span>(<span class="string">'add new user'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></tbody></table></figure><h4 id="注册路由模块"><a href="#注册路由模块" class="headerlink" title="注册路由模块"></a>注册路由模块</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./router/user.js'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></tbody></table></figure><h4 id="为路由模块添加前缀"><a href="#为路由模块添加前缀" class="headerlink" title="为路由模块添加前缀"></a>为路由模块添加前缀</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./router/user.js'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/api'</span>, userRouter)</span><br></pre></td></tr></tbody></table></figure><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><h4 id="Express-中间件的格式"><a href="#Express-中间件的格式" class="headerlink" title="Express 中间件的格式"></a>Express 中间件的格式</h4><p>Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：<br>![[Pasted image 20230419144637.png]]<br>注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。</p><h4 id="next-函数的作用"><a href="#next-函数的作用" class="headerlink" title="next 函数的作用"></a>next 函数的作用</h4><p>next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。<br>![[Pasted image 20230419144730.png]]</p><h3 id="Express-中间件的初体验"><a href="#Express-中间件的初体验" class="headerlink" title="Express 中间件的初体验"></a>Express 中间件的初体验</h3><h4 id="定义中间件函数"><a href="#定义中间件函数" class="headerlink" title="定义中间件函数"></a>定义中间件函数</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mw</span> = (<span class="params">req,res,next</span>)=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'这是一个中间件'</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：当前业务处理完毕之后，必须调用<code>next</code>函数，把流转关系交给下个路由</p><h4 id="全局生效的中间件"><a href="#全局生效的中间件" class="headerlink" title="全局生效的中间件"></a>全局生效的中间件</h4><p>客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。 通过调用 <code>app.use(中间件函数)</code>，即可定义一个全局生效的中间件，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mw</span> = (<span class="params">req,res,next</span>)=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(mw)</span><br></pre></td></tr></tbody></table></figure><h4 id="定义全局中间件的简化形式"><a href="#定义全局中间件的简化形式" class="headerlink" title="定义全局中间件的简化形式"></a>定义全局中间件的简化形式</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h4><p>多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 <code>req</code> 或 <code>res</code> 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。<br>![[Pasted image 20230419145411.png]]</p><h4 id="定义多个全局中间件"><a href="#定义多个全局中间件" class="headerlink" title="定义多个全局中间件"></a>定义多个全局中间件</h4><p>可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行 调用，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是第一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是第二个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user'</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'Home Page'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="局部生效的中间件"><a href="#局部生效的中间件" class="headerlink" title="局部生效的中间件"></a>局部生效的中间件</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mw</span> = (<span class="params">req,res,next</span>)=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"这是一个中间件"</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,mw, <span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'home page'</span>)</span><br><span class="line">}) <span class="comment">// mw仅仅在当前路由生效</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/user'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'home page'</span>)</span><br><span class="line">}) <span class="comment">// mw不生效</span></span><br></pre></td></tr></tbody></table></figure><h4 id="定义多个局部中间件"><a href="#定义多个局部中间件" class="headerlink" title="定义多个局部中间件"></a>定义多个局部中间件</h4><p>可以在路由中，通过如下两种等价的方式，使用多个局部中间件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,mw1,mw2,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'home page'</span>)})</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,[mw1,mw2],<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'home page'</span>)})</span><br></pre></td></tr></tbody></table></figure><h4 id="了解中间件的5个使用注意事项"><a href="#了解中间件的5个使用注意事项" class="headerlink" title="了解中间件的5个使用注意事项"></a>了解中间件的5个使用注意事项</h4><ul><li>一定要在路由之前注册中间件</li><li>客户端发送过来的请求，可以连续调用多个中间件进行处理 </li><li>执行完中间件的业务代码之后，不要忘记调用 next() 函数</li><li>为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</li></ul><h4 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h4><p>为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是： </p><ul><li>应用级别的中间件 </li><li>路由级别的中间件 </li><li>错误级别的中间件 </li><li>Express 内置的中间件</li><li>第三方的中间件</li></ul><h5 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h5><p>通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{<span class="title function_">next</span>()})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,mw1,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{res.<span class="title function_">send</span>(<span class="string">'home page'</span>)})</span><br></pre></td></tr></tbody></table></figure><h5 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h5><p>绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不 过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'time:'</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/'</span>,router)</span><br></pre></td></tr></tbody></table></figure><h5 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h5><p>错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 <code>(err, req, res, next)</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'服务器内部发生错误'</span>)</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'home page'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>)=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'发生了错误：'</span>+err.<span class="property">messege</span>)</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">'Error'</span>+err.<span class="property">messege</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>注意：错误级别的中间件， 必须注册在所有路由之后！</p><h4 id="Express内置的中间件"><a href="#Express内置的中间件" class="headerlink" title="Express内置的中间件"></a>Express内置的中间件</h4><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验： </p><ul><li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） </li><li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>({<span class="attr">extended</span>: <span class="literal">false</span>}))</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="第三方的中间件"><a href="#第三方的中间件" class="headerlink" title="第三方的中间件"></a>第三方的中间件</h4><p>非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置 第三方中间件，从而提高项目的开发效率。 例如：在 <a href="mailto:express@4.16.0">express@4.16.0</a> 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步 骤如下：</p><ul><li>运行 npm install body-parser 安装中间件 </li><li>使用 require 导入中间件</li><li>调用 app.use() 注册并使用中间件</li></ul><p>注意：Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。</p><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><h4 id="需求描述与实现步骤"><a href="#需求描述与实现步骤" class="headerlink" title="需求描述与实现步骤"></a>需求描述与实现步骤</h4><p>自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。</p><p>实现步骤：</p><ul><li>定义中间件 </li><li>监听 <code>req</code> 的 <code>data</code> 事件 </li><li>监听 <code>req</code> 的 <code>end</code> 事件 </li><li>使用 <code>querystring</code> 模块解析请求体数据 </li><li>将解析出来的数据对象挂载为 <code>req.body</code> </li><li>将自定义中间件封装为模块</li></ul><h4 id="自定义中间件-1"><a href="#自定义中间件-1" class="headerlink" title="自定义中间件"></a>自定义中间件</h4><p>使用 app.use() 来定义全局生效的中间件，代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>{</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="监听-req-的-data-事件"><a href="#监听-req-的-data-事件" class="headerlink" title="监听 req 的 data 事件"></a>监听 req 的 data 事件</h4><p>在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。 如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触 发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">'data'</span>,chunk)=&gt;{</span><br><span class="line">str += chunk</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="监听-req-的-end-事件"><a href="#监听-req-的-end-事件" class="headerlink" title="监听 req 的 end 事件"></a>监听 req 的 end 事件</h4><p>当请求体数据接收完毕之后，会自动触发 req 的 end 事件。 因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">'end'</span>,<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-querystring-模块解析请求体数据"><a href="#使用-querystring-模块解析请求体数据" class="headerlink" title="使用 querystring 模块解析请求体数据"></a>使用 querystring 模块解析请求体数据</h4><p>Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把 查询字符串，解析成对象的格式。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"><span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br></pre></td></tr></tbody></table></figure><h4 id="将解析出来的数据对象挂载为-req-body"><a href="#将解析出来的数据对象挂载为-req-body" class="headerlink" title="将解析出来的数据对象挂载为 req.body"></a>将解析出来的数据对象挂载为 req.body</h4><p>上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">'end'</span>,<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br><span class="line">req.<span class="property">body</span> = body</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="将自定义中间件封装为模块"><a href="#将自定义中间件封装为模块" class="headerlink" title="将自定义中间件封装为模块"></a>将自定义中间件封装为模块</h4><p>为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bodyParser</span>(<span class="params">req,res,next</span>){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = bodyParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBodyParser = <span class="built_in">require</span>(<span class="string">'custom-body-parser'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myBodyParser)</span><br></pre></td></tr></tbody></table></figure><h2 id="使用-Express-写接口"><a href="#使用-Express-写接口" class="headerlink" title="使用 Express 写接口"></a>使用 Express 写接口</h2><h3 id="创建基本的服务器"><a href="#创建基本的服务器" class="headerlink" title="创建基本的服务器"></a>创建基本的服务器</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,(=&gt;{</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'express server running at http://127.0.0.1'</span>)</span><br><span class="line">}))</span><br></pre></td></tr></tbody></table></figure><h3 id="创建-API-路由模块"><a href="#创建-API-路由模块" class="headerlink" title="创建 API 路由模块"></a>创建 API 路由模块</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> apiRouter = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = apiRouter</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">'./apiRouter.js'</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/api'</span>,apiRouter)</span><br></pre></td></tr></tbody></table></figure><h3 id="编写-GET-接口"><a href="#编写-GET-接口" class="headerlink" title="编写 GET 接口"></a>编写 GET 接口</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">get</span>(<span class="string">'/get'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> query = req.<span class="property">query</span></span><br><span class="line">res.<span class="title function_">send</span>({</span><br><span class="line"><span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">msg</span>: <span class="string">'GET请求成功'</span>,</span><br><span class="line"><span class="attr">data</span>: query</span><br><span class="line">})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="编写-POST-接口"><a href="#编写-POST-接口" class="headerlink" title="编写 POST 接口"></a>编写 POST 接口</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">post</span>(<span class="string">'/get'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{</span><br><span class="line"><span class="keyword">const</span> query = req.<span class="property">query</span></span><br><span class="line">res.<span class="title function_">send</span>({</span><br><span class="line"><span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">msg</span>: <span class="string">'Post请求成功'</span>,</span><br><span class="line"><span class="attr">data</span>: query</span><br><span class="line">})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>注意：如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 <code>app.use(express.urlencoded({ extended: false }))</code></p><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><h4 id="接口的跨域问题"><a href="#接口的跨域问题" class="headerlink" title="接口的跨域问题"></a>接口的跨域问题</h4><p>刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。<br>解决接口跨域问题的方案主要有两种： </p><ul><li>CORS（主流的解决方案，推荐使用） </li><li>JSONP（有缺陷的解决方案：只支持 GET 请求）</li></ul><h4 id="使用-cors-中间件解决跨域问题"><a href="#使用-cors-中间件解决跨域问题" class="headerlink" title="使用 cors 中间件解决跨域问题"></a>使用 cors 中间件解决跨域问题</h4><p>cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。 使用步骤分为如下 3 步： </p><ul><li>运行 <code>npm install cors</code> 安装中间件 </li><li>使用 <code>const cors = require('cors')</code> 导入中间件 </li><li>在路由之前调用 <code>app.use(cors())</code> 配置中间件</li></ul><h4 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h4><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定 浏览器是否阻止前端 JS 代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头， 就可以解除浏览器端的跨域访问限制。<br>![[Pasted image 20230419152810.png]]</p><h4 id="Cors注意事项"><a href="#Cors注意事项" class="headerlink" title="Cors注意事项"></a>Cors注意事项</h4><ul><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 <code>XMLHttpRequest Level2</code> 的浏览器，才能正常访问开启了 CORS 的服 务端接口（例如：IE10+、Chrome4+、FireFox3.5+）</li></ul><h4 id="CORS-响应头部-Access-Control-Allow-Origin"><a href="#CORS-响应头部-Access-Control-Allow-Origin" class="headerlink" title="CORS 响应头部 - Access-Control-Allow-Origin"></a>CORS 响应头部 - Access-Control-Allow-Origin</h4><p>响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></tbody></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URL。 例如，下面的字段值将只允许来自 <a href="http://itcast.cn/">http://itcast.cn</a> 的请求：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Origin'</span>, url)</span><br></pre></td></tr></tbody></table></figure><p>如果指定了 Access-Control-Allow-Origin 字段的值为通配符 <code>*</code>，表示允许来自任何域的请求，示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="CORS-响应头部-Access-Control-Allow-Headers"><a href="#CORS-响应头部-Access-Control-Allow-Headers" class="headerlink" title="CORS 响应头部 - Access-Control-Allow-Headers"></a><code>CORS 响应头部 - Access-Control-Allow-Headers</code></h4><p>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头： <code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、 Content-Type</code> （值仅限于 <code>text/plain、multipart/form-data、application/x-www-form-urlencoded</code> 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 <code>Access-Control-Allow-Headers</code> 对额外 的请求头进行声明，否则这次请求会失败。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, X-Custom-Header'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="CORS-响应头部-Access-Control-Allow-Methods"><a href="#CORS-响应头部-Access-Control-Allow-Methods" class="headerlink" title="CORS 响应头部 - Access-Control-Allow-Methods"></a><code>CORS 响应头部 - Access-Control-Allow-Methods</code></h4><p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。 示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'POST, GET, DELETE, HEAD'</span>)</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">'Access-Control-Allow-Methods'</span>,<span class="string">'*'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="CORS请求的分类"><a href="#CORS请求的分类" class="headerlink" title="CORS请求的分类"></a>CORS请求的分类</h4><p>客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是： ① 简单请求 ② 预检请求</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>同时满足以下两大条件的请求，就属于简单请求： ① 请求方式：GET、POST、HEAD 三者之一<br>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、 Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</p><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>只要符合以下任何一个条件的请求，都需要进行预检请求：<br>    ① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型<br>    ② 请求头中包含自定义头部字段<br>    ③ 向服务器发送了 application/json 格式的数据<br>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一 次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><h5 id="简单请求和预检请求的区别"><a href="#简单请求和预检请求的区别" class="headerlink" title="简单请求和预检请求的区别"></a>简单请求和预检请求的区别</h5><p>简单请求的特点：客户端与服务器之间只会发生一次请求。<br>预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p><h3 id="JSONP-接口"><a href="#JSONP-接口" class="headerlink" title="JSONP 接口"></a>JSONP 接口</h3><p>概念：浏览器端通过<code>&lt;script&gt;</code>标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP。<br>特点：<br>    ① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。<br>    ② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求</p><h4 id="创建-JSONP-接口的注意事项"><a href="#创建-JSONP-接口的注意事项" class="headerlink" title="创建 JSONP 接口的注意事项"></a>创建 JSONP 接口的注意事项</h4><p>如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/jsonp'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{ })</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/get'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{})</span><br></pre></td></tr></tbody></table></figure><h4 id="实现-JSONP-接口的步骤"><a href="#实现-JSONP-接口的步骤" class="headerlink" title="实现 JSONP 接口的步骤"></a>实现 JSONP 接口的步骤</h4><p>① 获取客户端发送过来的回调函数的名字<br>② 得到要通过 JSONP 形式发送给客户端的数据<br>③ 根据前两步得到的数据，拼接出一个函数调用的字符串<br>④ 把上一步拼接得到的字符串，响应给客户端的<code>&lt;script&gt;</code>标签进行解析执行</p><h4 id="实现-JSONP-接口的具体代码"><a href="#实现-JSONP-接口的具体代码" class="headerlink" title="实现 JSONP 接口的具体代码"></a>实现 JSONP 接口的具体代码</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/jsonp'</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>{ </span><br><span class="line"><span class="keyword">const</span> funcName = req.<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line"><span class="keyword">const</span> data = {<span class="attr">name</span>: <span class="string">'Alicia'</span>, <span class="attr">age</span>: <span class="string">'prefer not to say'</span>}</span><br><span class="line"><span class="keyword">const</span> scriptStr = <span class="string">`<span class="subst">${funcName}</span>(<span class="subst">${<span class="built_in">JSON</span>.stringify(data)}</span>)`</span></span><br><span class="line">res.<span class="title function_">send</span>(scriptStr)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="在网页中使用-jQuery-发起-JSONP-请求"><a href="#在网页中使用-jQuery-发起-JSONP-请求" class="headerlink" title="在网页中使用 jQuery 发起 JSONP 请求"></a>在网页中使用 jQuery 发起 JSONP 请求</h4><p>调用 $.ajax() 函数，提供 JSONP 的配置选项，从而发起 JSONP 请求，示例代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#btnJSONP'</span>).<span class="title function_">on</span>(<span class="string">'click'</span>,<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">$.<span class="title function_">ajax</span>({</span><br><span class="line"><span class="attr">method</span>: <span class="string">'GET'</span>,</span><br><span class="line"><span class="attr">url</span>: <span class="string">'http://127.0.0.1'</span>,</span><br><span class="line"><span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>){</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Express-简介&quot;&gt;&lt;a href=&quot;#Express-简介&quot; class=&quot;headerlink&quot; title=&quot;Express 简介&quot;&gt;&lt;/a&gt;Express 简介&lt;/h2&gt;&lt;p&gt;Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="工具使用" scheme="https://sajlle.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="express" scheme="https://sajlle.github.io/tags/express/"/>
    
    <category term="路由" scheme="https://sajlle.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
    <category term="服务器" scheme="https://sajlle.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>node.js中的模块化</title>
    <link href="https://sajlle.github.io/2023/04/18/node-js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://sajlle.github.io/2023/04/18/node-js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2023-04-17T17:38:24.000Z</published>
    <updated>2023-04-18T02:14:34.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><ul><li>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） </li><li>自定义模块（用户创建的每个 .js 文件，都是自定义模块）</li><li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载<span id="more"></span><h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>) <span class="comment">// 加载内置模块</span></span><br><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">'./custom.js'</span>) <span class="comment">// 加载自定义模块</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>) <span class="comment">// 加载第三方模块</span></span><br></pre></td></tr></tbody></table></figure><h2 id="共享模块成员"><a href="#共享模块成员" class="headerlink" title="共享模块成员"></a>共享模块成员</h2>每个自定义模块中都存储了module对象，其存贮了当前模块的有关信息。<h3 id="module-exports对象"><a href="#module-exports对象" class="headerlink" title="module.exports对象"></a>module.exports对象</h3>自定义模块可通过module.exports对象将模块成员共享出去，供外界使用。<br>使用<code>require()</code>方法导入自定义模块，得到的就是<code>module.exports</code>指向的对象。<br>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。==默认情况 下，exports 和 module.exports 指向同一个对象==。最终共享的结果，还是以<mark style="background: #FF5582A6;"> module.exports </mark>指向的对象为准</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">username</span> = <span class="string">"Lee"</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {username: "Lee", age: 22}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = {</span><br><span class="line"><span class="attr">gender</span>: <span class="string">'female'</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">"Lee"</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {age: 22}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'mylene farmer'</span>,</span><br><span class="line"><span class="attr">gender</span>: <span class="string">'female'</span>,</span><br><span class="line"><span class="attr">career</span>: <span class="string">'singer'</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = <span class="string">'Lee'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {name: 'mylene farmer', gender: 'female', career: 'singer'}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'mylene farmer'</span>,</span><br><span class="line"><span class="attr">gender</span>: <span class="string">'female'</span>,</span><br><span class="line"><span class="attr">career</span>: <span class="string">'singer'</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = <span class="string">'Lee'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'./example.js'</span>)</span><br><span class="line"><span class="comment">// {name: 'mylene farmer', gender: 'female', career: 'singer'}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Node-js中的模块化规范"><a href="#Node-js中的模块化规范" class="headerlink" title="Node.js中的模块化规范"></a>Node.js中的模块化规范</h3><p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。<br>CommonJS 规定：</p><ul><li>每个模块内部，module 变量代表当前模块。</li><li>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 </li><li>加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块</li></ul><h3 id="Node-js中的第三方模块——包"><a href="#Node-js中的第三方模块——包" class="headerlink" title="Node.js中的第三方模块——包"></a>Node.js中的第三方模块——包</h3><h4 id="如何下载包"><a href="#如何下载包" class="headerlink" title="如何下载包"></a>如何下载包</h4><ul><li><a href="https://www.npmjs.com/">npm Inc官网</a> 全球最大的包共享平台，可在此搜索需要的包</li><li><a href="https://registry.npmjs.org/">常用下载地址-来自npm Inc</a> npm Inc提供的共享包的服务器地址，可在此下载需要的包</li><li>查看npm的版本：<code>npm -v</code></li></ul><h4 id="在项目中安装包"><a href="#在项目中安装包" class="headerlink" title="在项目中安装包"></a>在项目中安装包</h4><h5 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h5><p><code>npm install 包名</code>，该命令也可简写为：<code>npm i 包名</code><br>初次安装包之后，多了<code>node_modules</code>文件夹和<code>package-lock.json</code>配置文件</p><ul><li><code>node_modules</code>文件夹：存放已安装到项目中的包<ul><li><code>require()</code>导入第三方包时，就从这个目录中查找并加载包</li></ul></li><li><code>package-lock.json</code>配置文件：记录 <code>node_modules</code> 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。<h5 id="安装指定版本的包"><a href="#安装指定版本的包" class="headerlink" title="安装指定版本的包"></a>安装指定版本的包</h5>默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包 名之后，通过 @ 符号指定具体的版本，例如：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moment@2.22.2</span><br></pre></td></tr></tbody></table></figure><h5 id="包的语义化规范"><a href="#包的语义化规范" class="headerlink" title="包的语义化规范"></a>包的语义化规范</h5>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0 其中每一位数字所代表的的含义如下： </li><li>第1位数字：大版本 </li><li>第2位数字：功能版本 </li><li>第3位数字：Bug修复版本<br>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。</li></ul><h5 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h5><p>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置 信息。例如：</p><ul><li>项目的名称、版本号、描述等 </li><li>项目中都用到了哪些包  </li><li>哪些包只在开发期间会用到 </li><li>哪些包在开发和部署时都需要用到<br>在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。<mark style="background: #ABF7F7A6;">从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码</mark>。</li></ul><p>今后在项目开发中，<mark style="background: #FF5582A6;">一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中</mark>。</p><p>npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理 配置文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在执行命令所处的目录中，快速新建package.json</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></tbody></table></figure><ul><li>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。 </li><li>运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。<h6 id="dependencies-节点"><a href="#dependencies-节点" class="headerlink" title="dependencies 节点"></a>dependencies 节点</h6>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包</li></ul><p>当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。 否则会报类似于下面的错误：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于项目运行依赖该包，如果未提前安装，会报如下错误。</span></span><br><span class="line">Error: Cannot find module <span class="string">'moment'</span></span><br></pre></td></tr></tbody></table></figure><p>可运行如下命令一次安装所有包</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure><p>可运行如下命令卸载指定的包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall moment</span><br></pre></td></tr></tbody></table></figure><h6 id="devDependencies-节点"><a href="#devDependencies-节点" class="headerlink" title="devDependencies 节点"></a>devDependencies 节点</h6><p>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。 与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。</p><p>可以使用如下的命令，将包记录到 devDependencies 节点中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -D <span class="comment">#此是简写形式</span></span><br><span class="line">npm install package --save-Dev</span><br></pre></td></tr></tbody></table></figure><h5 id="解决包下载速度慢的问题"><a href="#解决包下载速度慢的问题" class="headerlink" title="解决包下载速度慢的问题"></a>解决包下载速度慢的问题</h5><ul><li><p>切换下载镜像源头</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前的下包镜像</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment"># 将下包的镜像源切换为淘宝镜像源</span></span><br><span class="line">npm config se registry=https://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 检查镜像源是否下载成功</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>nrm</code>切换镜像源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nrm</span></span><br><span class="line">npm i nrm -g</span><br><span class="line"><span class="comment"># 查看所有可用镜像</span></span><br><span class="line">nrm <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 将镜像切换为淘宝镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h4><p>使用 npm 包管理工具下载的包，共分为两大类，分别是：项目包和全局包</p><h5 id="项目包"><a href="#项目包" class="headerlink" title="项目包"></a>项目包</h5><p>那些被安装到项目的 node_modules 目录中的包，都是项目包。<br>项目包又分为两类，分别是： </p><ul><li>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到） </li><li>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li></ul><h5 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h5><p>在执行 npm install 命令时，如果提供了 <code>-g</code> 参数，则会把包安装为全局包。 全局包会被安装到 <code>C:\Users\用户目录\AppData\Roaming\npm\node_modules</code> 目录下。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i package -g</span><br><span class="line">npm uninstall package -g</span><br></pre></td></tr></tbody></table></figure><ul><li>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 </li><li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</li></ul><h5 id="5ting-toc"><a href="#5ting-toc" class="headerlink" title="5ting_toc"></a>5ting_toc</h5><p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g i5ting_toc</span><br><span class="line">i5ting_toc -f index.md -o</span><br></pre></td></tr></tbody></table></figure><h3 id="包的结构"><a href="#包的结构" class="headerlink" title="包的结构"></a>包的结构</h3><p>一个规范的包，它的组成结构，必须符合以下 3 点要求： ① 包必须以单独的目录而存在 ② 包的顶级目录下要必须包含 package.json 这个包管理配置文件 ③ package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。 注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考<a href="https://yarnpkg.com/zh-Hans/docs/package-json">该网址</a></p><h3 id="开发自己的包"><a href="#开发自己的包" class="headerlink" title="开发自己的包"></a>开发自己的包</h3><ul><li>实现功能</li><li>初始化包的基本结构<ul><li>新建包的根目录</li><li>在根目录下新建三个文件<ul><li><code>package.json</code>管理配置文件</li><li><code>index.js</code>入口文件</li><li><code>README.md</code>说明文档</li></ul></li><li>初始化<code>package.json</code></li><li><code>index.js</code>里写功能，把功能暴露出去</li><li>拆分不同的功能到不同的js文件中</li><li>编写<code>README.md</code>文件，包括安装方式、导入方式，功能介绍，开源协议等。</li></ul></li><li>发布包<ul><li>注册npm账号</li><li>执行<code>npm login</code>命令</li><li>切到包的根目录，运行<code>npm public</code>命令</li></ul></li><li>删除已经发布的包<ul><li>运行<code>npm uninstall package --force</code><ul><li>只能删除72hours之内的包</li><li>24小时内不许重新发布</li></ul></li></ul></li></ul><h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><h3 id="内置模块的加载机制"><a href="#内置模块的加载机制" class="headerlink" title="内置模块的加载机制"></a>内置模块的加载机制</h3><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。 例如，require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p><h3 id="自定义模块的加载机制"><a href="#自定义模块的加载机制" class="headerlink" title="自定义模块的加载机制"></a>自定义模块的加载机制</h3><p>使用 require() 加载自定义模块时，必须指定以 <code>./</code> 或 <code>../</code> 开头的路径标识符。<br>在加载自定义模块时，==如果没有指定 <code>./</code> 或 <code>../</code> 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。==<br>同时，在使用 <code>require()</code> 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p><ul><li>按照确切的文件名进行加载 </li><li> 补全 .js 扩展名进行加载 </li><li> 补全 .json 扩展名进行加载 </li><li> 补全 .node 扩展名进行加载 </li><li> 加载失败，终端报错</li></ul><h3 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h3><p>如果传递给 <code>require()</code> 的模块标识符不是一个内置模块，也没有以 <code>./</code> 或 <code>../</code> 开头，则 Node.js 会从当前模块的父 目录开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</p><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。 </p><p>例如，假设<code>'C:\Users\itheima\project\foo.js</code>‘ 文件里调用了 <code>require('tools')</code>，则 Node.js 会按以下顺序查找： </p><ul><li><code>C:\Users\itheima\project\node_modules\tools</code> </li><li><code>C:\Users\itheima\node_modules\tools</code></li><li><code>C:\Users\node_modules\tools</code></li><li><code>C:\node_modules\tools</code></li></ul><h3 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h3><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：<br>① 在被加载的目录下查找一个叫做 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口<br>② 如果目录里没有 <code>package.json</code> 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。<br>③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：<code>Error: Cannot find module 'xxx'</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;模块分类&quot;&gt;&lt;a href=&quot;#模块分类&quot; class=&quot;headerlink&quot; title=&quot;模块分类&quot;&gt;&lt;/a&gt;模块分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） &lt;/li&gt;
&lt;li&gt;自定义模块（用户创建的每个 .js 文件，都是自定义模块）&lt;/li&gt;
&lt;li&gt;第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Node" scheme="https://sajlle.github.io/tags/Node/"/>
    
    <category term="npm" scheme="https://sajlle.github.io/tags/npm/"/>
    
    <category term="工具使用" scheme="https://sajlle.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>git建仓折腾记</title>
    <link href="https://sajlle.github.io/2023/04/16/git%E5%BB%BA%E4%BB%93%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>https://sajlle.github.io/2023/04/16/git%E5%BB%BA%E4%BB%93%E6%8A%98%E8%85%BE%E8%AE%B0/</id>
    <published>2023-04-15T22:13:43.000Z</published>
    <updated>2023-04-15T14:17:13.598Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚刚注册GitHub账号，想要建仓，遇到了种种神奇的问题，让俺再次对GitHub的复杂提升了认识。<br>遂决定把这次建仓折腾的经过记录下来，以作备用。</p><span id="more"></span><p>注册账号掠过不提，从建仓库说起。</p><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><ul><li>输入<code>git config --global user.name 'yourname'</code>，添加用户名<ul><li><code>yourname</code>是你GitHub账号名称</li></ul></li><li>输入<code>git config --global user.email 'youremail'</code>，添加邮箱<ul><li><code>youremail</code>是GitHub注册的邮箱地址</li></ul></li><li>以上两条命令配置的文件会被写入文件夹下的.gitconfig文件中，该文件是git的全局配置文件。</li><li>如何检查是否配置成功了呢？<ul><li>输入<code>git config user.name</code> ，如果返回<code>yourname</code>，则表示配置成功</li></ul></li></ul><h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><ul><li>打开准备作为git仓库的文件夹，运行git bash</li><li>输入 <code>git init</code> 初始化仓库<ul><li>该命令会创建一个.git的隐藏目录，这个目录里包含了初始文件（很重要，不要随便移除它哦）</li></ul></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="git中的文件有四种状态"><a href="#git中的文件有四种状态" class="headerlink" title="git中的文件有四种状态"></a>git中的文件有四种状态</h4><ul><li>未管理</li><li>已管理<ul><li>未修改</li><li>已修改</li><li>已暂存</li><li>已提交<h4 id="操作未提交的文件"><a href="#操作未提交的文件" class="headerlink" title="操作未提交的文件"></a>操作未提交的文件</h4></li></ul></li><li>使用<code>git status</code>检查文件状态<ul><li>可用<code>git status -s</code>精简输出</li></ul></li><li>使用<code>git add filename</code>开始追踪一个文件</li><li>使用<code>git commit -m "message"</code>提交文件<h4 id="操作已提交的文件"><a href="#操作已提交的文件" class="headerlink" title="操作已提交的文件"></a>操作已提交的文件</h4></li><li>文件修改之后，使用<code>git add filename</code>把文件添加到暂存区</li><li>使用<code>git commit -m "message"</code>提交修改后的文件</li><li>使用<code>git checkout --filename</code>撤销修改，（所有修改均会消息，慎用）<h4 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h4></li><li>使用<code>git add .</code>一次添加多个文件到暂存区</li><li>使用<code>git reset HEAD filename</code>，从暂存区移除文件</li><li>使用<code>git commit -a -m "messge"</code> 跳过暂存，直接提交<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4></li><li><code>git rm -f filename</code>从仓库和工作区中移除文件</li><li><code>git rm --cached filename</code>从仓库中移除，工作区保留<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4>在根目录下创建<code>.gitignore</code>文件，写明要忽略的文件<br>该文件的规范如下：</li><li><code>#</code>开头的是注释</li><li><code>/</code>结尾的是目录</li><li><code>/</code>开头的是防止递归</li><li><code>！</code>开头的是取反</li><li>可以使用glob模式进行文件和文件夹的匹配<h4 id="glob模式"><a href="#glob模式" class="headerlink" title="glob模式"></a>glob模式</h4></li><li><code>*</code>匹配&gt;=0个字符</li><li><code>[abc]</code>匹配方括号中任意一个字符</li><li><code>?</code>匹配1个任意字符</li><li><code>**</code>匹配任意中间目录，例如：<code>a/**/z</code>可以匹配<code>a/z</code>，<code>a/c/z</code>等<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4></li><li><code>git log</code>查看所有提交历史</li><li><code>git log -2</code>只显示最近的2条提交历史</li><li><code>git log -2 --pretty=oneline</code>在一行上显示最近的两条提交历史</li><li><code>git log -2 --pretty=format:"%h | %an | %ar | %s "</code>以规定格式显示最近提交历史，<code>%h</code>表示简写哈希，<code>%an</code>表示作者，<code>%ar</code>表示作者修订日期，<code>%s</code>表示提交说明<h4 id="回退到指定版本"><a href="#回退到指定版本" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h4></li><li><code>git reset --hard &lt;CommitID&gt;</code>根据指定的提交ID回退到指定版本</li><li><code>git relog --pretty=oneline</code>查看命令操作历史</li><li><code>git reset --hard &lt;CommitID&gt;</code>根据最新的提交ID，跳到最新版本</li></ul><h3 id="Github远程仓库使用"><a href="#Github远程仓库使用" class="headerlink" title="Github远程仓库使用"></a>Github远程仓库使用</h3><h4 id="访问GitHub远程仓库"><a href="#访问GitHub远程仓库" class="headerlink" title="访问GitHub远程仓库"></a>访问GitHub远程仓库</h4><ul><li>获取仓库地址（ssh地址或者http地址）</li><li>复制GitHub仓库的https地址（或者ssh地址）</li><li>在git bash 中输入以下命令<code>git remote add 远程仓库名称 远程仓库地址</code>，访问远程仓库</li><li>使用<code>git push -u 仓库名称 仓库分支</code>，将内容推送到远程仓库指定分支上<h4 id="设置ssh密钥"><a href="#设置ssh密钥" class="headerlink" title="设置ssh密钥"></a>设置ssh密钥</h4>远程登陆GitHub仓库有两种方式，一种是http登陆，一种是ssh登陆。http登陆每次要输入用户名密码比较麻烦，所以常用ssh登陆。<br>ssh登陆需要设置ssh密钥，下面我们就开始配置ssh。<ul><li>打开仓库文件夹，运行git bash</li><li>输入<code>ssh-keygen -t rsa -b 4096 -C 'youremail'</code>，该命令会在指定目录设立一个.ssh文件夹，文件夹里保存了公钥和私钥。</li><li>用记事本打开.pub文件（公钥文件），复制内容，粘贴到GitHub上的ssh配置页面。</li><li>回到git bash，运行<code>ssh -T git@github.com</code>，检测ssh是否配置成功。<h4 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a>将远程仓库克隆到本地</h4></li></ul></li><li><code>git clone 远程仓库地址</code></li></ul><h4 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h4><h5 id="本地分支操作"><a href="#本地分支操作" class="headerlink" title="本地分支操作"></a>本地分支操作</h5><ul><li><code>git branch</code> 查看分支列表</li><li><code>git branch newbranch</code>创建新分支</li><li><code>git checkout newbranch</code>切到指定分支上</li><li><code>git checkout -b name</code>创建并切换到name分支上</li><li><code>git merge name</code>合并分支name到当前所在分支</li><li><code>git branch -d name </code>删除name分支<h5 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h5></li><li><code>git remote show 远程仓库名称</code> ，查看远程仓中所有分支列表</li><li>跟踪分支<ul><li><code>git checkout 远程分支名称</code>，下载远程分支到本地</li><li><code>git checkout -b 本地分支名称 远程仓库名称/远程分支名称</code>，下载远程分支到本地并重命名</li></ul></li><li>拉取远程分支最新代码<ul><li><code>git pull</code>从远程仓里拉取当前分支最新代码，保持当前分支和远程分支代码一致</li></ul></li><li>删除远程分支<ul><li><code>git push 远程仓库名称 --delete 远程分支名称</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近刚刚注册GitHub账号，想要建仓，遇到了种种神奇的问题，让俺再次对GitHub的复杂提升了认识。&lt;br&gt;遂决定把这次建仓折腾的经过记录下来，以作备用。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sajlle.github.io/tags/git/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="GitHub" scheme="https://sajlle.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>如何快速上手shell？</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bshell%EF%BC%9F/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bshell%EF%BC%9F/</id>
    <published>2023-04-15T14:52:20.000Z</published>
    <updated>2023-04-15T06:55:42.297Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本课程讲述的是Bourne Again SHell，即bash<span id="more"></span><h2 id="使用Shell"><a href="#使用Shell" class="headerlink" title="使用Shell"></a>使用Shell</h2></li><li><code>missing:~$</code> shell文本接口，主机名为<code>missing</code>，且当前的工作目录（current working directory)是<code>~</code>，<code>$</code>符号表示您不是<code>root</code>用户</li><li>shell如何解析和执行程序？<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br></pre></td></tr></tbody></table></figure><ul><li>上面的示例中，shell执行echo, 同时指定参数hello。</li><li>shell基于空格分割命令并解析，执行第一个单词代表的程序，将后续的单词作为程序可以访问的参数。</li><li>如果想传递包含空格的参数，如名为“My Photos”的文件夹，则可用单引号或者双引号或者使用转义符号<code>\</code>进行处理</li></ul></li><li>shell如何寻找<code>echo</code>?<ul><li>通过咨询<mark style="background: #FF5582A6;">环境变量</mark><code>$PATH</code></li><li><code>$PATH</code>会列出当shell接受某条指令时，进行程序搜索的路径<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></tbody></table></figure></li><li>该目录由<code>:</code>分割。上例中，shell先找了<code>usr/local/sbin</code>，又找了<code>usr/local/bin</code>，接着找<code>usr/sbin</code>，又找了<code>usr/bin</code>…</li><li>可以用<code>which</code>确定该程序名代表的是那个程序</li><li>也可绕过<code>$PATH</code>，直接指定需要执行的程序路径来执行该程序</li></ul></li></ul><h2 id="在shell中导航"><a href="#在shell中导航" class="headerlink" title="在shell中导航"></a>在shell中导航</h2><ul><li>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用&nbsp;<code>/</code>&nbsp;分割，而在Windows上是&nbsp;<code>\</code></li><li><code>/</code>&nbsp;代表的是系统的根目录</li><li>如果某个路径以&nbsp;<code>/</code>&nbsp;开头，那么它是一个&nbsp;<mark style="background: #FF5582A6;"><em>绝对路径</em></mark>，其他的都是&nbsp;<em>相对路径</em>&nbsp;。</li><li><mark style="background: #FF5582A6;">相对路径</mark>是指相对于当前工作目录的路径</li><li>当前工作目录可以使用<mark style="background: #FF5582A6;">&nbsp;<code>pwd</code>&nbsp;</mark>命令来获取。</li><li>切换目录需要使用<mark style="background: #FF5582A6;">&nbsp;<code>cd</code>&nbsp;</mark>命令</li><li><code>.</code>&nbsp;表示的是当前目录，而&nbsp;<code>..</code>&nbsp;表示<mark style="background: #FF5582A6;">上级目录</mark></li><li>当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。</li></ul><h3 id="如何查看目录？"><a href="#如何查看目录？" class="headerlink" title="如何查看目录？"></a>如何查看目录？</h3><ul><li><mark style="background: #FF5582A6;"><code>ls</code>&nbsp;</mark>命令：查看指定目录下包含哪些文件<ul><li>除非我们利用第一个参数指定目录，否则&nbsp;<code>ls</code>&nbsp;会打印当前目录下的文件。</li><li>在执行程序时使用&nbsp;<code>-h</code>&nbsp;或&nbsp;<code>--help</code>&nbsp;标记可以打印帮助信息</li><li><code>-l</code> 可以更加详细地列出目录下文件或文件夹的信息，案例如下：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span> -l /home</span><br><span class="line">drwxr-xr-x 1 missing  <span class="built_in">users</span>  4096 Jun 15  2019 missing</span><br></pre></td></tr></tbody></table></figure></li><li>第一个字符&nbsp;<code>d</code>&nbsp;表示&nbsp;<code>missing</code>&nbsp;是一个目录</li><li>接下来的九个字符，每三个字符构成一组。<ul><li>（<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。</li><li><code>-</code>&nbsp;表示该用户不具备相应的权限。</li><li><code>missing</code>，即文件所有者，有读<code>r</code>写<code>w</code>和搜索<code>x</code>的权利</li><li><code>users</code>，即用户，有读取<code>r</code>和搜索<code>x</code>的权利</li><li>其他人只有读取<code>r</code>和搜索<code>x</code>的权利</li><li>附注：<ul><li>为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。</li><li>为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）</li><li><code>/bin</code>&nbsp;目录下的程序在最后一组，即表示所有人的用户组中，均包含&nbsp;<code>x</code>&nbsp;权限，也就是说任何人都可以执行这些程序。</li></ul></li></ul></li></ul></li></ul><h3 id="shell常见命令"><a href="#shell常见命令" class="headerlink" title="shell常见命令"></a>shell常见命令</h3><ul><li><code>mv</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/mv.md">移动文件</a>，改文件名</li><li><code>pwd</code> &nbsp;print work directory 打印当前目录 显示出当前工作目录的绝对路径</li><li><code>cp</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/cp.md">拷贝文件</a> </li><li><code>mkdir</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/mkdir.md">新建文件夹</a></li><li><code>man</code> <mark style="background: #FF5582A6;">打印程序参数</mark>，输入输出信息，程序工作方式，展示用户手册。按<code>q</code>退出该程序, press ctrl+L can clear your terminal</li><li><code>ed</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/ed.md">文本编辑</a> </li><li><code>chmod</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/chmod.md">更改用户对文件的权限</a></li><li><code>cat</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/cat.md">连接且打印文件</a></li><li><code>rm</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/rm.md">删除文件</a>（不可恢复）</li><li><code>ls</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/ls.md">打印目录</a></li><li><code>cd</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/cd.md">更改目录</a> </li><li><code>echo</code> <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/echo.md">输出字符串</a> </li><li><code>tail</code><a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/tail.md">print the last nth line</a> </li><li><code>grep</code>  <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/grep">查找文件或者字符串</a></li><li><code>tee</code>  <a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/tee.md">运行程序时，将结果打印到terminal上</a><h2 id="在程序间创建链接"><a href="#在程序间创建链接" class="headerlink" title="在程序间创建链接"></a>在程序间创建链接</h2></li><li>在 shell 中，程序有两个主要的“流”：它们的<mark style="background: #FF5582A6;">输入流和输出流</mark>。<ul><li>当程序尝试读取信息时，它们会从输入流中进行读取</li><li>当程序打印信息时，它们会将信息输出到输出流中。</li><li>通常，一个程序的输入输出流都是您的终端。（键盘作为输入，显示器作为输出）</li><li>可以<mark style="background: #FF5582A6;">重定向这些流</mark>！<ul><li>最简单的重定向是&nbsp;<code>&lt; file</code>&nbsp;和&nbsp;<code>&gt; file</code>。</li><li>这两个命令可以将程序的输入输出流分别重定向到文件<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello &gt; hello.txt   // 将hello追加到hello.txt中</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello.txt  // 打印hello.txt的内容</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt  // ？</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt  // 把<span class="built_in">cat</span>输出的内容追加到hello.txt, 再把hello.txt文件的内容追加给hello2.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello2.txt  // 打印hello2.txt文件的内容</span><br><span class="line">hello</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li>还可以使用&nbsp;<code>&gt;&gt;</code>&nbsp;来<mark style="background: #FF5582A6;">向一个文件追加内容</mark><ul><li>使用管道（&nbsp;<em>pipes</em>&nbsp;），我们能够更好的利用文件重定向。</li><li><code>|</code>&nbsp;<mark style="background: #FF5582A6;">操作符</mark>允许我们将一个程序的输出和另外一个程序的输入连接起来<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span> -l / | <span class="built_in">tail</span> -n1   </span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --<span class="built_in">head</span> --silent google.com | grep --ignore-case content-length | <span class="built_in">cut</span> --delimiter=<span class="string">' '</span> -f2</span><br><span class="line">219</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="sudo-和-su，以根用户的身份操作系统"><a href="#sudo-和-su，以根用户的身份操作系统" class="headerlink" title="sudo 和 su，以根用户的身份操作系统"></a>sudo 和 su，以根用户的身份操作系统</h2><ul><li><code>root user</code>可以创建、读取、更新和删除系统中的任何文件</li><li><code>$</code>说明你以普通用户运行程序，<code>#</code>说明你以管理员身份运行程序，</li><li>使用<code>sudo su</code>命令切换为管理员</li><li>使用<code>exit</code>命令退出管理员模式</li><li>通常在用户不会以根用户的身份直接登录系统<ul><li>此时用户想要操作文件，可以使用<mark style="background: #FF5582A6;"><code>sudo</code>命令</mark></li><li><code>sudo</code>命令可以让普通用户以<code>su</code>(即super user或者root的简写)的身份进行操作</li><li>如果遇到拒绝访问（<code>permission denied</code>）错误时，常常因为您必须是根用户才能操作</li></ul></li><li>只有<code>root user</code>才能做的事情：<ul><li>向&nbsp;<mark style="background: #FF5582A6;"><code>sysfs</code>&nbsp;文件</mark>写入内容。</li><li>系统被挂载在&nbsp;<code>/sys</code>&nbsp;下，<code>sysfs</code>&nbsp;文件则暴露了一些内核（kernel）参数。</li><li><strong>注意 Windows 和 macOS 没有这个文件</strong></li><li>例如：笔记本电脑屏幕亮度写在<code>brightness</code>文件中，此文件位于<code>/sys/class/backlight</code><ul><li>在此文件中写入数值，可以更改屏幕亮度，代码如下<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">'*brightness*'</span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line">$ <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span><br><span class="line">$ sudo <span class="built_in">echo</span> 3 &gt; brightness</span><br><span class="line">An error occurred <span class="keyword">while</span> redirecting file <span class="string">'brightness'</span></span><br><span class="line">open: Permission denied</span><br></pre></td></tr></tbody></table></figure>被拒绝了，因为不是根用户，且<code>|</code>、<code>&gt;</code>、和&nbsp;<code>&lt;</code>&nbsp;是<mark style="background: #FF5582A6;">通过 shell 执行的</mark>，而不是被各个程序单独执行。&nbsp;<code>echo</code>&nbsp;等程序并不知道&nbsp;<code>|</code>&nbsp;的存在，<mark style="background: #FF5582A6;">它们只知道从自己的输入输出流中进行读写</mark>。可以这写：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 3 | sudo <span class="built_in">tee</span> brightness</span><br></pre></td></tr></tbody></table></figure>打开&nbsp;<code>/sys</code>&nbsp;文件的是<mark style="background: #FF5582A6;">&nbsp;<code>tee</code>&nbsp;</mark>这个程序，并且该程序以<mark style="background: #FF5582A6;">&nbsp;<code>root</code>&nbsp;</mark>权限在运行，因此操作可以进行。<br>注释：<code>tee</code>的作用是把内容写到 brightness 里然后再输出到公屏上。<br>注释：<code>|</code>的作用是把两个程序连接起来，差不多是等前面的程序执行完毕，再执行后面的程序</li></ul></li></ul></li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol><li> 本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>或者是 Linux 虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">me@k345:/sys/power$ <span class="built_in">cd</span> ~</span><br><span class="line">me@k345:~$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></tbody></table></figure></li><li>在&nbsp;<code>/tmp</code>&nbsp;下新建一个名为&nbsp;<code>missing</code>&nbsp;的文件夹。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~$ <span class="built_in">mkdir</span> tmp/missing</span><br><span class="line">me@k345:~$ <span class="built_in">ls</span></span><br><span class="line">tmp</span><br><span class="line">me@k345:~$ <span class="built_in">cd</span> tmp/missing</span><br></pre></td></tr></tbody></table></figure></li><li> 用&nbsp;<code>man</code>&nbsp;查看程序&nbsp;<code>touch</code>&nbsp;的使用手册。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ man <span class="built_in">touch</span></span><br></pre></td></tr></tbody></table></figure></li><li>用&nbsp;<code>touch</code>&nbsp;在&nbsp;<code>missing</code>&nbsp;文件夹中新建一个叫&nbsp;<code>semester</code>&nbsp;的文件。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ <span class="built_in">touch</span> semester</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">ls</span></span><br><span class="line">semester</span><br></pre></td></tr></tbody></table></figure></li><li>将以下内容一行一行地写入&nbsp;<code>semester</code>&nbsp;文件：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent https://missing.csail.mit.edu</span><br></pre></td></tr></tbody></table></figure><ul><li>第一行可能有点棘手，&nbsp;<code>#</code>&nbsp;在Bash中表示注释，而&nbsp;<code>!</code>&nbsp;即使被双引号（<code>"</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考&nbsp;<a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ <span class="built_in">echo</span> <span class="string">'#!/bin/sh'</span> &gt; semester</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">echo</span> curl --<span class="built_in">head</span> --silent https://missing.csail.mit.edu &gt;&gt; semester</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">cat</span> semester</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent https://missing.csnail.mit.edu</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用&nbsp;<code>ls</code>&nbsp;命令来获取信息并理解其不能执行的原因。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ ./semester</span><br><span class="line">-bash: ./semester: Permission denied</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">ls</span> -l semester</span><br><span class="line">-rw-r--r-- 1 me me 62 Dec 13 16:15 semester</span><br></pre></td></tr></tbody></table></figure></li><li>查看&nbsp;<a href="shell%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/chmod.md"><code>chmod</code>&nbsp;</a>的手册(例如，使用&nbsp;<code>man chmod</code>&nbsp;命令)<br><code>man chmod</code></li><li>使用&nbsp;<code>chmod</code>&nbsp;命令改变权限，使&nbsp;<code>./semester</code>&nbsp;能够成功执行，不要使用&nbsp;<code>sh semester</code>&nbsp;来执行该程序。您的 shell 是如何知晓这个文件需要使用<mark style="background: #FF5582A6;">&nbsp;<code>sh</code>&nbsp;</mark>来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ <span class="built_in">chmod</span> 774 semester</span><br><span class="line">me@k345:~/tmp/missing$ ./semester</span><br><span class="line">HTTP/2 200</span><br><span class="line">server: GitHub.com</span><br><span class="line">content-type: text/html; charset=utf-8</span><br><span class="line">last-modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">etag: <span class="string">"638e155b-1f37"</span></span><br><span class="line">expires: Tue, 13 Dec 2022 06:00:39 GMT</span><br><span class="line">cache-control: max-age=600</span><br><span class="line">x-proxy-cache: MISS</span><br><span class="line">x-github-request-id: 1384:4AB2:A56CA:BC41A:639812AF</span><br><span class="line">accept-ranges: bytes</span><br><span class="line"><span class="built_in">date</span>: Tue, 13 Dec 2022 08:25:13 GMT</span><br><span class="line">via: 1.1 varnish</span><br><span class="line">age: 0</span><br><span class="line">x-served-by: cache-hkg17927-HKG</span><br><span class="line">x-cache: HIT</span><br><span class="line">x-cache-hits: 1</span><br><span class="line">x-timer: S1670919913.350973,VS0,VE369</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">x-fastly-request-id: a3eb30c6a4647450e4a045e388d5f9eccb08d85d</span><br><span class="line">content-length: 7991</span><br></pre></td></tr></tbody></table></figure></li><li>使用&nbsp;<code>|</code>&nbsp;和&nbsp;<code>&gt;</code>&nbsp;，将&nbsp;<code>semester</code>&nbsp;文件输出的最后更改日期信息，写入主目录下的&nbsp;<code>last-modified.txt</code>&nbsp;的文件中<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">me@k345:~/tmp/missing$ ./semester | grep last-modified</span><br><span class="line">last-modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br><span class="line">me@k345:~/tmp/missing$ ./semester | grep last-modified &gt; ~/last-modified.txt</span><br><span class="line">me@k345:~/tmp/missing$ <span class="built_in">cat</span> ~/last-modified.txt</span><br><span class="line">last-modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br></pre></td></tr></tbody></table></figure></li><li>写一段命令来从&nbsp;<code>/sys</code>&nbsp;中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">me@k345:/sys/class/power_supply/battery$ <span class="built_in">cat</span> /sys/class/power_supply/battery/capacity</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本课程讲述的是Bourne Again SHell，即bash&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
    <category term="Shell" scheme="https://sajlle.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>命令行环境介绍</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-04-15T14:51:21.000Z</published>
    <updated>2023-04-15T06:57:12.345Z</updated>
    
    <content type="html"><![CDATA[<p>当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p><p>我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p><p>我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p><span id="more"></span><h1 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h1><p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用&nbsp;<code>find</code>&nbsp;搜索一个非常大的目录结构）。大多数情况下，我们可以使用&nbsp;<code>Ctrl-C</code>&nbsp;来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p><p>在上面的例子中，当我们输入&nbsp;<code>Ctrl-C</code>&nbsp;时，shell 会发送一个<code>SIGINT</code>&nbsp;信号到进程。</p><p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code>&nbsp;并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code>&nbsp;信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import signal, time</span><br><span class="line"></span><br><span class="line">def handler(signum, time):</span><br><span class="line">    print("\nI got a SIGINT, but I am not stopping")</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    time.sleep(.1)</span><br><span class="line">    print("\r{}".format(i), end="")</span><br><span class="line">    i += 1</span><br></pre></td></tr></tbody></table></figure><p>如果我们向这个程序发送两次&nbsp;<code>SIGINT</code>&nbsp;，然后再发送一次&nbsp;<code>SIGQUIT</code>，程序会有什么反应？注意&nbsp;<code>^</code>&nbsp;是我们在终端输入<code>Ctrl</code>&nbsp;时的表示形式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python sigint.py</span><br><span class="line">24^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">26^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">30^\[1]    39913 quit       python sigint.pyƒ</span><br></pre></td></tr></tbody></table></figure><p>尽管&nbsp;<code>SIGINT</code>&nbsp;和&nbsp;<code>SIGQUIT</code>&nbsp;都常常用来发出和终止程序相关的请求。<code>SIGTERM</code>&nbsp;则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a>&nbsp;命令, 它的语法是：&nbsp;<code>kill -TERM &lt;PID&gt;</code>。</p><h2 id="暂停和后台执行进程"><a href="#暂停和后台执行进程" class="headerlink" title="暂停和后台执行进程"></a>暂停和后台执行进程</h2><p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code>&nbsp;会让进程暂停。在终端中，键入&nbsp;<code>Ctrl-Z</code>&nbsp;会让 shell 发送&nbsp;<code>SIGTSTP</code>&nbsp;信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p><p>我们可以使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a>&nbsp;或&nbsp;<a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a>&nbsp;命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p><p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a>&nbsp;命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a>&nbsp;找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code>&nbsp;会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用&nbsp;<code>$!</code>&nbsp;这一特殊参数。</p><p>还有一件事情需要掌握，那就是命令中的&nbsp;<code>&amp;</code>&nbsp;后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p><p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code>&nbsp;，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a>&nbsp;(一个用来忽略&nbsp;<code>SIGHUP</code>&nbsp;的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code>&nbsp;。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p><p>下面这个简单的会话中展示来了些概念的应用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>SIGKILL</code>&nbsp;是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p><p>您可以在&nbsp;<a href="https://en.wikipedia.org/wiki/Signal_(IPC)">这里</a>&nbsp;或输入&nbsp;<a href="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a>&nbsp;或使用&nbsp;<code>kill -l</code>&nbsp;来获取更多关于信号的信息。</p><h1 id="终端多路复用"><a href="#终端多路复用" class="headerlink" title="终端多路复用"></a>终端多路复用</h1><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p><p>像&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>&nbsp;这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p><p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p><p>这让您操作远端设备时的工作流大大改善，避免了&nbsp;<code>nohup</code>&nbsp;和其他类似技巧的使用。</p><p>现在最流行的终端多路器是&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code>&nbsp;是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p><p><code>tmux</code>&nbsp;的快捷键需要我们掌握，它们都是类似&nbsp;<code>&lt;C-b&gt; x</code>&nbsp;这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下&nbsp;<code>x</code>。<code>tmux</code>&nbsp;中对象的继承结构如下：</p><ul><li><strong>会话</strong>&nbsp;- 每个会话都是一个独立的工作区，其中包含一个或多个窗口<ul><li>  <code>tmux</code>&nbsp;开始一个新的会话</li><li>  <code>tmux new -s NAME</code>&nbsp;以指定名称开始一个新的会话</li><li>  <code>tmux ls</code>&nbsp;列出当前所有会话</li><li>  在&nbsp;<code>tmux</code>&nbsp;中输入&nbsp;<code>&lt;C-b&gt; d</code>&nbsp;，将当前会话分离</li><li>  <code>tmux a</code>&nbsp;重新连接最后一个会话。您也可以通过&nbsp;<code>-t</code>&nbsp;来指定具体的会话</li></ul></li><li><strong>窗口</strong>&nbsp;- 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<ul><li>  <code>&lt;C-b&gt; c</code>&nbsp;创建一个新的窗口，使用&nbsp;<code>&lt;C-d&gt;</code>关闭</li><li>  <code>&lt;C-b&gt; N</code>&nbsp;跳转到第&nbsp;<em>N</em>&nbsp;个窗口，注意每个窗口都是有编号的</li><li>  <code>&lt;C-b&gt; p</code>&nbsp;切换到前一个窗口</li><li>  <code>&lt;C-b&gt; n</code>&nbsp;切换到下一个窗口</li><li>  <code>&lt;C-b&gt; ,</code>&nbsp;重命名当前窗口</li><li>  <code>&lt;C-b&gt; w</code>&nbsp;列出当前所有窗口</li></ul></li><li><strong>面板</strong>&nbsp;- 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<ul><li>  <code>&lt;C-b&gt; "</code>&nbsp;水平分割</li><li>  <code>&lt;C-b&gt; %</code>&nbsp;垂直分割</li><li>  <code>&lt;C-b&gt; &lt;方向&gt;</code>&nbsp;切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li><li>  <code>&lt;C-b&gt; z</code>&nbsp;切换当前面板的缩放</li><li>  <code>&lt;C-b&gt; [</code>&nbsp;开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li><li>  <code>&lt;C-b&gt; &lt;空格&gt;</code>&nbsp;在不同的面板排布间切换</li></ul></li></ul><p>扩展阅读：&nbsp;<a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a>&nbsp;是一份&nbsp;<code>tmux</code>&nbsp;快速入门教程，&nbsp;<a href="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a>&nbsp;文章则更加详细，它包含了&nbsp;<code>screen</code>&nbsp;命令。您也许想要掌握&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a>&nbsp;命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias alias_name="command_to_alias arg1 arg2"</span><br></pre></td></tr></tbody></table></figure><p>注意，&nbsp;<code>=</code>两边是没有空格的，因为&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a>&nbsp;是一个 shell 命令，它只接受一个参数。</p><p>别名有许多很方便的特性:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 创建常用命令的缩写</span><br><span class="line">alias ll="ls -lh"</span><br><span class="line"></span><br><span class="line"># 能够少输入很多</span><br><span class="line">alias gs="git status"</span><br><span class="line">alias gc="git commit"</span><br><span class="line">alias v="vim"</span><br><span class="line"></span><br><span class="line"># 手误打错命令也没关系</span><br><span class="line">alias sl=ls</span><br><span class="line"></span><br><span class="line"># 重新定义一些命令行的默认行为</span><br><span class="line">alias mv="mv -i"           # -i prompts before overwrite</span><br><span class="line">alias mkdir="mkdir -p"     # -p make parent dirs as needed</span><br><span class="line">alias df="df -h"           # -h prints human readable format</span><br><span class="line"></span><br><span class="line"># 别名可以组合使用</span><br><span class="line">alias la="ls -A"</span><br><span class="line">alias lla="la -l"</span><br><span class="line"></span><br><span class="line"># 在忽略某个别名</span><br><span class="line">\ls</span><br><span class="line"># 或者禁用别名</span><br><span class="line">unalias la</span><br><span class="line"></span><br><span class="line"># 获取别名的定义</span><br><span class="line">alias ll</span><br><span class="line"># 会打印 ll='ls -lh'</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code>&nbsp;或&nbsp;<code>.zshrc</code>，下一节我们就会讲到。</p><h1 id="配置文件（Dotfiles）"><a href="#配置文件（Dotfiles）" class="headerlink" title="配置文件（Dotfiles）"></a>配置文件（Dotfiles）</h1><p>很多程序的配置都是通过纯文本格式的被称作_点文件_的配置文件来完成的（之所以称为点文件，是因为它们的文件名以&nbsp;<code>.</code>&nbsp;开头，例如&nbsp;<code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p><p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a>&nbsp;有非常好的资源</p><p>对于&nbsp;<code>bash</code>来说，在大多数系统下，您可以通过编辑&nbsp;<code>.bashrc</code>&nbsp;或&nbsp;<code>.bash_profile</code>&nbsp;来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p><p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似&nbsp;<code>export PATH="$PATH:/path/to/program/bin"</code>&nbsp;的命令，这样才能确保这些程序能够被 shell 找到。</p><p>还有一些其他的工具也可以通过_点文件_进行配置：</p><ul><li>  <code>bash</code>&nbsp;-&nbsp;<code>~/.bashrc</code>,&nbsp;<code>~/.bash_profile</code></li><li>  <code>git</code>&nbsp;-&nbsp;<code>~/.gitconfig</code></li><li>  <code>vim</code>&nbsp;-&nbsp;<code>~/.vimrc</code>&nbsp;和&nbsp;<code>~/.vim</code>&nbsp;目录</li><li>  <code>ssh</code>&nbsp;-&nbsp;<code>~/.ssh/config</code></li><li>  <code>tmux</code>&nbsp;-&nbsp;<code>~/.tmux.conf</code></li></ul><p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其&nbsp;<strong>符号链接</strong>&nbsp;到需要的地方。这么做有如下好处：</p><ul><li>  <strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li><li>  <strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li><li>  <strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li><li>  <strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li></ul><p>配置文件中需要放些什么？您可以通过在线文档和<a href="https://en.wikipedia.org/wiki/Man_page">帮助手册</a>了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的<a href="https://github.com/search?o=desc&amp;q=dotfiles&amp;s=stars&amp;type=Repositories">dotfiles 仓库</a>&nbsp;—— 其中最受欢迎的那些可以在<a href="https://github.com/mathiasbynens/dotfiles">这里</a>找到（我们建议您不要直接复制别人的配置）。<a href="https://dotfiles.github.io/">这里</a>&nbsp;也有一些非常有用的资源。</p><p>本课程的老师们也在 GitHub 上开源了他们的配置文件：&nbsp;<a href="https://github.com/anishathalye/dotfiles">Anish</a>,&nbsp;<a href="https://github.com/jonhoo/configs">Jon</a>,&nbsp;<a href="https://github.com/jjgo/dotfiles">Jose</a>.</p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p><p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [[ "$(uname)" == "Linux" ]]; then {do_something}; fi</span><br><span class="line"></span><br><span class="line"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="line">if [[ "$SHELL" == "zsh" ]]; then {do_something}; fi</span><br><span class="line"></span><br><span class="line"># 您也可以针对特定的设备进行配置</span><br><span class="line">if [[ "$(hostname)" == "myServer" ]]; then {do_something}; fi</span><br></pre></td></tr></tbody></table></figure><p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code>&nbsp;可以这样编写：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以在日常使用的设备上创建配置文件&nbsp;<code>~/.gitconfig_local</code>&nbsp;来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p><p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在&nbsp;<code>bash</code>&nbsp;和&nbsp;<code>zsh</code>&nbsp;中同时启用一些别名，您可以把它们写在&nbsp;<code>.aliases</code>&nbsp;里，然后在这两个 shell 里应用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Test if ~/.aliases exists and source it</span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h1 id="远端设备"><a href="#远端设备" class="headerlink" title="远端设备"></a>远端设备</h1><p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p><p>通过如下命令，您可以使用&nbsp;<code>ssh</code>&nbsp;连接到其他服务器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></tbody></table></figure><p>这里我们尝试以用户名&nbsp;<code>foo</code>&nbsp;登录服务器&nbsp;<code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似&nbsp;<code>ssh bar</code>&nbsp;这样的命令来登录服务器。</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p><code>ssh</code>&nbsp;的一个经常被忽视的特性是它可以直接远程执行命令。&nbsp;<code>ssh foobar@server ls</code>&nbsp;可以直接在用foobar的命令下执行&nbsp;<code>ls</code>&nbsp;命令。 想要配合管道来使用也可以，&nbsp;<code>ssh foobar@server ls | grep PATTERN</code>&nbsp;会在本地查询远端&nbsp;<code>ls</code>&nbsp;的输出而&nbsp;<code>ls | ssh foobar@server grep PATTERN</code>&nbsp;会在远端对本地&nbsp;<code>ls</code>&nbsp;输出的结果进行查询。</p><h2 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h2><p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是&nbsp;<code>~/.ssh/id_rsa</code>&nbsp;或者&nbsp;<code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>使用&nbsp;<a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a>&nbsp;命令可以生成一对密钥：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></tbody></table></figure><p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用&nbsp;<a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a>&nbsp;或&nbsp;<a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a>&nbsp;，这样就不需要每次都输入该密码了。</p><p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a>&nbsp;介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行&nbsp;<code>ssh-keygen -y -f /path/to/key</code>.</p><h3 id="基于密钥的认证机制"><a href="#基于密钥的认证机制" class="headerlink" title="基于密钥的认证机制"></a>基于密钥的认证机制</h3><p><code>ssh</code>&nbsp;会查询&nbsp;<code>.ssh/authorized_keys</code>&nbsp;来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh/id_ed25519 | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys'</span><br></pre></td></tr></tbody></table></figure><p>如果支持&nbsp;<code>ssh-copy-id</code>&nbsp;的话，可以使用下面这种更简单的解决方案：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></tbody></table></figure><h2 id="通过-SSH-复制文件"><a href="#通过-SSH-复制文件" class="headerlink" title="通过 SSH 复制文件"></a>通过 SSH 复制文件</h2><p>使用 ssh 复制文件有很多方法：</p><ul><li>  <code>ssh+tee</code>, 最简单的方法是执行&nbsp;<code>ssh</code>&nbsp;命令，然后通过这样的方法利用标准输入实现&nbsp;<code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a>&nbsp;命令会将标准输出写入到一个文件；</li><li>  <a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a>&nbsp;：当需要拷贝大量的文件或目录时，使用<code>scp</code>&nbsp;命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li><li>  <a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a>&nbsp;对&nbsp;<code>scp</code>&nbsp;进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于&nbsp;<code>--partial</code>标记实现断点续传。<code>rsync</code>&nbsp;的语法和<code>scp</code>类似；</li></ul><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用&nbsp;<code>localhost:PORT</code>&nbsp;或&nbsp;<code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p><p>此时就需要进行&nbsp;_端口转发_。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p><p><strong>本地端口转发</strong><img src="https://i.stack.imgur.com/a28N8.png%C2%A0" alt="Local Port Forwarding" title="本地端口转发"></p><p><strong>远程端口转发</strong><img src="https://i.stack.imgur.com/4iK3b.png%C2%A0" alt="Remote Port Forwarding" title="远程端口转发"></p><p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听&nbsp;<code>8888</code>&nbsp;端口。 然后，建立从本地端口&nbsp;<code>9999</code>&nbsp;的转发，使用&nbsp;<code>ssh -L 9999:localhost:8888 foobar@remote_server</code>&nbsp;。这样只需要访问本地的&nbsp;<code>localhost:9999</code>&nbsp;即可。</p><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias my_server="ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span><br></pre></td></tr></tbody></table></figure><p>不过，更好的方法是使用&nbsp;<code>~/.ssh/config</code>.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"></span><br><span class="line"># 在配置文件中也可以使用通配符</span><br><span class="line">Host *.mit.edu</span><br><span class="line">    User foobaz</span><br></pre></td></tr></tbody></table></figure><p>这么做的好处是，使用&nbsp;<code>~/.ssh/config</code>&nbsp;文件来创建别名，类似&nbsp;<code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p><p>注意，<code>~/.ssh/config</code>&nbsp;文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p><p>服务器侧的配置通常放在&nbsp;<code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p><p>有时将一个远端文件夹挂载到本地会比较方便，&nbsp;<a href="https://github.com/libfuse/sshfs">sshfs</a>&nbsp;可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p><h1 id="Shell-amp-框架"><a href="#Shell-amp-框架" class="headerlink" title="Shell &amp; 框架"></a>Shell &amp; 框架</h1><p>在 shell 工具和脚本那节课中我们已经介绍了&nbsp;<code>bash</code>&nbsp;shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。</p><p>例如，<code>zsh</code>&nbsp;shell 是&nbsp;<code>bash</code>&nbsp;的超集并提供了一些方便的功能：</p><ul><li>  智能替换,&nbsp;<code>**</code></li><li>  行内替换/通配符扩展</li><li>  拼写纠错</li><li>  更好的 tab 补全和选择</li><li>  路径展开 (<code>cd /u/lo/b</code>&nbsp;会被展开为&nbsp;<code>/usr/local/bin</code>)</li></ul><p><strong>框架</strong>&nbsp;也可以改进您的 shell。比较流行的通用框架包括<a href="https://github.com/sorin-ionescu/prezto">prezto</a>&nbsp;或&nbsp;<a href="https://ohmyz.sh/">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh 语法高亮</a>&nbsp;或&nbsp;<a href="https://github.com/zsh-users/zsh-history-substring-search">zsh 历史子串查询</a>。 像&nbsp;<a href="https://fishshell.com/">fish</a>&nbsp;这样的 shell 包含了很多用户友好的功能，其中一些特性包括：</p><ul><li>  向右对齐</li><li>  命令语法高亮</li><li>  历史子串查询</li><li>  基于手册页面的选项补全</li><li>  更智能的自动补全</li><li>  提示符主题</li></ul><p>需要注意的是，使用这些框架可能会降低您 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p><h1 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h1><p>和自定义 shell 一样，花点时间选择适合您的&nbsp;<strong>终端模拟器</strong>并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间<a href="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">比较</a>的信息）</p><p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p><ul><li>  字体选择</li><li>  彩色主题</li><li>  快捷键</li><li>  标签页/面板支持</li><li>  回退配置</li><li>  性能（像&nbsp;<a href="https://github.com/jwilm/alacritty">Alacritty</a>&nbsp;或者&nbsp;<a href="https://sw.kovidgoyal.net/kitty/">kitty</a>&nbsp;这种比较新的终端，它们支持GPU加速）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。&lt;/p&gt;
&lt;p&gt;我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。&lt;/p&gt;
&lt;p&gt;我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
    <category term="Shell" scheme="https://sajlle.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Vim编辑器使用指南</title>
    <link href="https://sajlle.github.io/2023/04/15/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://sajlle.github.io/2023/04/15/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2023-04-15T14:50:57.000Z</published>
    <updated>2023-04-15T06:58:35.748Z</updated>
    
    <content type="html"><![CDATA[<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的 Word 与 Visual Studio Code）。</p><span id="more"></span><p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p><ul><li>  阅读教程（比如这节课以及我们为您提供的资源）</li><li>  坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li><li>  随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有</li></ul><p>如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如<mark style="background: #FFB8EBA6;">打开和编辑文件、保存与退出、浏览缓冲区</mark>。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p><h1 id="该学哪个编辑器？"><a href="#该学哪个编辑器？" class="headerlink" title="该学哪个编辑器？"></a>该学哪个编辑器？</h1><p>程序员们对自己正在使用的文本编辑器通常有着&nbsp;<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98">非常强的执念</a>。</p><p>现在最流行的编辑器是什么？<a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow 的用户并不能代表所有程序员）显示，<a href="https://code.visualstudio.com/">Visual Studio Code</a>&nbsp;是目前最流行的代码编辑器。而&nbsp;<a href="https://www.vim.org/">Vim</a>&nbsp;则是最流行的基于命令行的编辑器。</p><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976 年的 Vi 编辑器，到现在还在 不断开发中。Vim 有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140 万人安装了&nbsp;<a href="https://github.com/VSCodeVim/Vim">Vim emulation for VS code</a>）。即使你最后使用 其他编辑器，Vim 也值得学习。</p><p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim 的设计哲学，教你基础知识， 并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p><h1 id="Vim-的哲学"><a href="#Vim-的哲学" class="headerlink" title="Vim 的哲学"></a>Vim 的哲学</h1><p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim 是一个_多模态_编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p><p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p><h1 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h1><p>Vim 的设计以大多数时间都花在<mark style="background: #FFB8EBA6;">阅读、浏览和进行少量编辑改动</mark>为基础，因此它具有多种操作模式：</p><ul><li>  <strong>正常模式</strong>：在文件中四处移动光标进行修改</li><li>  <strong>插入模式</strong>：插入文本 （press <code>i</code> to enter , press <code>esc</code> to quit</li><li>  <strong>替换模式</strong>：替换文本 </li><li>  <strong>可视化模式</strong>（一般，行，块）：选中文本块</li><li>  <strong>命令模式</strong>：用于执行命令</li></ul><p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code>&nbsp;在插入模式会插入字母&nbsp;<code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p><p>在默认设置下，Vim 会在左下角显示当前的模式。Vim 启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。</p><p>你可以按下&nbsp;<code>&lt;ESC&gt;</code>（<mark style="background: #FFB8EBA6;">退出键）从任何其他模式返回正常模式</mark>。在正常模式，键入&nbsp;<code>i</code>&nbsp;进入插入 模式，<code>R</code>&nbsp;进入替换模式，<code>v</code>&nbsp;进入可视（一般）模式，<code>V</code>&nbsp;进入可视（行）模式，<code>&lt;C-v&gt;</code>&nbsp;（Ctrl-V, 有时也写作&nbsp;<code>^V</code>）进入可视（块）模式，<code>:</code>&nbsp;进入命令模式。</p><p>因为你会在使用 Vim 时大量使用&nbsp;<code>&lt;ESC&gt;</code>&nbsp;键，所以可以考虑把大小写锁定键重定义成&nbsp;<code>&lt;ESC&gt;</code>&nbsp;键（<a href="https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS">MacOS 教程</a>）。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h2><p>在正常模式，键入&nbsp;<code>i</code>&nbsp;进入插入模式。现在 Vim 跟很多其他的编辑器一样，直到你键入&nbsp;<code>&lt;ESC&gt;</code>&nbsp;返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p><h2 id="缓存，-标签页，-窗口"><a href="#缓存，-标签页，-窗口" class="headerlink" title="缓存， 标签页， 窗口"></a>缓存， 标签页， 窗口</h2><p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在_多个_窗口打开，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用，比如在查看同一个文件的不同部分的时候。</p><p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>在正常模式下键入&nbsp;<code>:</code>&nbsp;进入命令行模式。 在键入&nbsp;<code>:</code>&nbsp;后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能，包括<mark style="background: #FFB8EBA6;">打开，保存，关闭文件</mark>，以及&nbsp;<a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p><ul><li>  <code>:q</code>&nbsp;退出（关闭窗口）</li><li>  <code>:w</code>&nbsp;保存（写）</li><li>  <code>:wq</code>&nbsp;保存然后退出</li><li>  <code>:e {文件名}</code>&nbsp;打开要编辑的文件</li><li>  <code>:ls</code>&nbsp;显示打开的缓存</li><li><code>:help {标题}</code>&nbsp;打开帮助文档<ul><li>  <code>:help :w</code>&nbsp;打开&nbsp;<code>:w</code>&nbsp;命令的帮助文档</li><li>  <code>:help w</code>&nbsp;打开&nbsp;<code>w</code>&nbsp;移动的帮助文档</li></ul></li></ul><h1 id="Vim-的接口其实是一种编程语言"><a href="#Vim-的接口其实是一种编程语言" class="headerlink" title="Vim 的接口其实是一种编程语言"></a>Vim 的接口其实是一种编程语言</h1><p>Vim 最重要的设计思想是 Vim 的界面本身是一个程序语言。键入操作（以及他们的助记名） 本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。</p><ul><li>  基本移动:&nbsp;<code>hjkl</code>&nbsp;（左， 下， 上， 右）</li><li>  词：&nbsp;<code>w</code>&nbsp;（下一个词），&nbsp;<code>b</code>&nbsp;（词初），&nbsp;<code>e</code>&nbsp;（词尾）</li><li>  行：&nbsp;<code>0</code>&nbsp;（行初），&nbsp;<code>^</code>&nbsp;（第一个非空格字符），&nbsp;<code>$</code>&nbsp;（行尾）</li><li>  屏幕：&nbsp;<code>H</code>&nbsp;（屏幕首行），&nbsp;<code>M</code>&nbsp;（屏幕中间），&nbsp;<code>L</code>&nbsp;（屏幕底部）</li><li>  翻页：&nbsp;<code>Ctrl-u</code>&nbsp;（上翻），&nbsp;<code>Ctrl-d</code>&nbsp;（下翻）</li><li>  文件：&nbsp;<code>gg</code>&nbsp;（文件头），&nbsp;<code>G</code>&nbsp;（文件尾）</li><li>  行数：&nbsp;<code>:{行数}&lt;CR&gt;</code>&nbsp;或者&nbsp;<code>{行数}G</code>&nbsp;({行数}为行数)</li><li>  杂项：&nbsp;<code>%</code>&nbsp;（找到配对，比如括号或者 /* */ 之类的注释对）</li><li>查找：&nbsp;<code>f{字符}</code>，&nbsp;<code>t{字符}</code>，&nbsp;<code>F{字符}</code>，&nbsp;<code>T{字符}</code><ul><li>  查找/到 向前/向后 在本行的{字符}</li><li>  <code>,</code>&nbsp;/&nbsp;<code>;</code>&nbsp;用于导航匹配</li></ul></li><li>  搜索:&nbsp;<code>/{正则表达式}</code>,&nbsp;<code>n</code>&nbsp;/&nbsp;<code>N</code>&nbsp;用于导航匹配</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>可视化模式:</p><ul><li>  可视化：<code>v</code></li><li>  可视化行：&nbsp;<code>V</code></li><li>  可视化块：<code>Ctrl+v</code></li></ul><p>可以用移动命令来选中。</p><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p><ul><li><code>i</code>&nbsp;进入插入模式<ul><li>  但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li>  <code>O</code>&nbsp;/&nbsp;<code>o</code>&nbsp;在之上/之下插入行</li><li><code>d{移动命令}</code>&nbsp;删除 {移动命令}<ul><li>  例如，<code>dw</code>&nbsp;删除词,&nbsp;<code>d$</code>&nbsp;删除到行尾,&nbsp;<code>d0</code>&nbsp;删除到行头。</li></ul></li><li><code>c{移动命令}</code>&nbsp;改变 {移动命令}<ul><li>  例如，<code>cw</code>&nbsp;改变词</li><li>  比如&nbsp;<code>d{移动命令}</code>&nbsp;再&nbsp;<code>i</code></li></ul></li><li>  <code>x</code>&nbsp;删除字符（等同于&nbsp;<code>dl</code>）</li><li>  <code>s</code>&nbsp;替换字符（等同于&nbsp;<code>xi</code>）</li><li>可视化模式 + 操作<ul><li>  选中文字,&nbsp;<code>d</code>&nbsp;删除 或者&nbsp;<code>c</code>&nbsp;改变</li></ul></li><li>  <code>u</code>&nbsp;撤销,&nbsp;<code>&lt;C-r&gt;</code>&nbsp;重做</li><li>  <code>y</code>&nbsp;复制 / “yank” （其他一些命令比如&nbsp;<code>d</code>&nbsp;也会复制）</li><li>  <code>p</code>&nbsp;粘贴</li><li>  更多值得学习的: 比如&nbsp;<code>~</code>&nbsp;改变字符的大小写</li></ul><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p><ul><li>  <code>3w</code>&nbsp;向前移动三个词</li><li>  <code>5j</code>&nbsp;向下移动5行</li><li>  <code>7dw</code>&nbsp;删除7个词</li></ul><h2 id="修饰语"><a href="#修饰语" class="headerlink" title="修饰语"></a>修饰语</h2><p>你可以用修饰语改变“名词”的意义。修饰语有&nbsp;<code>i</code>，表示“内部”或者“在内“，和&nbsp;<code>a</code>， 表示”周围“。</p><ul><li>  <code>ci(</code>&nbsp;改变当前括号内的内容</li><li>  <code>ci[</code>&nbsp;改变当前方括号内的内容</li><li>  <code>da'</code>&nbsp;删除一个单引号字符串， 包括周围的单引号</li></ul><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>这里是一个有问题的&nbsp;<a href="https://en.wikipedia.org/wiki/Fizz_buzz">fizz buzz</a>&nbsp;实现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fizz_buzz(limit):</span><br><span class="line">    for i in range(limit):</span><br><span class="line">        if i % 3 == 0:</span><br><span class="line">            print('fizz')</span><br><span class="line">        if i % 5 == 0:</span><br><span class="line">            print('fizz')</span><br><span class="line">        if i % 3 and i % 5:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    fizz_buzz(10)</span><br></pre></td></tr></tbody></table></figure><p>我们会修复以下问题：</p><ul><li>  主函数没有被调用</li><li>  从 0 而不是 1 开始f</li><li>  在 15 的整数倍的时候在不用行打印 “fizz” 和 “buzz”</li><li>  在 5 的整数倍的时候打印 “fizz”</li><li>采用硬编码的参数 10 而不是从命令控制行读取参数</li><li>主函数没有被调用<ul><li>  <code>G</code>&nbsp;文件尾</li><li>  <code>o</code>&nbsp;向下打开一个新行</li><li>  输入 “if&nbsp;<strong>name</strong>&nbsp;…”</li></ul></li><li>从 0 而不是 1 开始<ul><li>  搜索&nbsp;<code>/range</code></li><li>  <code>ww</code>&nbsp;向前移动两个词</li><li>  <code>i</code>&nbsp;插入文字， “1, “</li><li>  <code>ea</code>&nbsp;在 limit 后插入， “+1”</li></ul></li><li>在新的一行 “fizzbuzz”<ul><li>  <code>jj$i</code>&nbsp;插入文字到行尾</li><li>  加入 “, end=’’”</li><li>  <code>jj.</code>&nbsp;重复第二个打印</li><li>  <code>jjo</code>&nbsp;在 if 打开一行</li><li>  加入 “else: print()”</li></ul></li><li>fizz fizz<ul><li>  <code>ci'</code>&nbsp;变到 fizz</li></ul></li><li>命令控制行参数<ul><li>  <code>ggO</code>&nbsp;向上打开</li><li>  “import sys”</li><li>  <code>/10</code></li><li>  <code>ci(</code>&nbsp;to “int(sys.argv[1])”</li></ul></li></ul><p>展示详情请观看课程视频。比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p><h1 id="自定义-Vim"><a href="#自定义-Vim" class="headerlink" title="自定义 Vim"></a>自定义 Vim</h1><p>Vim 由一个位于&nbsp;<code>~/.vimrc</code>&nbsp;的文本配置文件（包含 Vim 脚本命令）。你可能会启用很多基本 设置。</p><p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。&nbsp;<strong>在<a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a>&nbsp;下载我们的设置，然后将它保存成&nbsp;<code>~/.vimrc</code>.</strong></p><p>Vim 能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在 GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>,&nbsp;<a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a>&nbsp;(uses&nbsp;<a href="https://neovim.io/">neovim</a>),&nbsp;<a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它，然后采用对你有用的部分。</p><h1 id="扩展-Vim"><a href="#扩展-Vim" class="headerlink" title="扩展 Vim"></a>扩展 Vim</h1><p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你_不_需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。你可以使用内置的插件管理系统。只需要创建一个&nbsp;<code>~/.vim/pack/vendor/start/</code>&nbsp;的文件夹，然后把插件放到这里（比如通过&nbsp;<code>git clone</code>）。</p><p>以下是一些我们最爱的插件：</p><ul><li>  <a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li><li>  <a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li><li>  <a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li><li>  <a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li></ul><p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>,&nbsp;<a href="https://github.com/jonhoo/configs">Jon</a>,&nbsp;<a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览&nbsp;<a href="https://vimawesome.com/">Vim Awesome</a>&nbsp;来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim plugins”。</p><h1 id="其他程序的-Vim-模式"><a href="#其他程序的-Vim-模式" class="headerlink" title="其他程序的 Vim 模式"></a>其他程序的 Vim 模式</h1><p>很多工具提供了 Vim 模式。这些 Vim 模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim 功能，但是大多数对基本功能支持的很好。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>如果你是一个 Bash 用户，用&nbsp;<code>set -o vi</code>。如果你用 Zsh：<code>bindkey -v</code>。Fish 用&nbsp;<code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以&nbsp;<code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如，<code>git</code>&nbsp;会使用这个编辑器来编辑 commit 信息。</p><h2 id="Readline"><a href="#Readline" class="headerlink" title="Readline"></a>Readline</h2><p>很多程序使用&nbsp;<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a>&nbsp;库来作为 它们的命令控制行界面。Readline 也支持基本的 Vim 模式， 可以通过在&nbsp;<code>~/.inputrc</code>&nbsp;添加如下行开启：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></tbody></table></figure><p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>甚至有 Vim 的网页浏览快捷键&nbsp;<a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的&nbsp;<a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a>&nbsp;和用于 Firefox 的&nbsp;<a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在&nbsp;<a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a>&nbsp;中用 Vim 快捷键。&nbsp;<a href="https://reversed.top/2016-08-13/big-list-of-vim-like-software">这个列表</a>&nbsp;中列举了支持类 vim 键位绑定的软件。</p><h1 id="Vim-进阶"><a href="#Vim-进阶" class="headerlink" title="Vim 进阶"></a>Vim 进阶</h1><p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你 可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p><code>:s</code>&nbsp;（替换）命令（<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p><ul><li><code>%s/foo/bar/g</code><ul><li>  在整个文件中将 foo 全局替换成 bar</li></ul></li><li><code>%s/\[.*\](\(.*\))/\1/g</code><ul><li>  将有命名的 Markdown 链接替换成简单 URLs</li></ul></li></ul><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><ul><li>  用&nbsp;<code>:sp</code>&nbsp;/&nbsp;<code>:vsp</code>&nbsp;来分割窗口</li><li>  同一个缓存可以在多个窗口中显示。</li></ul><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ul><li>  <code>q{字符}</code>&nbsp;来开始在寄存器<code>{字符}</code>中录制宏</li><li>  <code>q</code>停止录制</li><li>  <code>@{字符}</code>&nbsp;重放宏</li><li>  宏的执行遇错误会停止</li><li>  <code>{计数}@{字符}</code>执行一个宏{计数}次</li><li>宏可以递归<ul><li>  首先用<code>q{字符}q</code>清除宏</li><li>  录制该宏，用&nbsp;<code>@{字符}</code>&nbsp;来递归调用该宏 （在录制完成之前不会有任何操作）</li></ul></li><li>例子：将 xml 转成 json (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">file</a>)<ul><li>  一个有 “name” / “email” 键对象的数组</li><li>  用一个 Python 程序？</li><li>用 sed / 正则表达式<ul><li>  <code>g/people/d</code></li><li>  <code>%s/&lt;person&gt;/{/g</code></li><li>  <code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/"name": "\1",/g</code></li><li>  …</li></ul></li><li>Vim 命令 / 宏<ul><li>  <code>Gdd</code>,&nbsp;<code>ggdd</code>&nbsp;删除第一行和最后一行</li><li>格式化最后一个元素的宏 （寄存器&nbsp;<code>e</code>）<ul><li>  跳转到有&nbsp;<code>&lt;name&gt;</code>&nbsp;的行</li><li>  <code>qe^r"f&gt;s": "&lt;ESC&gt;f&lt;C"&lt;ESC&gt;q</code></li></ul></li><li>格式化一个的宏<ul><li>  跳转到有&nbsp;<code>&lt;person&gt;</code>&nbsp;的行</li><li>  <code>qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q</code></li></ul></li><li>格式化一个标签然后转到另外一个的宏<ul><li>  跳转到有&nbsp;<code>&lt;person&gt;</code>&nbsp;的行</li><li>  <code>qq@pjq</code></li></ul></li><li>执行宏到文件尾<ul><li>  <code>999@q</code></li></ul></li><li>  手动移除最后的&nbsp;<code>,</code>&nbsp;然后加上&nbsp;<code>[</code>&nbsp;和&nbsp;<code>]</code>&nbsp;分隔符</li></ul></li></ul></li></ul><h1 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h1><ul><li>  <code>vimtutor</code>&nbsp;是一个 Vim 安装时自带的教程</li><li>  <a href="https://vim-adventures.com/">Vim Adventures</a>&nbsp;是一个学习使用 Vim 的游戏</li><li>  <a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a></li><li>  <a href="https://vimways.org/2019/">Vim Advent Calendar</a>&nbsp;有很多 Vim 小技巧</li><li>  <a href="http://www.vimgolf.com/">Vim Golf</a>&nbsp;是用 Vim 的用户界面作为程序语言的&nbsp;<a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li><li>  <a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a></li><li>  <a href="http://vimcasts.org/">Vim Screencasts</a></li><li>  <a href="https://pragprog.com/titles/dnvim2/">Practical Vim</a>（书籍）</li></ul><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution">习题解答</a></p><ol><li> 完成&nbsp;<code>vimtutor</code>。备注：它在一个&nbsp;<a href="https://en.wikipedia.org/wiki/VT100">80x24</a>（80 列，24 行） 终端窗口看起来效果最好。</li><li> 下载我们提供的&nbsp;<a href="https://missing-semester-cn.github.io/2020/files/vimrc">vimrc</a>，然后把它保存到&nbsp;<code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。</li><li>安装和配置一个插件：&nbsp;<a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>.<ol><li> 用&nbsp;<code>mkdir -p ~/.vim/pack/vendor/start</code>&nbsp;创建插件文件夹</li><li> 下载这个插件：&nbsp;<code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code></li><li> 阅读这个插件的&nbsp;<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件，打开 Vim, 然后用 Vim 命令控制行开始&nbsp;<code>:CtrlP</code>.</li><li> 自定义 CtrlP：添加&nbsp;<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a>&nbsp;到你的&nbsp;<code>~/.vimrc</code>&nbsp;来用按 Ctrl-P 打开 CtrlP</li></ol></li><li> 练习使用 Vim, 在你自己的机器上重做&nbsp;<a href="https://missing-semester-cn.github.io/2020/editors/#demo">演示</a>。</li><li> 下个月用 Vim 完成_所有的_文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”时， 尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题，可以来我们的答疑时间或者给我们发邮件。</li><li> 在其他工具中设置 Vim 快捷键 （见上面的操作指南）。</li><li> 进一步自定义你的&nbsp;<code>~/.vimrc</code>&nbsp;和安装更多插件。</li><li> （高阶）用 Vim 宏将 XML 转换到 JSON (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">例子文件</a>)。 尝试着先完全自己做，但是在你卡住的时候可以查看上面<a href="https://missing-semester-cn.github.io/2020/editors/#macros">宏</a>&nbsp;章节。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的 Word 与 Visual Studio Code）。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
    <category term="Vim" scheme="https://sajlle.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>git基础命令大全</title>
    <link href="https://sajlle.github.io/2023/04/15/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://sajlle.github.io/2023/04/15/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2023-04-15T14:50:26.000Z</published>
    <updated>2023-04-15T07:00:48.934Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读&nbsp;<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>！</p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>  <code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li><li>  <code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为&nbsp;<code>.git</code>&nbsp;的目录下</li><li>  <code>git status</code>: 显示当前的仓库状态</li><li>  <code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li><li><code>git commit</code>: 创建一个新的提交<ul><li>  如何编写&nbsp;<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>  为何要&nbsp;<a href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></li><li>  <code>git log</code>: 显示历史日志</li><li>  <code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li><li>  <code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li><li>  <code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li><li>  <code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</li></ul><h2 id="分支和合并"><a href="#分支和合并" class="headerlink" title="分支和合并"></a>分支和合并</h2><ul><li>  <code>git branch</code>: 显示分支</li><li>  <code>git branch &lt;name&gt;</code>: 创建分支</li><li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支<ul><li>  相当于&nbsp;<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li>  <code>git merge &lt;revision&gt;</code>: 合并到当前分支</li><li>  <code>git mergetool</code>: 使用工具来处理合并冲突</li><li>  <code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li></ul><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><ul><li>  <code>git remote</code>: 列出远端</li><li>  <code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li><li>  <code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li><li>  <code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li><li>  <code>git fetch</code>: 从远端获取对象/索引</li><li>  <code>git pull</code>: 相当于&nbsp;<code>git fetch; git merge</code></li><li>  <code>git clone</code>: 从远端下载仓库</li></ul><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li>  <code>git commit --amend</code>: 编辑提交的内容或信息</li><li>  <code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li><li>  <code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li><li>  <code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作</li></ul><h1 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h1><ul><li>  <code>git config</code>: Git 是一个&nbsp;<a href="https://git-scm.com/docs/git-config">高度可定制的</a>&nbsp;工具</li><li>  <code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li><li>  <code>git add -p</code>: 交互式暂存</li><li>  <code>git rebase -i</code>: 交互式变基</li><li>  <code>git blame</code>: 查看最后修改某行的人</li><li>  <code>git stash</code>: 暂时移除工作目录下的修改内容</li><li>  <code>git bisect</code>: 通过二分查找搜索历史记录</li><li>  <code>.gitignore</code>:&nbsp;<a href="https://git-scm.com/docs/gitignore">指定</a>&nbsp;故意不追踪的文件</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li>  <strong>图形用户界面</strong>: Git 的&nbsp;<a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a>&nbsp;有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li><li>  <strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>,&nbsp;<a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>这样的框架中一般以及集成了这一功能</li><li>  <strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a>&nbsp;是 Vim 中集成 GIt 的常用插件</li><li>  <strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a>&nbsp;<a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a>&nbsp;<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li><li>  <strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中您需要使用一个被称作<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</li><li>  <strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像&nbsp;<a href="https://about.gitlab.com/">GitLab</a>&nbsp;和&nbsp;<a href="https://bitbucket.org/">BitBucket</a>&nbsp;这样的平台。</li></ul><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li>  <a href="https://git-scm.com/book/en/v2">Pro Git</a>&nbsp;，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li><li>  <a href="https://ohshitgit.com/">Oh Shit, Git!?!</a>&nbsp;，简短的介绍了如何从 Git 错误中恢复；</li><li>  <a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a>&nbsp;，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li><li>  <a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li><li>  <a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li><li>  <a href="https://learngitbranching.js.org/">Learn Git Branching</a>&nbsp;通过基于浏览器的游戏来学习 Git ；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;推荐阅读&amp;nbsp;&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot;&gt;Pro Git 中文版&lt;/a&gt;！&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sajlle.github.io/tags/git/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
  </entry>
  
  <entry>
    <title>git原理详解</title>
    <link href="https://sajlle.github.io/2023/04/15/git%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sajlle.github.io/2023/04/15/git%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-15T14:50:00.000Z</published>
    <updated>2023-04-15T06:59:33.899Z</updated>
    
    <content type="html"><![CDATA[<p>版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p><p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p><span id="more"></span><p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p><ul><li>  当前模块是谁编写的？</li><li>  这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li><li>  最近的1000个版本中，何时/为什么导致了单元测试失败？</li></ul><p>尽管版本控制系统有很多， 其事实上的标准则是&nbsp;<strong>Git</strong>&nbsp;。而这篇&nbsp;<a href="https://xkcd.com/1597/">XKCD 漫画</a>&nbsp;则反映出了人们对 Git 的评价：</p><p><img src="https://imgs.xkcd.com/comics/git.png" alt="xkcd 1597"></p><p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p><p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p><h1 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h1><p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = "hello world")</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = "git is wonderful")</span><br></pre></td></tr></tbody></table></figure><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p><h2 id="历史记录建模：关联快照"><a href="#历史记录建模：关联快照" class="headerlink" title="历史记录建模：关联快照"></a>历史记录建模：关联快照</h2><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git 并没有采用这样的模型。</p><p>在 Git 中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p><p>在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></tbody></table></figure><p>上面是一个 ASCII 码构成的简图，其中的&nbsp;<code>o</code>&nbsp;表示一次提交（快照）。</p><p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></tbody></table></figure><p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p><h2 id="数据模型及其伪代码表示"><a href="#数据模型及其伪代码表示" class="headerlink" title="数据模型及其伪代码表示"></a>数据模型及其伪代码表示</h2><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct {</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一种简洁的历史模型。</p><h2 id="对象和内存寻址"><a href="#对象和内存寻址" class="headerlink" title="对象和内存寻址"></a>对象和内存寻址</h2><p>Git 中的对象可以是 blob、树或提交：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></tbody></table></figure><p>Git 在储存数据时，所有的对象都会基于它们的&nbsp;<a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a>&nbsp;进行寻址。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></tbody></table></figure><p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p><p>例如，<a href="https://missing-semester-cn.github.io/2020/version-control/#snapshots">上面</a>例子中的树（可以通过&nbsp;<code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code>&nbsp;来进行可视化），看上去是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></tbody></table></figure><p>树本身会包含一些指向其他内容的指针，例如&nbsp;<code>baz.txt</code>&nbsp;(blob) 和&nbsp;<code>foo</code>&nbsp;(树)。如果我们用&nbsp;<code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></tbody></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p><p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code>&nbsp;引用通常会指向主分支的最新一次提交。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></tbody></table></figure><p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p><p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code>&nbsp;和&nbsp;<code>引用</code>。</p><p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的&nbsp;<code>git</code>&nbsp;命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p><p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交&nbsp;<code>5d83f9e</code>&nbsp;时，有什么命令可以完成该操作（针对这个具体问题，您可以使用&nbsp;<code>git checkout master; git reset --hard 5d83f9e</code>）</p><h1 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h1><p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p><p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p><p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。&lt;/p&gt;
&lt;p&gt;为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://sajlle.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sajlle.github.io/tags/git/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT The Missing Semester" scheme="https://sajlle.github.io/tags/MIT-The-Missing-Semester/"/>
    
  </entry>
  
  <entry>
    <title>数据抽象</title>
    <link href="https://sajlle.github.io/2023/04/15/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
    <id>https://sajlle.github.io/2023/04/15/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</id>
    <published>2023-04-15T14:41:43.000Z</published>
    <updated>2023-04-15T07:23:26.378Z</updated>
    
    <content type="html"><![CDATA[<p>我们在第一章集中讨论了计算过程和函数在程序设计中的作用。 我们了解了如何使用原始数据(数字)和原始操作(算术)，如何通过组合和控制来形成复合函数，以及如何通过给过程命名来创建函数抽象。 我们还发现，高阶函数增强了语言的能力，使我们能够根据通用的计算方法进行操作，从而进行推理。 这就是编程的精髓所在。</p><p>本章的重点是数据。 我们在这里研究的技术将允许我们表示和操作许多不同领域的信息。 由于互联网的爆炸式增长，我们所有人都可以在网上免费获得大量的结构化信息，计算可以应用于各种各样的不同问题。 有效使用内置和用户定义的数据类型是数据处理应用程序的基础。</p><span id="more"></span><h3 id="2-1-1-原生数据类型"><a href="#2-1-1-原生数据类型" class="headerlink" title="2.1.1 原生数据类型"></a>2.1.1 原生数据类型<a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.1-yin-yan#2.1.1-yuan-sheng-shu-ju-lei-xing"></a></h3><p>Python中的每个值都有一个类来决定它是什么类型的值。共享类的值也共享行为。例如，整数1和2都是int类的实例。这两个值可以进行类似的处理。例如，它们都可以被求反或添加到另一个整数。内置的type函数允许我们检查包含任何值的类。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">2</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>到目前为止，我们使用的值都是Python语言中内置的少数原生数据类型的实例。原生数据类型具有以下属性：</p><ul><li>  1.有些表达式的计算结果是原生类型的值，称为==字面量==。</li><li>  2.有一些内置函数和操作符来操作原生类型的值。</li></ul><p>int类是用来表示整数的原生数据类型。整型字面值(相邻数字序列)计算为整型值，数学运算符操作这些值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12</span> + <span class="number">3000000000000000000000000</span></span><br><span class="line"><span class="number">3000000000000000000000012</span></span><br></pre></td></tr></tbody></table></figure><p>Python包含三种原生数字类型:==整数(int)、浮点数(float)和复数(complex)。==</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1.5</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'float'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>+<span class="number">1j</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'complex'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>浮点数。</strong> float这个名字来自于Python和许多其他编程语言中实数的表示方式:“==浮点”==表示。 虽然数字如何表示的细节不是本文的主题，但了解int和float对象之间的一些高级区别是很重要的。 特别是，==int对象精确地表示整数==，没有任何近似值或对其大小的限制。 另一方面，浮动对象可以表示范围很广的小数，但==并不是所有的数字都可以精确地表示==，==有最小值和最大值==。 因此，浮点数应该被看作是实数的近似值。 这些近似的精确度是有限的。 组合浮点值会导致近似误差; 如果不是为了近似，下面的两个表达式都将计算为7。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> / <span class="number">3</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">3</span> * <span class="number">7</span> * <span class="number">3</span></span><br><span class="line"><span class="number">6.999999999999999</span></span><br></pre></td></tr></tbody></table></figure><p>虽然上面合并了整型值，但一个整型除以另一个整型会得到一个浮点值：两个整型除以的实际比率的截断有限近似值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'float'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="number">0.3333333333333333</span></span><br></pre></td></tr></tbody></table></figure><p>当我们进行等式检验时，这种近似的问题就出现了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span> == <span class="number">0.333333333333333312345</span> <span class="comment"># Beware of float approximation</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>int和float类之间的这些细微差别对编写程序有广泛的影响，因此程序员必须记住这些细节。 幸运的是，只有少数几种本机数据类型，这就限制了精通一门编程语言所需的记忆量。 此外，这些相同的细节在许多编程语言中都是一致的，由<a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754浮点标准</a>等社区指南强制执行。</p><p><strong>非数字类型。</strong> 值可以表示许多其他类型的数据，比如声音、图像、位置、web地址、网络连接等等。 少数是用本地数据类型表示的，例如bool类用于值True和False。 大多数值的类型必须由程序员使用，我们将在本章中开发的组合和抽象方法来定义。</p><p>下面几节将更多地介绍Python的原生数据类型，重点介绍它们在创建有用的数据抽象中所扮演的角色。 对于那些对进一步细节感兴趣的人，在线书籍<a href="http://getpython3.com/diveintopython3/native-datatypes.html">Dive Into Python 3</a>中关于原生数据类型的一章给出了所有Python原生数据类型以及如何操作它们的实用概述，包括大量的使用示例和实用技巧。</p><h3 id="2-2-数据抽象"><a href="#2-2-数据抽象" class="headerlink" title="2.2 数据抽象"></a>2.2 数据抽象</h3><p>当我们考虑世界上我们想要在程序中表示的大量事物时，我们发现它们中的大多数都有复合结构。 例如，地理位置包含纬度和经度坐标。 为了表示位置，我们希望我们的编程语言能够将纬度和经度结合在一起形成一对，这是一个复合数据值，我们的程序可以将其作为单个概念单元进行操作，但它也有两个可以单独考虑的部分。</p><p>==复合数据的使用使我们能够增加程序的模块化==。 如果我们可以将地理位置作为整体值来操作，那么我们就可以将程序中使用位置计算的部分从这些位置如何表示的细节中屏蔽掉。 将处理数据如何表示的程序部分与处理数据如何操作的程序部分隔离开来的通用技术是一种强大的设计方法论，称为数据抽象。 ==数据抽象使程序更容易设计、维护和修改==。</p><p>数据抽象在性质上与功能抽象相似。 当我们创建一个函数抽象时，函数如何实现的细节可以被抑制，并且特定的函数本身可以被具有相同总体行为的任何其他函数所替代。 换句话说，==我们可以进行抽象，将函数的使用方式与函数如何实现的细节分离开来。== 类似地，数据抽象将如何使用复合数据值与如何构造复合数据值的细节分离开来。</p><p>==数据抽象的基本思想是对程序进行结构化==，以便它们能够对抽象数据进行操作。 也就是说，我们的程序应该以这样一种方式使用数据，即尽可能少地对数据做出假设。 同时，一个具体的数据表示被定义为程序的独立部分。</p><p>程序的这两个部分，==操作抽象数据的部分和定义具体表示的部分，由一组根据具体表示实现抽象数据的函数连接起来。== 为了说明这种技术，我们将考虑如何设计一组用于处理有理数的函数。</p><h4 id="2-2-1-示例-有理数"><a href="#2-2-1-示例-有理数" class="headerlink" title="2.2.1 示例:有理数"></a>2.2.1 示例:<a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.1-shi-li-you-li-shu">有理数</a></h4><p>有理数是整数的比率，有理数是实数的一个重要子类。有理数，如1/3或17/29通常写成：<code>&lt;numerator&gt;/&lt;denominator&gt;</code><br>&lt;分子&gt;和&lt;分母&gt;都是整数值的占位符。这两部分都需要准确地描述有理数的值。实际上，整数的除法会产生一个浮点近似值，从而失去整数的精确精度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="number">0.3333333333333333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">3</span> == <span class="number">0.333333333333333300000</span> <span class="comment"># Dividing integers yields an approximation</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>然而，我们可以通过结合分子和分母来创建有理数的精确表示。</p><p>通过使用函数抽象，我们知道，在实现程序的某些部分之前，我们可以开始高效地编程。 让我们先假设我们已经有了一种从分子和分母构造有理数的方法。 我们还假设，给定一个有理数，我们有一种选择其分子和分母成分的方法。 让我们进一步假设构造函数和选择器可以使用以下三个函数：</p><ul><li>  1.rational(n, d)返回分子n、分母d的有理数。</li><li>  2.number (x)返回有理数x的分子。</li><li>3.denom(x)返回有理数x的分母。</li></ul><p>==我们在这里使用的是一个设计程序的强大策略：一厢情愿== 我们还没有阐述一个有理数是如何表示的，或者numer, denom, rational函数是如何实现的。即便如此，如果我们确实定义了这三个函数，我们就可以进行加法、乘法、打印和测试有理数是否相等：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    nx, dx = numer(x), denom(x)</span><br><span class="line">    ny, dy = numer(y), denom(y)</span><br><span class="line">    <span class="keyword">return</span> rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mul_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> rational(numer(x) * numer(y), denom(x) * denom(y))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(numer(x), <span class="string">'/'</span>, denom(x))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rationals_are_equal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> numer(x) * denom(y) == numer(y) * denom(x)</span><br></pre></td></tr></tbody></table></figure><p>现在，我们已经根据选择器函数number和denom以及构造器函数rational定义了有理数的操作，但我们还没有定义这些函数。我们需要的是一种把分子和分母结合成复合值的方法。</p><h4 id="2-2-2-复合结构"><a href="#2-2-2-复合结构" class="headerlink" title="2.2.2 复合结构"></a>2.2.2 <a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.2-dui">复合结构</a></h4><p>为了使我们能够实现数据抽象的具体级别，Python提供了一个称为列表的复合结构，可以通过将表达式放在用逗号分隔的方括号中来构造。这样的表达式称为列表字面量。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = pair</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>访问列表中元素的第二种方法是通过元素选择操作符，也使用方括号表示。与列表文字不同，直接跟在另一个表达式后面的方括号表达式并不求值为列表值，而是从前一个表达式的值中选择元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair[<span class="number">0</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair[<span class="number">1</span>]</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>Python中的列表(以及大多数其他编程语言中的序列)是0索引的，这意味着索引0选择第一个元素，索引1选择第二个元素，以此类推。支持这种索引约定的一种直观感觉是，索引表示元素从列表开始的偏移量。</p><p>元素选择操作符的等效函数称为getitem，它还使用0索引位置从列表中选择元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> getitem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getitem(pair, <span class="number">0</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getitem(pair, <span class="number">1</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>在Python中，双元素列表并不是表示对的唯一方法。将两个值捆绑成一个值的任何方式都可以被认为是一对。列表是一种常见的方法。列表也可以包含两个以上的元素，我们将在本章后面讨论。</p><p><strong>表示有理数。</strong>我们现在可以用一对整数表示一个有理数：一个分子和一个分母。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>): </span><br><span class="line">    <span class="keyword">return</span> [n, d]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">numer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">denom</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><p>再加上我们前面定义的算术运算，我们可以用我们定义的函数来处理有理数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = rational(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(half)</span><br><span class="line"><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>third = rational(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(mul_rationals(half, third))</span><br><span class="line"><span class="number">1</span> / <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(add_rationals(third, third))</span><br><span class="line"><span class="number">6</span> / <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure><p>如上例所示，我们的有理数实现不会将有理数减少到最低项。我们可以通过改变rational的实现来弥补这个缺陷。如果我们有一个计算两个整数的最大公分母的函数，我们可以使用它在构造对之前将分子和分母降为最低项。与许多有用的工具一样，这样的函数已经存在于Python库中。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> gcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>):  </span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> (n//g, d//g)</span><br></pre></td></tr></tbody></table></figure><p>层除法运算符，//表示整数除法，它将除法结果的小数部分舍入。因为我们知道g能将n和d都整除，所以在这种情况下整数除法是正确的。这个修改过的rational实现确保了用最低的术语表达rational。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(add_rationals(third, third))</span><br><span class="line"><span class="number">2</span> / <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>这种改进是通过改变构造函数而不改变任何实现实际算术操作的函数来实现的。</p><h4 id="2-2-3-抽象障碍"><a href="#2-2-3-抽象障碍" class="headerlink" title="2.2.3 抽象障碍"></a>2.2.3 <a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.3-chou-xiang-de-zhang-ai">抽象障碍</a></h4><p>在继续讨论复合数据和数据抽象的更多示例之前，让我们考虑一下有理数示例所提出的一些问题。 我们用构造函数rational和选择器number和denom来定义操作。 一般来说，数据抽象的基本思想是识别一组基本的操作，根据这些操作，某种类型的值的所有操作都将被表示出来，然后在操作数据时只使用这些操作。 通过以这种方式限制操作的使用，在不改变程序行为的情况下更容易改变抽象数据的表示。</p><p>当程序的某个部分可以使用较高级别的函数而不是使用较低级别的函数时，就会发生抽象障碍冲突。例如，一个计算有理数平方的函数最好使用mul_rational来实现，它不假设任何关于有理数实现的事情。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_rational</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> mul_rational(x, x)</span><br></pre></td></tr></tbody></table></figure><p>直接引用分子和分母会违反一个抽象障碍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_rational_violating_once</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> rational(numer(x) * numer(x), denom(x) * denom(x))</span><br></pre></td></tr></tbody></table></figure><p>假设用两元素列表来表示有理数会违反两个抽象障碍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_rational_violating_twice</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> [x[<span class="number">0</span>] * x[<span class="number">0</span>], x[<span class="number">1</span>] * x[<span class="number">1</span>]]</span><br></pre></td></tr></tbody></table></figure><p>抽象障碍使程序更容易维护和修改。 依赖于特定表示的函数越少，当人们想要改变这种表示时，所需要的更改就越少。 square_rational的所有这些实现都有正确的行为，但只有第一个实现对未来的更改是健壮的。 即使我们改变了有理数的表示形式，square_rational函数也不需要更新。 相比之下，square_rational_violating_once在选择器或构造器签名发生更改时需要更改，而square_rational_violating_twice在有理数的实现发生更改时需要更新。</p><h4 id="2-2-4-数据属性"><a href="#2-2-4-数据属性" class="headerlink" title="2.2.4 数据属性"></a>2.2.4 <a href="https://zlt-shadow.gitbook.io/sicp-in-python-cn/di-2-zhang-shu-ju-gou-jian-chou-xiang/2.2-shu-ju-chou-xiang#2.2.4-shu-ju-shu-xing">数据属性</a></h4><p>抽象障碍塑造了我们思考数据的方式。 有理数的有效表示不受任何特定实现的限制(如双元素列表); 它是一个由rational返回的值，可以传递给number和denom。 此外，构造函数和选择器之间必须保持适当的关系。 也就是说，如果我们从整数n和d构造一个有理数x，那么number (x)/denom(x)等于n/d。</p><p>一般来说，我们可以使用选择器和构造器的集合，以及一些行为条件来表达抽象数据。 只要满足行为条件(如上面的分割属性)，选择器和构造器就构成了一种数据的有效表示。 抽象障碍下面的实现细节可能会改变，但如果行为没有改变，那么数据抽象仍然有效，使用该数据抽象编写的任何程序都将保持正确。</p><p>这个观点可以广泛地应用，包括我们用来实现有理数的对值。 实际上，我们从未详细说明什么是pair，只是说该语言提供了创建和操作带有两个元素的列表的方法。 我们需要实现pair的行为是将两个值粘合在一起。 作为一种行为条件，</p><ul><li>  如果由值x和y构造一对p，则select(p, 0)返回x, select(p, 1)返回y。</li></ul><p>我们实际上并不需要list类型来创建pair。相反，我们可以实现两个函数pair和select来满足这个描述，就像实现一个两个元素的列表一样。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pair</span>(<span class="params">x, y</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">"""Return a function that represents a pair."""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> get</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">p, i</span>):</span><br><span class="line">    <span class="string">"""Return the element at index i of pair p."""</span></span><br><span class="line">        <span class="keyword">return</span> p(i)</span><br></pre></td></tr></tbody></table></figure><p>通过这个实现，我们可以创建和操作对。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = pair(<span class="number">20</span>, <span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select(p, <span class="number">0</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select(p, <span class="number">1</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></figure><p>这种高阶函数的使用与我们对数据应该是什么的直观概念完全不同。 然而，这些函数足以在程序中表示对。 函数足以表示复合数据。</p><p>展示pair的函数表示的意义并不在于Python实际上是这样工作的(出于效率原因，列表实现得更直接)，而是它可以这样工作。 函数表示虽然晦涩，但却是表示成对的一种完全合适的方式，因为它满足成对需要满足的唯一条件。 数据抽象的实践使我们能够轻松地在表示之间切换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在第一章集中讨论了计算过程和函数在程序设计中的作用。 我们了解了如何使用原始数据(数字)和原始操作(算术)，如何通过组合和控制来形成复合函数，以及如何通过给过程命名来创建函数抽象。 我们还发现，高阶函数增强了语言的能力，使我们能够根据通用的计算方法进行操作，从而进行推理。 这就是编程的精髓所在。&lt;/p&gt;
&lt;p&gt;本章的重点是数据。 我们在这里研究的技术将允许我们表示和操作许多不同领域的信息。 由于互联网的爆炸式增长，我们所有人都可以在网上免费获得大量的结构化信息，计算可以应用于各种各样的不同问题。 有效使用内置和用户定义的数据类型是数据处理应用程序的基础。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>功能抽象</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%8A%9F%E8%83%BD%E6%8A%BD%E8%B1%A1/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%8A%9F%E8%83%BD%E6%8A%BD%E8%B1%A1/</id>
    <published>2023-04-15T14:37:16.000Z</published>
    <updated>2023-04-15T06:38:19.831Z</updated>
    
    <content type="html"><![CDATA[<p>Every powerful language has three such mechanisms:</p><ul><li>  <strong>primitive expressions and statements</strong>, which represent the simplest building blocks that the language provides,</li><li>  <strong>means of combination</strong>, by which compound elements are built from simpler ones, and</li><li>  <strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.<br>data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.</li></ul><span id="more"></span><p>以下指南改编自<a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>，它可作为所有（非叛逆的）Python 程序员的指南。一组共享的约定使开发人员社区成员之间的沟通更加顺畅。作为遵循这些约定的副作用，您会发现您的代码在内部变得更加一致。</p><ol><li> 函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li><li> 函数名称通常会引起解释器应用于参数的操作（例如print、add、square）或产生的数量的名称（例如max、abs、sum）。</li><li> 参数名称是小写的，单词之间用下划线分隔。首选单字名称。</li><li> 参数名称应该唤起参数在函数中的作用，而不仅仅是允许的参数类型。</li><li> 当作用明显时，单字母参数名称是可以接受的，但要避免使用“l”（小写 ell）、“O”（大写 oh）或“I”（大写 i），以免与数字混淆。</li></ol><p>换句话说，函数定义应该能够抑制细节。函数的使用者可能并没有自己编写函数，而是可能作为“黑盒子”从另一个程序员那里得到的。程序员不需要知道函数是如何实现的就可以使用它。Python 库具有此属性。许多开发人员使用那里定义的函数，但很少有人检查他们的实现。</p><p><strong>功能抽象的各个方面</strong><br>要掌握功能抽象的使用，考虑其三个核心属性通常很有用。函数的&nbsp;_域(domain_是它可以接受的参数集。函数的_范围range_是它可以返回的值的集合。函数的_意图intent_是它计算输入和输出之间的关系（以及它可能产生的任何副作用）。通过领域、范围和意图理解功能抽象对于在复杂程序中正确使用它们至关重要。</p><p>例如，我们用来实现sum_squares的任何平方函数 都应该具有以下属性：</p><ul><li>  domain是任何单个实数。</li><li>  range是任何非负实数。</li><li>  intent是输出是输入的平方。</li></ul><p>这些==属性不指定意图是如何执行的==；这个细节被抽象掉了。</p><p>在除法方面，Python 提供了两个中缀运算符：/和&nbsp;//。前者是正常除法，因此即使除数平均除以被除数，它也会产生_浮点数或十进制值：_</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>  /  <span class="number">4</span> </span><br><span class="line"><span class="number">1.25</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span>  /  <span class="number">4</span> </span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></tbody></table></figure><p>另一方面，// 运算符将结果向下舍入为整数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>  //  <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>- <span class="number">5</span>  //  <span class="number">4</span> </span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>这两个运算符是truediv和floordiv&nbsp;函数的简写。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span>  operator  <span class="keyword">import</span>  truediv ,  floordiv </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>truediv ( <span class="number">5</span> ,  <span class="number">4</span> ) </span><br><span class="line"><span class="number">1.25</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floordiv ( <span class="number">5</span> ,  <span class="number">4</span> ) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>您应该在程序中随意使用中缀运算符和圆括号。对于简单的数学运算，惯用的 Python 更喜欢运算符而不是调用表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Every powerful language has three such mechanisms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;primitive expressions and statements&lt;/strong&gt;, which represent the simplest building blocks that the language provides,&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;means of combination&lt;/strong&gt;, by which compound elements are built from simpler ones, and&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;means of abstraction&lt;/strong&gt;, by which compound elements can be named and manipulated as units.&lt;br&gt;data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>链表初探</title>
    <link href="https://sajlle.github.io/2023/04/15/%E9%93%BE%E8%A1%A8%E5%88%9D%E6%8E%A2/"/>
    <id>https://sajlle.github.io/2023/04/15/%E9%93%BE%E8%A1%A8%E5%88%9D%E6%8E%A2/</id>
    <published>2023-04-15T14:34:11.000Z</published>
    <updated>2023-04-15T06:35:50.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表操作类型"><a href="#链表操作类型" class="headerlink" title="链表操作类型"></a>链表操作类型</h1><ul><li>添加第n个节点</li><li>删除第n个节点</li><li>删除头部节点</li><li>删除尾部节点</li><li>插入头部节点</li><li>插入尾部节点<span id="more"></span></li></ul><h1 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h1><h2 id="Linked-Lists"><a href="#Linked-Lists" class="headerlink" title="Linked Lists"></a>Linked Lists</h2><p>We’ve learned that a Python list is one way to store sequential values. Another type of list is a linked list. A Python list stores all of its elements in a single object, and each element can be accessed by using its index. A linked list, on the other hand, is a recursive object that only stores two things: its first value and a reference to the rest of the list, which is another linked list.</p><p>We can implement a class,&nbsp;<code>Link</code>, that represents a linked list object. Each instance of&nbsp;<code>Link</code>&nbsp;has two instance attributes,&nbsp;<code>first</code>&nbsp;and&nbsp;<code>rest</code>.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Link:</span><br><span class="line">    """A linked list.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; s = Link(1)</span><br><span class="line">    &gt;&gt;&gt; s.first</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; s.rest is Link.empty</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))</span><br><span class="line">    &gt;&gt;&gt; s.first = 5</span><br><span class="line">    &gt;&gt;&gt; s.rest.first = 6</span><br><span class="line">    &gt;&gt;&gt; s.rest.rest = Link.empty</span><br><span class="line">    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)</span><br><span class="line">    Link(5, Link(6))</span><br><span class="line">    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))</span><br><span class="line">    &gt;&gt;&gt; s</span><br><span class="line">    Link(5, Link(7, Link(Link(8, Link(9)))))</span><br><span class="line">    &gt;&gt;&gt; print(s)                             # Prints str(s)</span><br><span class="line">    &lt;5 7 &lt;8 9&gt;&gt;</span><br><span class="line">    """</span><br><span class="line">    empty = ()</span><br><span class="line"></span><br><span class="line">    def __init__(self, first, rest=empty):</span><br><span class="line">        assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">        self.first = first</span><br><span class="line">        self.rest = rest</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        if self.rest is not Link.empty:</span><br><span class="line">            rest_repr = ', ' + repr(self.rest)</span><br><span class="line">        else:</span><br><span class="line">            rest_repr = ''</span><br><span class="line">        return 'Link(' + repr(self.first) + rest_repr + ')'</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        string = '&lt;'</span><br><span class="line">        while self.rest is not Link.empty:</span><br><span class="line">            string += str(self.first) + ' '</span><br><span class="line">            self = self.rest</span><br><span class="line">        return string + str(self.first) + '&gt;'</span><br></pre></td></tr></tbody></table></figure><p>A valid linked list can be one of the following:</p><ol><li> An empty linked list (<code>Link.empty</code>)</li><li> A&nbsp;<code>Link</code>&nbsp;object containing the first value of the linked list and a reference to the rest of the linked list</li></ol><p>What makes a linked list recursive is that the&nbsp;<code>rest</code>&nbsp;attribute of a single&nbsp;<code>Link</code>&nbsp;instance is another linked list! In the big picture, each&nbsp;<code>Link</code>&nbsp;instance stores a single value of the list. When multiple&nbsp;<code>Link</code>s are linked together through each instance’s&nbsp;<code>rest</code>&nbsp;attribute, an entire sequence is formed.</p><blockquote><p><em>Note</em>: This definition means that the&nbsp;<code>rest</code>&nbsp;attribute of any&nbsp;<code>Link</code>&nbsp;instance&nbsp;<em>must</em>&nbsp;be either&nbsp;<code>Link.empty</code>&nbsp;or another&nbsp;<code>Link</code>&nbsp;instance! This is enforced in&nbsp;<code>Link.__init__</code>, which raises an&nbsp;<code>AssertionError</code>&nbsp;if the value passed in for&nbsp;<code>rest</code>&nbsp;is neither of these things.</p></blockquote><p>To check if a linked list is empty, compare it against the class attribute&nbsp;<code>Link.empty</code>. For example, the function below prints out whether or not the link it is handed is empty:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_empty(link):</span><br><span class="line">    if link is Link.empty:</span><br><span class="line">        print('This linked list is empty!')</span><br><span class="line">    else:</span><br><span class="line">        print('This linked list is not empty!')</span><br></pre></td></tr></tbody></table></figure><h1 id="链表题目"><a href="#链表题目" class="headerlink" title="链表题目"></a>链表题目</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store_digits</span>(<span class="params">n</span>): </span><br><span class="line"><span class="string">"""Stores the digits of a positive number n in a linked list. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s = store_digits(1) </span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s </span></span><br><span class="line"><span class="string">Link(1) </span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>store_digits(2345) </span></span><br><span class="line"><span class="string">Link(2, Link(3, Link(4, Link(5)))) </span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>store_digits(876) </span></span><br><span class="line"><span class="string">Link(8, Link(7, Link(6)))</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line">res = Link.empty</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">res = Link(n%<span class="number">10</span>,res)</span><br><span class="line">n = n//<span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h3 id="Q2-Convert-Link"><a href="#Q2-Convert-Link" class="headerlink" title="Q2: Convert Link"></a>Q2: Convert Link</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_link</span>(<span class="params">link</span>):</span><br><span class="line">    <span class="string">"""Takes a linked list and returns a Python list with the same elements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; link = Link(1, Link(2, Link(3, Link(4))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; convert_link(link)</span></span><br><span class="line"><span class="string">    [1, 2, 3, 4]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; convert_link(Link.empty)</span></span><br><span class="line"><span class="string">    []</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">while</span> link != Link.empty:</span><br><span class="line">    s.append(link.first)</span><br><span class="line">    link = link.rest</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Q3-Every-Other"><a href="#Q3-Every-Other" class="headerlink" title="Q3: Every Other"></a>Q3: Every Other</h3><p>Implement&nbsp;<code>every_other</code>, which takes a linked list&nbsp;<code>s</code>. It mutates&nbsp;<code>s</code>&nbsp;such that all of the odd-indexed elements (using 0-based indexing) are removed from the list. For example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="string">'a'</span>, Link(<span class="string">'b'</span>, Link(<span class="string">'c'</span>, Link(<span class="string">'d'</span>))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>every_other(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.first</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest.first</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest.rest <span class="keyword">is</span> Link.empty</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>If&nbsp;<code>s</code>&nbsp;contains fewer than two elements,&nbsp;<code>s</code>&nbsp;remains unchanged.<br>Do not return anything!&nbsp;<code>every_other</code>&nbsp;should mutate the original list.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">every_other</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""Mutates a linked list so that all the odd-indiced elements are removed</span></span><br><span class="line"><span class="string">    (using 0-based indexing).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link(4))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; every_other(s)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Link(1, Link(3))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; odd_length = Link(5, Link(3, Link(1)))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; every_other(odd_length)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; odd_length</span></span><br><span class="line"><span class="string">    Link(5, Link(1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; singleton = Link(4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; every_other(singleton)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; singleton</span></span><br><span class="line"><span class="string">    Link(4)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">is</span> Link.empty <span class="keyword">or</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">s.rest = s.rest.rest</span><br><span class="line">every_other(s.rest)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;链表操作类型&quot;&gt;&lt;a href=&quot;#链表操作类型&quot; class=&quot;headerlink&quot; title=&quot;链表操作类型&quot;&gt;&lt;/a&gt;链表操作类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;添加第n个节点&lt;/li&gt;
&lt;li&gt;删除第n个节点&lt;/li&gt;
&lt;li&gt;删除头部节点&lt;/li&gt;
&lt;li&gt;删除尾部节点&lt;/li&gt;
&lt;li&gt;插入头部节点&lt;/li&gt;
&lt;li&gt;插入尾部节点&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构" scheme="https://sajlle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://sajlle.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>递归初探</title>
    <link href="https://sajlle.github.io/2023/04/15/%E9%80%92%E5%BD%92%E5%88%9D%E6%8E%A2/"/>
    <id>https://sajlle.github.io/2023/04/15/%E9%80%92%E5%BD%92%E5%88%9D%E6%8E%A2/</id>
    <published>2023-04-15T14:31:24.000Z</published>
    <updated>2023-04-15T07:28:15.770Z</updated>
    
    <content type="html"><![CDATA[<p>在许多递归函数体中可以找到一个常见的模式。 主体以基本情况开始，这是一个条件语句，它定义了对于最容易处理的输入函数的行为。 在sum_digits的情况下，基本情况是任何单个数字参数，我们只需返回该参数。有些递归函数会有多个基本情况。</p><p>基本用例之后是一个或多个递归调用。 递归调用总是有一个特定的特征:它们简化了原来的问题。 递归函数通过增量地简化问题来表示计算。 例如，7的数字加起来比73的数字加起来简单，73的数字加起来又比738的数字加起来简单。 对于每一个后续调用，需要完成的工作就更少了。</p><span id="more"></span><p>以阶乘函数为例子，例如fact(4)计算4! =4x3x2x1=24。<br>如果使用while循环，则从最小值开始乘到给定值，使用递归则从给定值乘到1。n! = nx(n-1)……1<br>我们不应该关心fact(n-1)在fact主体中是如何实现的; 我们应该相信它计算的是n-1的阶乘。<br>我们根据函数本身来定义函数，但只是在验证函数的正确性时相信更简单的情况将正确工作。</p><p>迭代函数必须保持一些在整个计算过程中变化的局部状态。 在迭代的任何点上，该状态描述了已完成工作的结果和剩余工作量。</p><h2 id="相互递归"><a href="#相互递归" class="headerlink" title="相互递归"></a>相互递归</h2><p>递归过程被两个相互调用的函数分割时，这些函数称为相互递归。<br>当递归过程被两个相互调用的函数分割时，这些函数称为相互递归。作为例子，考虑以下非负整数的偶数和奇数的定义：</p><ul><li>  一个数比奇数多一，它就是偶数</li><li>  一个数比偶数多一，它就是奇数</li><li>  0是偶数</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:  <span class="comment"># 先写最简单的情况</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> is_odd(n-<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> is_even(n-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>可将<code>is_odd</code>合并到<code>is_even</code>中，如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> n-<span class="number">1</span> == <span class="number">0</span>:  <span class="comment"># 把is_odd中的n替换为n-1，因为is_even传给is_odd的实参是n-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> is_even((n-<span class="number">1</span>)-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="递归函数中的打印"><a href="#递归函数中的打印" class="headerlink" title="递归函数中的打印"></a>递归函数中的打印</h2><p>递归函数演进的计算过程通常可以通过调用print来可视化。例如：我们将实现一个函数cascade，它从最大到最小到最大打印一个数字的所有前缀。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cascade</span>(<span class="params">n</span>):</span><br><span class="line"><span class="string">"""Print a cascade of prefixes of n. """</span></span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">cascade(n//<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cascade(<span class="number">2013</span>)</span><br><span class="line"><span class="number">2013</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">2013</span></span><br></pre></td></tr></tbody></table></figure><p>也可简化一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cascade</span>(<span class="params">n</span>):</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">10</span>:</span><br><span class="line">cascade(n//<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></tbody></table></figure><p>相互递归案例2：<br>有n个初始鹅卵石的双人博弈。玩家轮流从桌子上拿走一颗或两颗石子，拿走最后一颗石子的玩家获胜。假设Alice和Bob玩这个游戏，每人都使用一个简单的策略：</p><ul><li>  Alice总是拿走一块石子</li><li>  如果桌子上有偶数个石子，Bob拿走两个石子，否则拿走一个石子</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">alice</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Bob wins'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> bob(n-<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bob</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Alice wins'</span>)</span><br><span class="line"><span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> alice(n-<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> alice(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice(<span class="number">20</span>)</span><br><span class="line">Bob wins</span><br></pre></td></tr></tbody></table></figure><h2 id="树递归"><a href="#树递归" class="headerlink" title="树递归"></a>树递归</h2><p>在树递归中，一个函数多次调用自己。考虑计算<a href="http://composingprograms.com/tutor.html#code=def+fib(n)%3A%0A++++if+n+%3D%3D+1%3A%0A++++++++return+0%0A++++if+n+%3D%3D+2%3A%0A++++++++return+1%0A++++else%3A%0A++++++++return+fib(n-2)+%2B+fib(n-1)%0A%0Aresult+%3D+fib(6)">斐波那契数列</a>，其中每个数字都是前面两个数字的和。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line"><span class="string">"""返回斐波那契数列中第n个数字的值"""</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">6</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h3 id="案例：自然数分区"><a href="#案例：自然数分区" class="headerlink" title="案例：自然数分区"></a>案例：自然数分区</h3><ul><li>啥是<a href="https://ja.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0%E3%81%AE%E5%88%86%E5%89%B2">自然数分区</a>？<ul><li>将给定<strong>的</strong>正整数n<strong>划分</strong>为正整数。</li><li>例如，4的分区是：<ol><li>4</li><li>3+1</li><li>2+2</li><li>2+1+1</li><li>1+1+1+1</li></ol></li><li>8的分区是：<ol><li> 8</li><li> 7 + 1</li><li> 6 + 2</li><li> 6 + 1 + 1</li><li> 5 + 3</li><li> 5 + 2 + 1</li><li> 5 + 1 + 1 + 1</li><li> 4 + 4</li><li> 4 + 3 + 1</li><li> 4 + 2 + 2</li><li> 4 + 2 + 1 + 1</li><li> 4 + 1 + 1 + 1 + 1</li><li> 3 + 3 + 2</li><li> 3 + 3 + 1 + 1</li><li> 3 + 2 + 2 + 1</li><li> 3 + 2 + 1 + 1 + 1</li><li> 3 + 1 + 1 + 1 + 1 + 1</li><li> 2 + 2 + 2 + 2</li><li> 2 + 2 + 2 + 1 + 1</li><li> 2 + 2 + 1 + 1 + 1 + 1</li><li> 2 + 1 + 1 + 1 + 1 + 1 + 1</li><li> 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1<br>有限分区：</li></ol></li></ul></li><li>筛掉包含重复数字的分区<ul><li>案例，8的有限分区是：<ul><li>  8</li><li>  7 + 1</li><li>  6 + 2</li><li>  5 + 3</li><li>  5 + 2 + 1</li><li>  4 + 3 + 1</li></ul></li></ul></li><li>奇数分区：<ul><li>案例，8的奇数分区是：<ul><li>  7 + 1</li><li>  5 + 3</li><li>  5 + 1 + 1 + 1</li><li>  3 + 3 + 1 + 1</li><li>  3 + 1 + 1 + 1 + 1 + 1</li><li>  1 + 1 + 1 + 1 + 1 + 1 + 1 + 1</li></ul></li></ul></li></ul><p>We will define a function&nbsp;count_partitions(n, m)&nbsp;that returns the number of different partitions of&nbsp;n&nbsp;using parts up to&nbsp;m. This function has a simple solution as a tree-recursive function, based on the following observation:</p><p>The number of ways to partition&nbsp;n&nbsp;using integers up to&nbsp;m&nbsp;equals</p><ol><li> the number of ways to partition&nbsp;n-m&nbsp;using integers up to&nbsp;m, and</li><li> the number of ways to partition&nbsp;n&nbsp;using integers up to&nbsp;m-1.</li></ol><p>To see why this is true, observe that all the ways of partitioning&nbsp;n&nbsp;can be divided into two groups: those that include at least one&nbsp;m&nbsp;and those that do not. Moreover, each partition in the first group is a partition of&nbsp;n-m, followed by&nbsp;m&nbsp;added at the end. In the example above, the first two partitions contain 4, and the rest do not.</p><p>Therefore, we can recursively reduce the problem of partitioning&nbsp;n&nbsp;using integers up to&nbsp;m&nbsp;into two simpler problems: (1) partition a smaller number&nbsp;n-m, and (2) partition with smaller components up to&nbsp;m-1.</p><p>To complete the implementation, we need to specify the following base cases:</p><ol><li> There is one way to partition 0: include no parts.</li><li> There are 0 ways to partition a negative&nbsp;n.</li><li> There are 0 ways to partition any&nbsp;n&nbsp;greater than 0 using parts of size 0 or less.<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_partitions</span>(<span class="params">n,m</span>):</span><br><span class="line"><span class="string">"""Count the ways to partition n using parts to m"""</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> n &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> m == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> count_partitions(n-m,m)+count_partitions(n,m-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在许多递归函数体中可以找到一个常见的模式。 主体以基本情况开始，这是一个条件语句，它定义了对于最容易处理的输入函数的行为。 在sum_digits的情况下，基本情况是任何单个数字参数，我们只需返回该参数。有些递归函数会有多个基本情况。&lt;/p&gt;
&lt;p&gt;基本用例之后是一个或多个递归调用。 递归调用总是有一个特定的特征:它们简化了原来的问题。 递归函数通过增量地简化问题来表示计算。 例如，7的数字加起来比73的数字加起来简单，73的数字加起来又比738的数字加起来简单。 对于每一个后续调用，需要完成的工作就更少了。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构" scheme="https://sajlle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="递归" scheme="https://sajlle.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>报错信息</title>
    <link href="https://sajlle.github.io/2023/04/15/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/"/>
    <id>https://sajlle.github.io/2023/04/15/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/</id>
    <published>2023-04-15T14:10:59.000Z</published>
    <updated>2023-04-15T06:18:32.090Z</updated>
    
    <content type="html"><![CDATA[<p>编程时，学会读取报错信息也是必要的。</p><span id="more"></span><p>Instance: </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last): </span><br><span class="line">File <span class="string">"&lt;pyshell#29&gt;"</span>, line <span class="number">3</span> <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">result = buggy(<span class="number">5</span>) </span><br><span class="line">File <span class="string">"&lt;pyshell#29&gt;"</span>, line <span class="number">5</span> <span class="keyword">in</span> buggy </span><br><span class="line"><span class="keyword">return</span> f + x </span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">'function'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Format"><a href="#Format" class="headerlink" title="Format:"></a>Format:</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"&lt;file name&gt;"</span>, line &lt;number&gt;, <span class="keyword">in</span> &lt;function&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>  <strong>File name</strong>: the name of the file that contains the problem.</li><li>  <strong>Number</strong>: the line number in the file that caused the problem, or the line number that contains the next function call</li><li>  <strong>Function</strong>: the name of the function in which the line can be found.<br>The&nbsp;<strong>second</strong>&nbsp;line in the pair (it’s indented farther in than the first) displays the actual line of code that makes the&nbsp;<em>next</em>&nbsp;function call. This gives you a quick look at what arguments were passed into the function, in what context the function was being used, etc.<br>Finally, remember that the traceback is organized with the “<strong>most recent call last.</strong>“</li></ul><h3 id="Error-Messages"><a href="#Error-Messages" class="headerlink" title="Error Messages"></a>Error Messages</h3><ul><li>The very last line in the traceback message is the error statement. An&nbsp;<em>error statement</em>&nbsp;has the following format:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;error <span class="built_in">type</span>&gt;: &lt;error message&gt;</span><br></pre></td></tr></tbody></table></figure></li><li>  <strong>Error type</strong>: the type of error that was caused (e.g.&nbsp;<code>SyntaxError</code>,&nbsp;<code>TypeError</code>). These are usually <strong>descriptive enough</strong> to help you narrow down your search for the cause of error.</li><li>  <strong>Error message</strong>: a <strong>more detailed description</strong> of exactly what caused the error. Different error types produce different error messages.</li></ul><h3 id="Debugging-Techniques"><a href="#Debugging-Techniques" class="headerlink" title="Debugging Techniques"></a>Debugging Techniques</h3><h4 id="Running-doctests"><a href="#Running-doctests" class="headerlink" title="Running doctests"></a>Running doctests</h4><p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>): </span><br><span class="line"><span class="string">"""A random function. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &gt;&gt;&gt;foo(4) </span></span><br><span class="line"><span class="string"> 4 </span></span><br><span class="line"><span class="string"> &gt;&gt;&gt; foo(5) </span></span><br><span class="line"><span class="string"> 5  </span></span><br><span class="line"><span class="string"> """</span></span><br></pre></td></tr></tbody></table></figure><p>The lines in the docstring that look like interpreter outputs are the&nbsp;<strong>doctests</strong>. To run them, go to your terminal and type:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></tbody></table></figure><p>This effectively loads your file into the Python interpreter, and checks to see if each doctest input (e.g.&nbsp;<code>foo(4)</code>) is the same as the specified output (e.g.&nbsp;<code>4</code>). If it isn’t, a message will tell you which doctests you failed.</p><p>The command line tool has a&nbsp;<code>-v</code>&nbsp;option that stands for&nbsp;<em>verbose</em>.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br></pre></td></tr></tbody></table></figure><p>In addition to telling you which doctests you failed, it will also ==tell you which doctests passed==.</p><h4 id="Writing-your-own-tests"><a href="#Writing-your-own-tests" class="headerlink" title="Writing your own tests"></a>Writing your own tests</h4><p>Some advice in writing tests:</p><ul><li>  <strong>Write some tests before you write code</strong>: this is called test-driven development. Writing down how you expect the function to behave first – this can guide you when writing the actual code.</li><li>  <strong>Write more tests after you write code</strong>: once you are sure your code passes the initial doctests, write some more tests to take care of edge cases.</li><li>  <strong>Test edge cases</strong>: make sure your code works for all special cases.</li></ul><h4 id="Using-print-statements"><a href="#Using-print-statements" class="headerlink" title="Using&nbsp;print&nbsp;statements"></a>Using&nbsp;<code>print</code>&nbsp;statements</h4><p>Once the doctests tell you where the error is, you have to figure what went wrong. If the doctest gave you a traceback message, look at what&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61a/fa20/articles/debugging.html#error-types">type of error</a>&nbsp;it is to help narrow your search. Also check that you aren’t making any&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61a/fa20/articles/debugging.html#common-bugs">common mistakes</a>.</p><p>When you first learn how to program, it can be hard to spot bugs in your code. One common practice is to add&nbsp;<code>print</code>&nbsp;statements.</p><p>Some advice:</p><ul><li>  Don’t just print out a variable – ==add some sort of message to make it easier for you to read:==<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(tmp) <span class="comment"># harder to keep track </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'DEBUG: tmp was this:'</span>, tmp) <span class="comment"># easier</span></span><br></pre></td></tr></tbody></table></figure></li><li>  Use&nbsp;<code>print</code>&nbsp;statements to view the results of function calls (i.e. after function calls).</li><li>  Use&nbsp;<code>print</code>&nbsp;statements at the end of a&nbsp;<code>while</code>&nbsp;loop to view the state of the counter variables after each iteration:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> i &lt; n: </span><br><span class="line">i += func(i) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">'DEBUG: i is'</span>, i)</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="Long-term-debugging"><a href="#Long-term-debugging" class="headerlink" title="Long-term debugging"></a>Long-term debugging</h5><p>The&nbsp;<code>print</code>&nbsp;statements described above are meant for <em><strong>quick debugging of one-time errors</strong></em> – after figuring out the error, you would remove all the&nbsp;<code>print</code>&nbsp;statements.</p><p>However, sometimes we would like to leave the debugging code if we need to periodically test our file. It can get kind of annoying if every time we run our file, debugging messages pop up. One way to avoid this is to use a global&nbsp;<code>debug</code>&nbsp;variable:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">debug = <span class="literal">True</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">n</span>): </span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> i &lt; n: </span><br><span class="line">i += func(i) </span><br><span class="line"><span class="keyword">if</span> debug: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">'DEBUG: i is'</span>, i)</span><br></pre></td></tr></tbody></table></figure><p>Now, whenever we want to do some debugging, we can set the global&nbsp;<code>debug</code>&nbsp;variable to&nbsp;<code>True</code>, and ==when we don’t want to see any debugging input, we can turn it to==&nbsp;<code>False</code>&nbsp;(such a variable is called a <em><strong>“flag”</strong></em>).</p><h4 id="Interactive-Debugging"><a href="#Interactive-Debugging" class="headerlink" title="Interactive Debugging"></a>Interactive Debugging</h4><p>One way a lot of programmers like to investigate their code is by use of an interactive <strong>REPL</strong>.. That is, a terminal where you can directly run functions and inspect their outputs.<br>Typically, to accomplish this, you can run</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></tbody></table></figure><p>and one then has a session of python where all the definitions of&nbsp;<code>file.py</code>&nbsp;have already been executed.<br>If you are using the&nbsp;<code>ok</code>&nbsp;autograder, it has a specific tool that enables you to jump into the middle of a failing test case. Just run</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ok -q &lt;question name&gt; -i</span><br></pre></td></tr></tbody></table></figure><p>and if you have a failing test case for that question, the setup code and doctest will be printed on the screen and run, and you will then have access to a terminal where you can execute commands related to the program.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ok -q &lt;question name&gt; --trace</span><br></pre></td></tr></tbody></table></figure><p>and a browser window should open up with your code.</p><h4 id="Using-assert-statements"><a href="#Using-assert-statements" class="headerlink" title="Using&nbsp;assert&nbsp;statements"></a>Using&nbsp;<code>assert</code>&nbsp;statements</h4><p>A key principle in software development is tha==<strong>t it is generally better for code to crash than produce an incorrect result,</strong>== and having asserts in your code makes it far more likely that your code will crash if it has a bug in it.</p><h3 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h3><h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><ul><li>  <strong>Cause</strong>: code syntax mistake</li><li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  File <span class="string">"file name"</span>, line number</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incorrect</span>(<span class="params">f</span>)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure></li><li>  <strong>Solution</strong>: the&nbsp;<code>^</code>&nbsp;symbol points to the code that contains invalid syntax. <mark style="background: #FF5582A6;">The error message doesn’t tell you&nbsp;<em>what</em>&nbsp;is wrong, but it does tell you&nbsp;<em>where</em>.</mark></li><li>  <strong>Notes</strong>: Python will check for&nbsp;<code>SyntaxErrors</code>&nbsp;<mark style="background: #FF5582A6;">before executing any code</mark>. This is different from other errors, which are only raised during runtime</li></ul><h4 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a><code>IndentationError</code></h4><ul><li>  <strong>Cause</strong>: improper indentation</li><li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  File <span class="string">"file name"</span>, line number</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'improper indentation'</span>)</span><br><span class="line">IndentationError: unindent does <span class="keyword">not</span> <span class="keyword">match</span> <span class="built_in">any</span> outer indentation level</span><br></pre></td></tr></tbody></table></figure></li><li>  <strong>Solution</strong>: The line that is improperly indented is displayed. ==Simply re-indent it==.</li><li>  <strong>Notes</strong>: If you are inconsistent with tabs and spaces, Python will raise one of these. <strong>Make sure you use spaces!</strong> (It’s just less of a headache in general in Python to use spaces and all cs61a content uses spaces).</li></ul><hr><h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a><code>TypeError</code></h3><ul><li><strong>Cause 1</strong>:<ul><li>  ==Invalid operand types== for primitive operators. You are probably trying to add/subract/multiply/divide incompatible types.</li><li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">'function'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><strong>Cause 2</strong>:<ul><li>  Using ==non-function objects== in function calls.</li><li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'int'</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><strong>Cause 3</strong>:<ul><li>  Passing an incorrect number of arguments to a function.</li><li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected <span class="number">2</span> arguments, got <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="NameError"><a href="#NameError" class="headerlink" title="NameError"></a><code>NameError</code></h3><ul><li><p>  <strong>Cause</strong>: variable not assigned(赋值) to anything OR it doesn’t exist. ==This includes function names==.</p></li><li><p><strong>Example</strong>:</p>  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line number</span><br><span class="line">  y = x + <span class="number">3</span></span><br><span class="line">NameError: <span class="keyword">global</span> name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></tbody></table></figure></li><li><p>  <strong>Solution</strong>: Make sure you are <strong>initializing the variable</strong> (i.e. assigning the variable to a value) before you use it.</p></li><li><p>  <strong>Notes</strong>: The reason the error message says “global name” is because Python will start searching for the variable from a function’s local frame. If the variable is not found there, Python will keep searching the parent frames until it reaches the global frame. If it still can’t find the variable, Python raises the error.</p></li></ul><h3 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a><code>IndexError</code></h3><ul><li>  <strong>Cause</strong>: trying to index(索引) a sequence（序列） (e.g. a tuple（元组）, list, string) with a number that exceeds（超过，胜过） the size of the sequence.</li><li><strong>Example</strong>:  <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line number</span><br><span class="line">  x[<span class="number">100</span>]</span><br><span class="line">IndexError: <span class="built_in">tuple</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></tbody></table></figure></li><li>  <strong>Solution</strong>: Make sure the index is within the bounds(边界) of the sequence. If you’re using a variable as an index (e.g.&nbsp;<code>seq[x]</code>, make sure the variable is assigned to a proper index.</li></ul><h2 id="Common-Bugs"><a href="#Common-Bugs" class="headerlink" title="Common Bugs"></a>Common Bugs</h2><h3 id="Spelling"><a href="#Spelling" class="headerlink" title="Spelling"></a>Spelling</h3><p>Python is&nbsp;<em><strong>case sensitive</strong></em>. The variable&nbsp;<code>hello</code>&nbsp;is not the same as&nbsp;<code>Hello</code>&nbsp;or&nbsp;<code>hello</code>&nbsp;or&nbsp;<code>helo</code>. This will usually show up as a&nbsp;<code>NameError</code>, but sometimes misspelled variables will actually have been defined. In that case, it can be difficult to find errors, and it is never gratifying to discover it’s just a spelling mistake.</p><h3 id="Missing-Parentheses"><a href="#Missing-Parentheses" class="headerlink" title="Missing Parentheses"></a>Missing Parentheses</h3><p>A common bug is to leave off the closing parenthesis. This will show up as a&nbsp;<code>SyntaxError</code>. Consider the following code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">return</span> foo(bar()   <span class="comment"># missing a parenthesis here</span></span><br><span class="line"></span><br><span class="line">fun()</span><br></pre></td></tr></tbody></table></figure><p>==Python will raise a&nbsp;<code>SyntaxError</code>, but will point to the line&nbsp;<em>after</em>&nbsp;the missing parenthesis:==</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line <span class="string">"number"</span></span><br><span class="line">    fun()</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure><p>In general, if Python points a&nbsp;<code>SyntaxError</code>&nbsp;to a seemingly correct line, you are probably forgetting a parenthesis somewhere.</p><h3 id="Missing-close-quotes（引号）"><a href="#Missing-close-quotes（引号）" class="headerlink" title="Missing close quotes（引号）"></a>Missing close quotes（引号）</h3><p>This is similar to the previous bug, but much easier to catch. Python will actually tell you the line that is missing the <strong>quote</strong>:(引号)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"file name"</span>, line <span class="string">"number"</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi</span></span><br><span class="line"><span class="string">           ^</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></tbody></table></figure><p><code>EOL</code>&nbsp;stands for “<strong>==End of Line==</strong>.”</p><h3 id="vs"><a href="#vs" class="headerlink" title="=&nbsp;vs.&nbsp;=="></a><code>=</code>&nbsp;vs.&nbsp;<code>==</code></h3><p>The single equal sign&nbsp;<code>=</code>&nbsp;is used for&nbsp;<em>assignment</em>; the double equal sign&nbsp;<code>==</code>&nbsp;is used for testing equivalence. The most common error of this form is something like:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x = <span class="number">3</span>:</span><br></pre></td></tr></tbody></table></figure><h3 id="Infinite-Loops"><a href="#Infinite-Loops" class="headerlink" title="Infinite Loops"></a>Infinite Loops</h3><p>Infinite loops are often caused by&nbsp;<code>while</code>&nbsp;loops whose conditions never change. For example:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(i)</span><br></pre></td></tr></tbody></table></figure><p>Sometimes you might have incremented the wrong counter:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i, n = 0, 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(i)</span><br><span class="line">    n += 1</span><br></pre></td></tr></tbody></table></figure><h3 id="Off-by-one-errors"><a href="#Off-by-one-errors" class="headerlink" title="Off-by-one errors"></a>Off-by-one errors</h3><p>Sometimes a&nbsp;<code>while</code>&nbsp;loop or recursive function might stop one iteration too short. Here, it’s best to walk through the iteration/recursion to see what number the loop stops at.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;编程时，学会读取报错信息也是必要的。&lt;/p&gt;</summary>
    
    
    
    <category term="BugFix" scheme="https://sajlle.github.io/categories/BugFix/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="BugFix" scheme="https://sajlle.github.io/tags/BugFix/"/>
    
  </entry>
  
  <entry>
    <title>流程控制</title>
    <link href="https://sajlle.github.io/2023/04/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://sajlle.github.io/2023/04/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2023-04-15T14:10:33.000Z</published>
    <updated>2023-04-15T06:20:24.431Z</updated>
    
    <content type="html"><![CDATA[<p><em>控制语句</em>&nbsp;（control statement）将赋予我们这种能力。它们是根据逻辑比较的结果控制程序执行流程的语句。<br>语句（statement）与我们目前研究过的表达式有着根本的不同。他们没有值（value）。执行控制语句决定了解释器接下来应该做什么，而不是计算某些东西。</p><span id="more"></span><h4 id="Statement（语句）"><a href="#Statement（语句）" class="headerlink" title="Statement（语句）"></a>Statement（语句）</h4><p>我们已经看到了三种语句：赋值（assignment）、def和&nbsp;return语句。这些 Python 代码行本身并不是表达式，尽管它们都包含表达式作为组件。</p><p>语句不是被评估（evaluated），而是被==执行==。<strong>每个语句都描述了对解释器状态的一些更改，并且执行语句会应用该更改</strong>。正如我们在<code>return</code>和赋值语句中看到的那样，==<strong>执行语句可能涉及评估其中包含的子表达式</strong>==。</p><p>表达式也可以作为语句执行，在这种情况下，它们==会被求值，但它们的值会被丢弃。==执行纯函数没有效果，但执行非纯函数会因为函数应用而产生效果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">square</span> ( x ): </span><br><span class="line">mul ( x , x ) <span class="comment"># 注意！此调用不返回值。</span></span><br></pre></td></tr></tbody></table></figure><p>这个例子是有效的 Python，但可能不是预期的。函数体由一个表达式组成。一个表达式本身是一个有效的语句，但该语句的效果是调用了<code>mul</code>函数，结果被丢弃。如果你想对表达式的结果做些什么，你需要这样说：你可以用==赋值语句存储它==或用 <code>return </code>语句==返回==它：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">square</span> ( x ):</span><br><span class="line"><span class="keyword">return</span> mul ( x , x )</span><br></pre></td></tr></tbody></table></figure><p>有时，当调用像<code>print</code>这样的<mark style="background: #FF5582A6;">非纯函数</mark>时，拥有一个主体是表达式的函数确实有意义。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">print_square</span> ( x ):</span><br><span class="line"><span class="built_in">print</span>(square( x ))</span><br></pre></td></tr></tbody></table></figure><p>Python 解释器的工作是执行由语句组成的程序。然而，许多有趣的计算工作都来自对表达式的求值。语句控制程序中不同表达式之间的关系以及它们的结果会发生什么。(Statements govern the relationship among different expressions in a program and what happens to their results.)</p><h4 id="Compound-Statements（复合语句）"><a href="#Compound-Statements（复合语句）" class="headerlink" title="Compound Statements（复合语句）"></a>Compound Statements（复合语句）</h4><p>通常，Python 代码是一系列语句。<strong>简单语句是不以冒号结尾的单行</strong>。之所以称为==复合语句，是因为它由其他语句（简单语句和复合语句）组成==。复合语句通常跨越多行，并以单行标题开头，以冒号结尾，冒号标识语句的类型。标题和缩进的语句组(intended suite)一起称为子句。复合语句由一个或多个子句组成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">&lt;statement&gt;</span><br><span class="line">&lt;statement&gt;</span><br><span class="line">...</span><br><span class="line">&lt;separating header&gt;:</span><br><span class="line">&lt;statement&gt;</span><br><span class="line">&lt;statement&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><ul><li>  表达式、返回语句和赋值语句都是简单的语句。</li><li> <code>def</code>语句是复合语句。<code>def</code> header后面的suite&nbsp;定义了函数体。<br>Specialized evaluation rules for each kind of header dictate when and if the statements in its suite are executed.<br>We say that the ==header controls its suite==.<br>例如，在def语句的情况下，我们看到 return 表达式不会立即求值，而是存储起来以供最终调用定义的函数时使用。</li></ul><p>我们现在也可以理解多行程序了。<br>To execute a sequence of statements, execute the first statement. If that statement does not redirect control, then proceed（继续） to execute the rest of the sequence of statements, if any remain.<br>This definition exposes the essential structure of a recursively(递归地) defined&nbsp;<em>sequence</em>: a sequence can be decomposed into its first element and the rest of its elements. The “rest” of a sequence of statements is itself a sequence of statements! Thus, we can recursively apply this execution rule. This view of sequences as recursive data structures will appear again in later chapters.<br>The important consequence of this rule is that statements are executed in order, but later statements may never be reached, because of redirected control.</p><p><strong>实用指南。</strong> 缩进套件时，所有行必须以相同的方式缩进相同的量（<strong>使用空格，而不是制表符</strong>）。缩进的任何变化都会导致错误。</p><h4 id="Defining-Functions-II-Local-Assignment（局部赋值）"><a href="#Defining-Functions-II-Local-Assignment（局部赋值）" class="headerlink" title="Defining Functions II: Local Assignment（局部赋值）"></a>Defining Functions II: Local Assignment（局部赋值）</h4><p>每当应用用户定义的函数时，其定义套件中的子句序列将在本地环境中执行——该环境以通过调用该函数创建的本地框架开始。return语句重定向控制：每当执行第一个return语句&nbsp;时，函数应用程序终止，&nbsp;return表达式的值是被应用函数的返回值。<br>赋值语句可以出现在函数体内。</p><p>赋值语句的作用是将名称绑定到&nbsp;当前环境的第一帧中的值（The effect of an assignment statement is to bind a name to a value in the first frame of the current environment.）<br>因此，函数体内的赋值语句不会影响全局框架（As a consequence, assignment statements within a function body cannot affect the global frame.）。函数只能操纵其本地环境这一事实对于创建==<em>模块化</em>==程序至关重要，在模块化程序中，纯函数仅通过它们获取和返回的值进行交互。（The fact that functions can only manipulate their local environment is critical to creating modular programs, in which pure functions interact only via the values they take and return.）</p><p>So far, local assignment hasn’t increased the expressive power of our function definitions. It will do so, when combined with other control statements. In addition, local assignment also plays a critical role in clarifying the meaning of complex expressions by assigning names to intermediate quantities.</p><h4 id="Conditional-Statements-条件控制"><a href="#Conditional-Statements-条件控制" class="headerlink" title="Conditional Statements 条件控制"></a>Conditional Statements 条件控制</h4><p><strong>Conditional statements</strong>. A conditional statement in Python consists of a series of headers and suites: a required&nbsp;if&nbsp;clause, an optional sequence of&nbsp;elif&nbsp;clauses, and finally an optional&nbsp;else&nbsp;clause:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure><p>When executing a conditional statement, each clause is considered in order. The computational process of executing a conditional clause follows.</p><ol><li> Evaluate the header’s expression.</li><li> If it is a true value, execute the suite. Then, skip over all subsequent clauses in the conditional statement.</li></ol><p>If the&nbsp;<code>else</code>&nbsp;clause is reached (which only happens if all&nbsp;<code>if&nbsp;</code>and<code>&nbsp;elif&nbsp;</code>expressions evaluate to false values), its suite is executed.</p><p><strong>Boolean contexts</strong>. Above, the execution procedures mention “a false value” and “a true value.” The expressions inside the header statements of conditional blocks are said to be in&nbsp;<em>boolean contexts</em>: their truth values matter to control flow, but otherwise their values are not assigned or returned. Python includes several false values, including <code>0</code>,&nbsp;<code>None</code>, and the&nbsp;<em>boolean</em>&nbsp;value&nbsp;<code>False</code>. All other numbers are true values. In Chapter 2, we will see that <strong>every built-in kind of data in Python has both true and false values.</strong></p><p><strong>Boolean values</strong>. Python has two boolean values, called<code>&nbsp;True</code>&nbsp;and<code>&nbsp;False</code>. Boolean values represent truth values in logical expressions. The built-in comparison operations,<code>&nbsp;&gt;, &lt;, &gt;=, &lt;=, ==, !=, </code>return these values.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &lt; <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt;= <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>第二个例子读作“5 大于等于 5”，对应于operator模块中的函数<code>ge</code> (greater equal) 。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == -<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>This final example reads “0 equals -0”, and corresponds to&nbsp;eq&nbsp;in the&nbsp;operator&nbsp;module. Notice that Python distinguishes assignment (<code>=</code>) from equality comparison (<code>==</code>), a convention shared across many programming languages.</p><p><strong>Boolean operators</strong>. Three basic logical operators are also built into Python:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>逻辑表达式有相应的求值过程。这些过程利用了这样一个事实，即逻辑表达式的真值有时可以在不评估其所有子表达式的情况下确定，这一特性称为&nbsp;<em>短路</em>(short-circuiting)。</p><p>评估表达式<code>&lt;left&gt; and &lt;right&gt;</code>：</p><ul><li>计算子表达式<code>&lt;left&gt;</code>。</li><li>如果结果为假值v，则表达式的计算结果为v。</li><li>否则，表达式的计算结果为子表达式<code>&nbsp;&lt;right&gt;</code>的值。</li></ul><p>评估表达式 <code>&lt;left&gt; or &lt;right&gt;</code>：</p><ol><li> 计算子表达式<code>&lt;left&gt;</code>。</li><li> 如果结果为真值v，则表达式的计算结果为v。</li><li> 否则，表达式的计算结果为子表达式<code>&nbsp;&lt;right&gt;</code>的值。</li></ol><p>评估表达式 <code>not &lt;exp&gt;</code>：</p><ol><li> 评估<code>&lt;exp&gt;</code>&nbsp;;&nbsp;如果结果为假值，则值为<code>True </code>，否则为<code>False</code>。</li></ol><p>这些值、规则和运算符为我们提供了一种组合比较结果的方法。执行比较并返回布尔值的函数通常以<code>is</code>开头，后面不跟下划线（例如<code>isfinite</code>、<code>&nbsp;isdigit</code>、<code>isinstance</code>等）。【These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with&nbsp;is, not followed by an underscore (e.g.,&nbsp;isfinite,&nbsp;isdigit,&nbsp;isinstance, etc.).】</p><h4 id="Iteration-迭代"><a href="#Iteration-迭代" class="headerlink" title="Iteration 迭代"></a>Iteration 迭代</h4><p>一个函数可以被多次应用，尽管它只被定义一次。迭代控制结构是另一种多次执行相同语句的机制。<br>考虑斐波那契数列，其中每个数都是前两个数的和：<br><code>0, 1, 1, 2, 3, 5, 8, 13, 21, ...</code><br>每个值都是通过重复应用 s<code>um-previous-two </code>规则构建的。第一个和第二个固定为 0 和 1。例如，第八个斐波那契数是 13。</p><p>我们可以使用<code>while</code>语句来枚举<code>n </code>个斐波那契数列。我们需要跟踪我们创建了多少个值 (<code>&nbsp;k</code>&nbsp;)，以及第<code> k</code> 个值 (&nbsp;<code>curr</code>&nbsp;) 及其前身 (&nbsp;<code>pred&nbsp;</code>)。单步执行此函数并观察斐波那契数如何一个一个地演化，绑定到<code>curr</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span>&nbsp;<span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"""Compute&nbsp;the&nbsp;nth&nbsp;Fibonacci&nbsp;number,&nbsp;for&nbsp;n&nbsp;&gt;=&nbsp;2."""</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;pred,&nbsp;curr&nbsp;=&nbsp;<span class="number">0</span>,&nbsp;<span class="number">1</span>&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Fibonacci&nbsp;numbers&nbsp;1&nbsp;and&nbsp;2</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;<span class="number">2</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Which&nbsp;Fib&nbsp;number&nbsp;is&nbsp;curr?</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;k&nbsp;&lt;&nbsp;n:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pred,&nbsp;curr&nbsp;=&nbsp;curr,&nbsp;pred&nbsp;+&nbsp;curr</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;k&nbsp;+&nbsp;<span class="number">1</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;curr</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span class="line">result&nbsp;=&nbsp;fib(<span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure><p>请记住，逗号分隔赋值语句中的多个名称和值。该行：<br><code>pred，curr = curr，pred + curr</code><br>具有将名称<code>pred</code>重新绑定到<code>curr</code>的值的效果，同时将 <code>curr</code> 重新绑定到<code>pred + curr</code>的值。<code>=</code>==右侧的所有表达式都在重新绑定发生之前进行计算==。<br>这种事件顺序——<strong>在更新左侧的任何绑定之前评估<code>=</code>右侧的所有内容</strong>——对于此函数的正确性至关重要。</p><p>A&nbsp;while&nbsp;clause contains a header expression followed by a suite:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expression&gt;:</span><br><span class="line">&lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure><p>To execute a&nbsp;while&nbsp;clause:</p><ol><li> Evaluate the header’s expression.</li><li> If it is a true value, execute the suite, then return to step 1.</li></ol><p>In step 2, the entire suite of the&nbsp;while&nbsp;clause is executed before the header expression is evaluated again.</p><p>In order to prevent the suite of a&nbsp;while&nbsp;clause from being executed indefinitely, the suite should always change some binding in each pass.</p><p>A&nbsp;while&nbsp;statement that does not terminate is called an infinite loop. Press&nbsp;<control>-C&nbsp;to force Python to stop looping.</control></p><h4 id="Testing-测试函数"><a href="#Testing-测试函数" class="headerlink" title="Testing 测试函数"></a>Testing 测试函数</h4><p>_测试_函数（testing function）是验证函数的行为是否符合预期的行为。我们的函数语言现在已经足够复杂，我们需要开始测试我们的实现。<br>A&nbsp;<em>test</em>&nbsp;is a mechanism for systematically performing this verification. Tests typically take the form of another function that contains one or more sample calls to the function being tested. The returned value is then verified against an expected result. Unlike most functions, which are meant to be general, tests involve selecting and validating calls with specific argument values. Tests also serve as documentation: they demonstrate how to call a function and what argument values are appropriate.</p><p><strong>Assertions.</strong>&nbsp;Programmers use&nbsp;assert&nbsp;statements to verify expectations, such as the output of a function being tested. An&nbsp;assert&nbsp;statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">'The 8th Fibonacci number should be 13'</span></span><br></pre></td></tr></tbody></table></figure><p>当被断言的表达式的计算结果为真值时，执行断言语句无效。当它是假值时，断言会导致停止执行的错误。</p><p>fib的测试函数应该测试几个参数，包括n的极值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span>  <span class="title function_">fib_test</span> (): </span><br><span class="line"><span class="keyword">assert</span> fib ( <span class="number">2</span> ) == <span class="number">1</span> , <span class="string">'第二个斐波那契数应该是 1'</span> </span><br><span class="line"><span class="keyword">assert</span> fib ( <span class="number">3</span> ) == <span class="number">1</span> , <span class="string">'第三个斐波那契数应该是 1 '</span> </span><br><span class="line"><span class="keyword">assert</span> fib ( <span class="number">50</span> ) = = <span class="number">7778742049</span> , <span class="string">'第 50 个斐波那契数列错误'</span></span><br></pre></td></tr></tbody></table></figure><p>当在文件中而不是直接在解释器中编写 Python 时，测试通常在同一个文件或后缀&nbsp;为 <code>_test.py</code>的相邻文件中编写。</p><p><strong>Doctests</strong><br>Python 提供了一种方便的方法，可以将简单的测试直接放在函数的<strong>文档字符串</strong> (docstring)中。==文档字符串的第一行应该包含函数的单行描述==，==然后是一个空行==。参数和行为的详细描述可能如下。此外，文档字符串可能包含调用该函数的示例交互式会话：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>): </span><br><span class="line">        <span class="string">"""返回前n个自然数的和。</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10) </span></span><br><span class="line"><span class="string">55 </span></span><br><span class="line"><span class="string">&gt;&gt;&gt;sum_naturals(100) </span></span><br><span class="line"><span class="string">5050 """</span></span><br><span class="line">total, k = <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> k &lt;= n: </span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure><p>Then, the interaction can be verified via the&nbsp;<a href="http://docs.python.org/py3k/library/doctest.html">doctest module</a>. Below, the&nbsp;globals&nbsp;function returns a representation of the global environment, which the interpreter needs in order to evaluate expressions. 然后，可以通过<a href="http://docs.python.org/py3k/library/doctest.html">doctest 模块</a>验证交互。下面，&nbsp;globals函数返回全局环境的表示，解释器需要它来评估表达式。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>为了仅验证单个函数的 doctest 交互，我们使用&nbsp;名为run_docstring_examples的doctest函数。这个函数（不幸的是）调用起来有点复杂。它的第一个参数是要测试的函数。第二个应该始终是表达式&nbsp;globals()的结果，这是一个返回全局环境的内置函数。第三个参数为True表示我们想要“详细”输出：所有测试运行的目录。</p><pre><code class="python">&gt;&gt;&gt; from  doctest  import  run_docstring_examples &gt;&gt;&gt; run_docstring_examples ( sum_naturals ,  globals (),  True )在 NoName 中寻找测试Trying: sum_naturals ( 10 ) Expecting: 55 ok Trying: sum_naturals ( 100 ) Expecting: 5050 ok```</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;控制语句&lt;/em&gt;&amp;nbsp;（control statement）将赋予我们这种能力。它们是根据逻辑比较的结果控制程序执行流程的语句。&lt;br&gt;语句（statement）与我们目前研究过的表达式有着根本的不同。他们没有值（value）。执行控制语句决定了解释器接下来应该做什么，而不是计算某些东西。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>隐序列</title>
    <link href="https://sajlle.github.io/2023/04/15/%E9%9A%90%E5%BA%8F%E5%88%97/"/>
    <id>https://sajlle.github.io/2023/04/15/%E9%9A%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-04-15T14:09:45.000Z</published>
    <updated>2023-04-15T06:24:17.246Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">range</span>(<span class="number">10000</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">45006230</span>]</span><br><span class="line"><span class="number">45016230</span></span><br></pre></td></tr></tbody></table></figure><p>在本例中，在构造range实例时，并不是存储该范围内的所有999,990000个整数。相反，range对象将第一个元素10,000添加到索引45,006,230以生成元素45,016,230。按需计算值，而不是从现有表示中检索值，是惰性计算的一个例子。在计算机科学中，<mark style="background: #FF5582A6;">惰性计算</mark>指的是延迟某个值的计算，直到该值需要时才计算的程序。</p><span id="more"></span><p>迭代器是一个对象，它提供对值的一个接一个顺序访问。<br>迭代器抽象有两个组件：一种机制用于检索正在处理的序列中的下一个元素，另一种机制用于通知已经到达序列的末尾且不再有其他元素存在。<br>对于任何容器，比如列表或range，都可以通过调用内置的<mark style="background: #FFF3A3A6;">iter函数</mark>来获得迭代器。可以通过调用内置的<mark style="background: #ABF7F7A6;">next函数来访问迭代器的内容。</mark></p><p>Python表示没有更多可用值的方式是在调用next时引发<mark style="background: #ABF7F7A6;">StopIteration</mark>异常。可以<mark style="background: #ABF7F7A6;">使用try语句处理此异常</mark>。</p><p>迭代器维护局部状态以表示其在序列中的位置。每次调用next时，该头都会上升。<mark style="background: #ADCCFFA6;">两个独立的迭代器可以跟踪同一序列中的两个不同位置。然而，同一个迭代器的两个名称将共享一个位置，因为它们共享相同的值。</mark></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">13</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">iter</span>(r)  <span class="comment"># 1st iterator over r</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">iter</span>(r)  <span class="comment"># 2nd iterator over r</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(t)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(t)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = t        <span class="comment"># Alternate name for the 2nd iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(u)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(u)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></tbody></table></figure><p>向前移动第二个迭代器不会影响第一个迭代器。因为从第一个迭代器返回的最后一个值是4，所以它被定位为next返回5。另一方面，第二个迭代器被定位为返回7 next。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(t)</span><br><span class="line"><span class="number">7</span>```</span><br><span class="line"></span><br><span class="line">&lt;mark style=<span class="string">"background: #ABF7F7A6;"</span>&gt;在迭代器上调用<span class="built_in">iter</span>将返回该迭代器，而不是副本&lt;/mark&gt;。Python中包含了这种行为，这样程序员就可以对一个值调用<span class="built_in">iter</span>来获得迭代器，而不必担心它是迭代器还是容器。</span><br><span class="line"></span><br><span class="line">迭代器的有用性源于这样一个事实：迭代器的底层数据序列不能显式地表示在内存中。 **迭代器提供了一种机制，可以依次考虑一系列的值，但不需要同时存储所有这些元素**。 相反，**当从迭代器请求下一个元素时，可以根据需要计算该元素，而不是从现有的内存源检索该元素。**</span><br><span class="line"></span><br><span class="line">`<span class="built_in">range</span> `能够惰性地计算序列的元素，因为所表示的序列是一致的，而且从范围的起始和结束边界计算任何元素都很容易。 **迭代器允许延迟生成更广泛的底层序列数据集，因为它们不需要提供对底层序列的任意元素的访问**。 相反，迭代器只需要在每次请求另一个元素时依次计算序列的下一个元素。 虽然不像访问序列的任意元素那样灵活(称为随机访问)，但对顺序数据的顺序访问通常对于数据处理应用程序来说已经足够了。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 可迭代对象</span></span><br><span class="line"></span><br><span class="line">任何可以产生迭代器的值都称为可迭代值。 在Python中，&lt;mark style=<span class="string">"background: #ABF7F7A6;"</span>&gt;可迭代值是任何可以传递给内置<span class="built_in">iter</span>函数的值。&lt;/mark&gt; &lt;mark style=<span class="string">"background: #ABF7F7A6;"</span>&gt;可迭代对象包括序列值，如字符串和元组，以及其他容器，如集合和字典&lt;/mark&gt;。迭代器也是可迭代对象，因为它们可以传递给<span class="built_in">iter</span>函数。</span><br><span class="line"></span><br><span class="line">即使是字典之类的&lt;mark style=<span class="string">"background: #FF5582A6;"</span>&gt;无序集合在生成迭代器时也必须对其内容定义顺序。&lt;/mark&gt; 字典和集合是无序的，因为程序员无法控制迭代的顺序，但是Python在其规范中保证了它们的某些属性的顺序。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = {<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">{<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: <span class="number">2</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="built_in">iter</span>(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(k)</span><br><span class="line"><span class="string">'one'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(k)</span><br><span class="line"><span class="string">'three'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = <span class="built_in">iter</span>(d.values())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(v)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(v)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>如果由于添加或删除键而导致字典的结构发生变化，那么所有迭代器都将失效，<mark style="background: #FF5582A6;">未来的迭代器可能会对其内容的顺序进行任意更改</mark>。另一方面，<mark style="background: #FF5582A6;">改变现有键的值不会改变内容的顺序或使迭代器失效。</mark></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'two'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(k)</span><br><span class="line">       </span><br><span class="line">RuntimeError: dictionary changed size during iteration</span><br><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></tbody></table></figure><h2 id="内置迭代器"><a href="#内置迭代器" class="headerlink" title="内置迭代器"></a>内置迭代器</h2><p>一些内置函数接受可迭代值作为参数并返回迭代器。 这些函数广泛用于延迟序列处理。</p><p>map函数是惰性的：调用它并不执行计算其结果元素所需的计算。 相反，将创建一个迭代器对象，如果使用next进行查询，该对象将返回结果。 我们可以在下面的例子中观察到这一事实，在这个例子中，对print的调用被延迟，直到double迭代器请求相应的元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">double_and_print</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'***'</span>, x, <span class="string">'=&gt;'</span>, <span class="number">2</span>*x, <span class="string">'***'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doubled = <span class="built_in">map</span>(double_and_print, s)  <span class="comment"># double_and_print not yet called</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(doubled)                       <span class="comment"># double_and_print called once</span></span><br><span class="line">*** <span class="number">3</span> =&gt; <span class="number">6</span> ***</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(doubled)                       <span class="comment"># double_and_print called again</span></span><br><span class="line">*** <span class="number">4</span> =&gt; <span class="number">8</span> ***</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(doubled)                       <span class="comment"># double_and_print called twice more</span></span><br><span class="line">*** <span class="number">5</span> =&gt; <span class="number">10</span> ***</span><br><span class="line">*** <span class="number">6</span> =&gt; <span class="number">12</span> ***</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></tbody></table></figure><p>filter函数返回一个迭代器over, zip，而reverse函数也返回迭代器。 TODO演示这些值</p><h2 id="For-语句"><a href="#For-语句" class="headerlink" title="For 语句"></a>For 语句</h2><p>Python中的for语句操作迭代器。如果对象具有返回迭代器的__iter__方法，则该对象是可迭代的(接口)。可迭代对象可以是for语句头中的<code>&lt;expression&gt;</code>的值:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure><p>为了执行for语句，Python计算头文件<code>&lt;expression&gt;</code>，它必须产生一个可迭代值。然后，对该值调用<code>__iter__</code>方法。在引发<code>StopIteration</code>异常之前，Python会反复调用该迭代器上的<code>__next__</code>方法，并将结果绑定到for语句中的。然后，它执行<code>&lt;suite&gt;</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> counts:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，counts列表从其__iter__()方法返回一个迭代器。 然后for语句重复调用该迭代器的__next__()方法，并每次将返回值赋给item。 这个过程一直持续，直到迭代器抛出StopIteration异常，此时for语句的执行结束。</p><p>有了迭代器的知识，我们就可以用while、赋值和try语句来实现for语句的执行规则。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = counts.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = items.__next__()</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>上面，调用counts的__iter__方法返回的迭代器被绑定到一个名称 items上，以便可以依次查询每个元素。 StopIteration异常的handling子句不做任何事情，但是处理异常提供了退出while循环的控制机制。<br>要在for循环中使用迭代器，迭代器还必须具有<code>__iter__</code>方法。<a href="http://docs.python.org/3/library/stdtypes.html#iterator-types">迭代器类型 Python文档</a>建议迭代器有一个’ iter ‘方法，该方法返回迭代器本身，因此所有迭代器都是可迭代的。</p><h2 id="生成器和Yield声明"><a href="#生成器和Yield声明" class="headerlink" title="生成器和Yield声明"></a>生成器和Yield声明</h2><p>Letters和 Positives对象要求我们引入一个新的概念 self.current到我们的对象，以跟踪序列的进程。 使用上面所示的简单序列，这可以很容易地完成。 然而，对于复杂的序列，__next__方法在计算中保存自己的位置可能会相当困难。生成器允许我们利用Python解释器的特性来定义更复杂的迭代。</p><p>生成器是由称为<mark style="background: #FF5582A6;">生成器函数</mark>的特殊函数类返回的迭代器。 生成器函数与常规函数的区别在于，它们<mark style="background: #FF5582A6;">不在函数体中包含return语句，而是使用yield语句返回序列的元素</mark>。</p><p>生成器不使用对象的属性来跟踪它们在一系列中的进度。相反，它们控制生成器函数的执行，直到每次调用生成器的__next__方法时执行下一个yield语句为止。使用生成器函数可以更简洁地实现Letters迭代器。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">letters_generator</span>():</span><br><span class="line">        current = <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">while</span> current &lt;= <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">yield</span> current</span><br><span class="line">            current = <span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>尽管我们从未显式定义<code>__iitem__</code>或<code>__next__</code>方法，但<code>yield</code>语句表明我们正在定义一个生成器函数。 当被调用时，生成器函数不会返回特定的生成值，而是返回自身可以返回生成值的生成器(它是一种迭代器类型)。 <mark style="background: #FF5582A6;">生成器对象有__item__和__next__方法，每次对__next__的调用都会从它之前停止的地方继续执行生成器函数，直到执行另一个yield语句。</mark></p><p>第一次调用__next__时，程序从letters_generator函数体开始执行语句，直到遇到yield语句为止。然后，它暂停并返回current.yield的值，不会破坏新创建的环境，它们会保存它以供以后使用。当__next__再次被调用时，执行将在它停止的地方继续。letters_generator作用域内的当前名称和任何其他绑定名称的值在后续对__next__的调用中保留。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = letters_generator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(letters)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'generator'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></tbody></table></figure><p>直到第一次调用__next__，生成器才会开始执行它的生成器函数的任何主体语句。每当生成器函数返回时，生成器将引发StopIteration异常。</p><h2 id="可迭代接口"><a href="#可迭代接口" class="headerlink" title="可迭代接口"></a>可迭代接口</h2><p>一个对象是可迭代的，如果它在__iter__方法被调用时返回一个迭代器。可迭代值表示数据集合，它们提供了一种固定的表示方式，可以产生多个迭代器。</p><p>例如，下面的Letters类的一个实例表示一个连续的字母序列。每次调用它的__iter__方法时，都会构造一个新的LetterIter实例，它允许顺序访问序列的内容。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Letters</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">'a'</span>, end=<span class="string">'e'</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> LetterIter(self.start, self.end)</span><br></pre></td></tr></tbody></table></figure><h2 id="创建迭代器的常用方法"><a href="#创建迭代器的常用方法" class="headerlink" title="创建迭代器的常用方法"></a>创建迭代器的常用方法</h2><p>•    <code>range(start, end)</code> returns an iterable containing numbers from start to end-<br>    1.    If start is not provided, it defaults to 0.<br>•    <code>map(f, iterable)</code> returns a new iterator containing the values resulting from applying f to each value in iterable.<br>•    <code>filter(f, iterable)</code> returns a new iterator containing only the values in iterable for which f(value) returns True.</p><h2 id="生成器和yield语句"><a href="#生成器和yield语句" class="headerlink" title="生成器和yield语句"></a>生成器和yield语句</h2><p>生成器函数是一种特殊的 Python 函数，它使用 yield语句而不是返回语句来报告数值。当一个生成器函数被调用时，它返回一个生成器对象，这是一种迭代器的类型。在右边，你可以看到一个函数，它返回一个自然数的迭代器。<br>yield语句与return语句类似。然而，返回语句在函数退出后关闭了当前的框架，而yield语句会使框架被保存到下一次调用时，这使生成器能够自动跟踪迭代状态。</p><p>一旦再次调用next，执行就会在上次停止的地方继续进行，直到下一个yield语句或函数的结束。一个生成器函数可以有多个 yield语句。<br>在一个函数中包含一个 yield 语句，会自动告诉 Python 这个函数将创建一个生成器。当我们调用这个函数时，它会返回一个生成器对象，而不是执行主体。当生成器的下一个方法被调用时，主体被执行，直到下一个 yield语句被执行。</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;r = &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1000000000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;r[&lt;span class=&quot;number&quot;&gt;45006230&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;45016230&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在本例中，在构造range实例时，并不是存储该范围内的所有999,990000个整数。相反，range对象将第一个元素10,000添加到索引45,006,230以生成元素45,016,230。按需计算值，而不是从现有表示中检索值，是惰性计算的一个例子。在计算机科学中，&lt;mark style=&quot;background: #FF5582A6;&quot;&gt;惰性计算&lt;/mark&gt;指的是延迟某个值的计算，直到该值需要时才计算的程序。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="SICP" scheme="https://sajlle.github.io/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>设计函数</title>
    <link href="https://sajlle.github.io/2023/04/15/%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>https://sajlle.github.io/2023/04/15/%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2023-04-15T14:08:52.000Z</published>
    <updated>2023-04-15T06:22:30.502Z</updated>
    
    <content type="html"><![CDATA[<p>好的函数的品质都强化了函数是抽象的想法。</p><span id="more"></span><ul><li>  每个功能应该<strong>只有一个</strong>工作。该工作应该可以用一个简短的名称来识别，并且可以在一行文本中进行描述。按顺序执行多个作业的函数应分为多个函数。</li><li>  ==_<strong>不要重复自己</strong>==_是软件工程的核心原则。所谓的 DRY 原则指出，多个代码片段不应描述冗余逻辑。相反，==该逻辑应该实现一次，命名并多次应用==。如果您发现自己正在复制和粘贴一段代码，那么您可能已经找到了进行功能抽象的机会。</li><li>  函数应该被一般地（genrally）定义。平方不在 Python 库中正是因为它是pow函数的特例，pow将数字计算为任意幂。</li></ul><p>函数定义通常包括描述函数的文档，称为_==docstring==_，它==必须与函数体一起缩进==。文档字符串通常是==三引号==。第一行在一行中描述了函数的工作。以下几行可以描述参数并阐明函数的行为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">        <span class="string">"""Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann's constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure><p>When you call&nbsp;<code>help</code>&nbsp;with the name of a function as an argument, you see its docstring (type&nbsp;<code>q</code>&nbsp;to quit Python help).</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></tbody></table></figure><p>代码只写一次，但往往要读很多遍。<br>The Python docs include&nbsp;<a href="http://www.python.org/dev/peps/pep-0257/">docstring guidelines</a>&nbsp;that maintain consistency across different Python projects.</p><p><strong>Comments</strong>. Comments in Python can be attached to the end of a line following the&nbsp;#&nbsp;symbol. For example, the comment&nbsp;Boltzmann’s constant&nbsp;above describes&nbsp;k. ==These comments don’t ever appear in Python’s&nbsp;help, and they are ignored by the interpreter.== They exist for humans alone.</p><p>A consequence of defining general functions is the introduction of additional arguments. ==Functions with many arguments can be awkward to call and difficult to read.==<br>In Python, we can provide ==default values== for the arguments of a function. When calling that function, arguments with ==default values are optional==. ==If they are not provided, then the default value is bound to the formal parameter(形式参数) name instead.== For instance, if an application commonly computes pressure for one mole of particles, this value can be provided as a default:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n=<span class="number">6.022e23</span></span>):</span><br><span class="line">        <span class="string">"""Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas (default: one mole)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann's constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure><p>The&nbsp;<code>=&nbsp;</code>symbol means two different things in this example, depending on the context in which it is used. In the<code>&nbsp;def&nbsp;</code>statement header,<code>&nbsp;=&nbsp;</code>==does not perform assignment==, but instead ==indicates a default value to use== when the&nbsp;pressure&nbsp;function is called. By contrast, the assignment statement to<code>&nbsp;k</code>&nbsp;==in the body of the function binds the name&nbsp;k&nbsp;to an approximation(近似值) of Boltzmann’s constant.==</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>)</span><br><span class="line"><span class="number">2269.974834</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)</span><br><span class="line"><span class="number">6809.924502</span></span><br></pre></td></tr></tbody></table></figure><p>The&nbsp;<code>pressure</code>&nbsp;function is defined to take three arguments, but only two are provided in the first call expression above. In this case, the value for&nbsp;<code>n&nbsp;</code>is taken from the&nbsp;<code>def&nbsp;</code>statement default. If a third argument is provided, the default is ignored.</p><p>As a guideline, most data values used in a function’s body should be expressed as default values to named arguments, so that they are easy to inspect and can be changed by the function caller. Some values that never change, such as the fundamental constant&nbsp;k, can be bound in the function body or in the global frame.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好的函数的品质都强化了函数是抽象的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="SICP" scheme="https://sajlle.github.io/tags/SICP/"/>
    
    <category term="函数式编程" scheme="https://sajlle.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的编程</title>
    <link href="https://sajlle.github.io/2023/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/"/>
    <id>https://sajlle.github.io/2023/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/</id>
    <published>2023-04-15T14:08:23.000Z</published>
    <updated>2023-04-15T06:26:00.022Z</updated>
    
    <content type="html"><![CDATA[<p>像数据抽象中的函数一样，类在数据的使用和实现之间创建了抽象障碍。与分派字典一样，对象响应行为请求。 与可变数据结构一样，对象具有不能从全局环境直接访问的局部状态。</p><p>面向对象编程的范例有自己的词汇表来支持对象隐喻。 我们已经看到，对象是一个具有方法和属性的数据值，可以通过<mark style="background: #FF5582A6;">点表示</mark>法访问。 每个对象也有一个类型，称为它的类。 为了创建新的数据类型，我们实现了新的类。</p><span id="more"></span><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>类充当所有类型为该类的对象的模板。每个对象都是某个特定类的实例。到目前为止，我们使用的对象都有内置类，但是也可以创建新的用户定义的类。类定义指定类的对象之间共享的属性和方法。</p><p>创建一个新的对象实例的行为被称为实例化类。 Python中实例化类的语法与调用函数的语法相同。</p><p>对象的属性是与对象相关联的名值对，可以通过<mark style="background: #ABF7F7A6;">点表示法</mark>访问。与类的所有对象不同，<mark style="background: #ABF7F7A6;">特定于特定对象的属性称为实例属性</mark>。每个帐户都有自己的余额和帐户持有人名称，它们是实例属性的示例。在更广泛的编程社区中，<mark style="background: #ABF7F7A6;">实例属性也可以称为字段、属性或实例变量</mark>。</p><p>对对象进行操作或执行特定于对象的计算的函数称为方法。方法的返回值和副作用可以依赖并更改对象的其他属性。<br>方法的行为可以依赖于对象不断变化的属性。两次使用相同参数的withdraw调用会返回不同的结果。</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>用户定义的类由由单个子句组成的class语句创建。类语句定义类名，然后包含一组定义类属性的语句：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure><p>当一个类语句被执行时，一个新的类被创建并绑定到<code>&lt;name&gt;</code> 在当前环境的第一个框架中。 然后执行<code>&lt;suite&gt;</code>。 在套件内的任何名称对于类语句，通过<code>def</code>或赋值语句创建或修改类的属性。</p><p>类通常是围绕操纵实例属性来组织的，实例属性是与该类的每个实例相关联的名值对。 该类通过定义初始化新对象的方法来指定其对象的实例属性。</p><p><code>&lt;suite&gt;</code> 类的对象语句包含为该类对象定义新方法的def语句。 初始化对象的方法在Python中有一个特殊的名称，<code>__init__</code>(单词“<code>init</code>”的两侧各有两个下划线)，它被称为该类的构造函数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br></pre></td></tr></tbody></table></figure><p>Account的<code>__init__</code>方法有两个形式参数。第一个<code>self</code>绑定到新创建的<code>Account</code>对象。 第二个形参<code>account_holder</code>绑定到在调用类进行实例化时传递给类的实参。</p><p>构造函数将实例属性名<code>balance</code>绑定到<code>0</code>。 它还将属性名称持有者绑定到名称<code>account_holder</code>的值。 形参<code>account_holder</code>是<code>__init__</code>方法中的本地名称。 另一方面，通过最终赋值语句绑定的名称持有者将持续存在，因为它使用点表示法存储为<code>self</code>属性。</p><p>定义了Account类之后，就可以实例化它了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Account(<span class="string">'Kirk'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个对Account类的“调用”创建了一个新对象，它是Account的一个实例，然后用两个参数调用构造函数<code>__init__</code>：新创建的对象和字符串<code>'Kirk'</code>。按照惯例，我们使用参数名<code>self</code>作为构造函数的第一个参数，因为它被绑定到正在实例化的对象。几乎所有的Python代码都采用了这种约定。</p><p>现在，我们可以使用点表示法访问对象的balance和holder</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">'Kirk'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>同一性</strong> ：每个新的account实例都有自己的balance属性，该属性的值<mark style="background: #ABF7F7A6;">独立于同一类的其他对象</mark>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Account(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.balance = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[acc.balance <span class="keyword">for</span> acc <span class="keyword">in</span> (a, b)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">200</span>]</span><br></pre></td></tr></tbody></table></figure><p>为了强制这种分离，作为用户定义类实例的每个对象都有一个唯一标识。使用is和is not操作符比较对象标识。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>尽管由相同的调用构造，绑定到a和b的对象是不一样的。通常，使用赋值将对象绑定到新名称并不会创建新对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>只有当使用调用表达式语法实例化类(例如Account)时，才会创建具有用户定义类的新对象。</p><p><strong>方法</strong> : 对象方法也由class语句集合中的def语句定义。下面，deposit和withdraw都定义为Account类对象上的方法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></tbody></table></figure><p>虽然方法定义在声明方式上与函数定义没有区别，但<mark style="background: #ABF7F7A6;">方法定义在执行时确实有不同的效果</mark>。 <mark style="background: #ABF7F7A6;">由类语句中的def语句创建的函数值绑定到声明的名称，但在类内部局部绑定为属性。</mark> <mark style="background: #FF5582A6;">该值是使用类实例中的点表示法作为方法调用的。</mark></p><p><mark style="background: #FF5582A6;">每个方法定义同样包含一个特殊的第一个参数self，它被绑定到调用该方法的对象。</mark> 例如，假设在一个特定的Account对象上调用了deposit，并传递了一个参数值：存入的金额。 对象本身与self绑定，而参数与amount绑定。 <mark style="background: #FF5582A6;">所有被调用的方法都可以通过self参数访问对象，因此它们都可以访问和操作对象的状态。</mark></p><p>为了调用这些方法，我们再次使用点表示法，如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="string">'Insufficient funds'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.holder</span><br><span class="line"><span class="string">'Spock'</span></span><br></pre></td></tr></tbody></table></figure><p>当通过<mark style="background: #FF5582A6;">点表示法</mark>调用方法时，对象本身(在本例中绑定到spock_account)扮演双重角色。首先，它确定了“withdraw”这个名字的含义；withdraw不是环境中的名称，而是Account类本地的名称。其次，<mark style="background: #FF5582A6;">在调用withdraw方法时，它被绑定到第一个参数self。</mark></p><h2 id="消息传递和点表达式"><a href="#消息传递和点表达式" class="headerlink" title="消息传递和点表达式"></a>消息传递和点表达式</h2><p>在类中定义的方法，以及通常在构造函数中分配的实例属性，是面向对象编程的基本元素。 这两个概念在数据值的消息传递实现中<mark style="background: #FF5582A6;">复制了调度字典的</mark>大部分行为。 对象使用点表示法接受消息，但这些消息不是任意字符串值的键，而是<mark style="background: #FF5582A6;">类的本地名称</mark>。 <mark style="background: #FF5582A6;">对象也有命名的本地状态值(实例属性)，但是可以使用点表法访问和操作该状态，而不必在实现中使用非本地语句</mark>。</p><p><mark style="background: #FF5582A6;">消息传递的中心思想是，数据值应该通过响应与它们所表示的抽象类型相关的消息而具有行为</mark>。 点表示法是Python的一个语法特性，它将消息传递隐喻形式化。 使用内置对象系统的语言的优点是，消息传递可以与其他语言特性无缝地交互，比如赋值语句。 我们不要求不同的消息“获取”或“设置”与本地属性名相关联的值；语言语法允许我们直接使用消息名称。</p><p><strong>点表示</strong> : 代码片段spock_account.deposit称为点表达式。 点表达式由表达式、点和名称组成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; . &lt;name&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>&lt;表达式&gt;</code>可以是任何有效的Python表达式，但必须是一个简单的名称(而不是计算结果为名称的表达式)。对于<code>&lt;表达式&gt;</code>的值的对象，点表达式计算为具有给定的的属性的值。</p><p>内置函数<code>getattr</code>还根据名称返回对象的属性。它<mark style="background: #FF5582A6;">是点表示法的等价函数</mark>。使用<code>getattr</code>，我们可以使用字符串查找属性，就像使用分派字典一样。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(spock_account, <span class="string">'balance'</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><p>我们还可以用<code>hasattr</code>测试对象是否有命名属性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(spock_account, <span class="string">'deposit'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>对象的属性包括它的<mark style="background: #FF5582A6;">所有实例属性</mark>，<mark style="background: #FF5582A6;">以及类中定义的所有属性(包括方法)</mark>。 方法是类的属性，需要特殊处理</p><p><strong>方法和函数。</strong> 当在对象上调用方法时，该对象将隐式地作为方法的第一个参数传递。 也就是说，对象就是<code>&lt;表达式&gt;</code>的值，<mark style="background: #FF5582A6;">在点的左边会自动作为第一个参数传递给点表达式右边命名的方法。</mark> <mark style="background: #FF5582A6;">因此，对象被绑定到参数self。</mark></p><p>为了实现自动自绑定，Python区分了函数(我们从正文开始就一直在创建)和绑定方法(绑定方法将函数和将调用该方法的对象结合在一起)。<mark style="background: #FF5582A6;">绑定的方法值已经与它的第一个参数(调用它的实例)相关联，该参数将在调用该方法时被命名为self。</mark></p><p>通过对点表达式的返回值调用<code>type</code>，我们可以看到交互式解释器中的区别。<mark style="background: #FF5582A6;"> 作为类的属性，方法只是一个函数，而作为实例的属性，它是一个绑定方法</mark>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(spock_account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'method'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>这两个结果的不同之处在于，<mark style="background: #FF5582A6;">第一个是带有参数self和amount的标准双参数函数</mark>。 第二个是一个<mark style="background: #FF5582A6;">单参数方法</mark>，在调用该方法时，名称self将自动绑定到名为spock_account的对象，而形参amount将绑定到传递给该方法的实参。 这两个值，无论是函数值还是绑定的方法值，都与同一个desposit函数体相关联。</p><p>我们可以以两种方式调用<code>deposit</code> : <mark style="background: #FF5582A6;">作为函数和作为绑定方法</mark>。 在前一种情况下，必须显式地为self形参提供一个实参。 在后一种情况下，self参数是自动绑定的。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.deposit(spock_account, <span class="number">1001</span>)  <span class="comment"># The deposit function takes 2 arguments</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">1000</span>)           <span class="comment"># The deposit method takes 1 argument</span></span><br><span class="line"><span class="number">2011</span></span><br></pre></td></tr></tbody></table></figure><p>函数<code>getattr</code>的行为与点表法完全相同：<mark style="background: #FF5582A6;">如果它的第一个参数是一个对象，但名称是类中定义的一个方法，那么getattr返回一个绑定的方法值。</mark> 另一方面，<mark style="background: #FF5582A6;">如果第一个参数是一个类，则getattr将直接返回属性值，这是一个普通函数。</mark></p><p><strong>命名约定。</strong> <mark style="background: #FF5582A6;">类名通常使用<code>CapWords</code>约定编写</mark>(也称为CamelCase，因为名称中间的大写字母看起来像驼峰)。 <mark style="background: #FF5582A6;">方法名称遵循命名函数的标准约定，使用用下划线分隔的小写单词</mark>。</p><p>在某些情况下，有些实例变量和方法与对象的维护和一致性有关，我们不希望对象的用户看到或使用它们。 它们不是类定义的抽象的一部分，而是实现的一部分。 Python的约定是，如果<mark style="background: #FF5582A6;">属性名以下划线开头，则只能在类本身的方法中访问，而不是由类的用户访问。</mark></p><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>某些属性值在给定类的所有对象之间共享。 这些<mark style="background: #FF5582A6;">属性与类本身相关联，而不是与类的任何单独实例相关联</mark>。 例如，假设一家银行按固定利率对账户余额支付利息。 利率可能会变化，但它是所有账户共享的单一价值。</p><p>类属性是由类语句集合中的<mark style="background: #FF5582A6;">赋值语句</mark>创建的，而不属于任何方法定义。 在更广泛的开发人员社区中，<mark style="background: #FF5582A6;">类属性也可以称为类变量或静态变量。 </mark>下面的类语句为帐户创建了一个名为interest的类属性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        interest = <span class="number">0.02</span>            <span class="comment"># A class attribute</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="comment"># Additional methods would be defined here</span></span><br></pre></td></tr></tbody></table></figure><p>仍然可以从类的任何实例访问此属性</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account = Account(<span class="string">'Kirk'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br></pre></td></tr></tbody></table></figure><p>对类属性的单个赋值语句会更改该类所有实例的属性值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></tbody></table></figure><p><strong>属性名称。</strong> 我们已经在对象系统中引入了足够的复杂性，以至于必须<mark style="background: #FF5582A6;">指定名称如何解析为特定的属性</mark>。毕竟，我们可以很容易地拥有具有相同名称的类属性和实例属性。</p><p>计算一个点表达式：<br><code>&lt;expression&gt; . &lt;name&gt;</code></p><ul><li>  计算<code>&lt;表达式&gt;</code> 在点的左边，它产生点表达式的对象。</li><li><code>&lt;name&gt;</code> 匹配该对象的实例属性; 如果存在具有该名称的属性，则返回其值。</li><li>如果 <code>&lt;name&gt;</code> 如果实例属性中没有出现<code>&lt;name&gt;</code> 在类中查找，这<mark style="background: #FF5582A6;">会产生一个类属性值</mark>。</li><li> 除非它是一个函数，否则将返回该值，在这种情况下，将返回绑定方法。</li></ul><p>在这个计算过程中，<mark style="background: #FF5582A6;">在类属性之前找到实例属性</mark>，就像在环境中局部名称优先于全局名称一样。 <mark style="background: #FF5582A6;">在求值过程的第四步中，类中定义的方法与点表达式的对象相结合，形成一个绑定方法。</mark> 一旦引入了类继承，在类中查找名称的过程将很快产生额外的细微差别。</p><p><strong>属性赋值。</strong> 所有在左侧包含点表达式的赋值语句都会影响该点表达式对象的属性。 如果对象是一个实例，则赋值设置一个实例属性。 如果对象是一个类，则赋值设置一个类属性。 该规则的结果是，<mark style="background: #FF5582A6;">对对象属性的赋值不能影响其类的属性</mark>。 下面的例子说明了这一区别。</p><p>如果将account实例的命名属性interest赋值，则创建一个与现有class属性同名的新实例属性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest = <span class="number">0.08</span></span><br></pre></td></tr></tbody></table></figure><p>属性值将从点表达式返回。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></tbody></table></figure><p>但是，class属性interest仍然保留其原始值，对于所有其他帐户都返回该值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></tbody></table></figure><p>对类属性的更改将影响spock_account，但kirk_account的实例属性将不受影响。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.05</span>  <span class="comment"># changing the class attribute</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest     <span class="comment"># changes instances without like-named instance attributes</span></span><br><span class="line"><span class="number">0.05</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest     <span class="comment"># but the existing instance attribute is unaffected</span></span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></tbody></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在使用面向对象的编程范式时，我们经常会发现不同的类型是相互关联的。特别地，我们发现相似的类在专业化程度上是不同的。两个类可能具有相似的属性，但是一个类表示另一个类的特殊情况。</p><p>例如，我们可能想要实现一个支票帐户，它与标准帐户不同。支票账户每次取款都要额外收取1美元，利率也较低。这里，我们演示所需的行为。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch = CheckingAccount(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.interest     <span class="comment"># Lower interest rate for checking accounts</span></span><br><span class="line"><span class="number">0.01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.deposit(<span class="number">20</span>)  <span class="comment"># Deposits are the same</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.withdraw(<span class="number">5</span>)  <span class="comment"># withdrawals decrease balance by an extra charge</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></figure><p>支票帐户是帐户的专门化。 在OOP术语中，通用帐户将作为CheckingAccount的基类，而CheckingAccount将是account的子类。 (术语父类和超类也用于基类，而子类也用于子类。)</p><p><mark style="background: #FF5582A6;">子类继承其基类的属性，但可能覆盖某些属性，包括某些方法。</mark> 对于继承，<mark style="background: #ABF7F7A6;">我们只指定子类和基类之间的不同之处。 我们在子类中未指定的任何东西都会自动假定其行为与基类一样。</mark></p><p>除了作为一个有用的组织特性之外，继承在我们的对象隐喻中也有作用。 <mark style="background: #FF5582A6;">继承意味着表示类之间的is-关系，这与have -a关系相反</mark>。 支票帐户是一种特定类型的帐户，因此从帐户继承CheckingAccount是继承的适当用法。 另一方面，银行拥有它管理的银行账户列表，因此任何一方都不应该从另一方继承。 相反，account对象的列表将自然地表示为bank对象的实例属性。</p><h2 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h2><p>首先，我们给出Account类的完整实现，其中包括该类及其方法的文档字符串。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="string">"""A bank account that has a non-negative balance."""</span></span><br><span class="line">        interest = <span class="number">0.02</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">"""Increase the account balance by amount and return the new balance."""</span></span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">"""Decrease the account balance by amount and return the new balance."""</span></span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></tbody></table></figure><p>CheckingAccount的完整实现如下所示。通过将计算结果为基类的表达式放在类名后的圆括号中来指定继承。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">CheckingAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        <span class="string">"""A bank account that charges for withdrawals."""</span></span><br><span class="line">        withdraw_charge = <span class="number">1</span></span><br><span class="line">        interest = <span class="number">0.01</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></tbody></table></figure><p>这里，我们引入了一个特定于CheckingAccount类的类属性withdraw_charge。我们给interest属性赋一个较低的值。我们还定义了一个新的withdraw方法来覆盖Account类中定义的行为。如果类套件中没有其他语句，则所有其他行为都继承自基类帐户。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking = CheckingAccount(<span class="string">'Sam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.deposit(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.withdraw(<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.interest</span><br><span class="line"><span class="number">0.01</span></span><br></pre></td></tr></tbody></table></figure><p>check .deposit表达式计算为一个存入存款的绑定方法，该方法在Account类中定义。当Python解析不是实例属性的点表达式中的名称时，它会在类中查找该名称。事实上，在类中“查找”名称的行为试图在原始对象的类的继承链中的每个基类中找到这个名称。我们可以递归地定义这个过程。在类中查找名称。</p><ul><li><ol><li>如果它<mark style="background: #FF5582A6;">命名了类中的一个属性，则返回该属性的值</mark>。</li></ol></li><li><ol start="2"><li>否则，在<mark style="background: #FF5582A6;">基类中查找名称</mark>(如果有的话)。</li></ol></li></ul><p>在执行deposit情况下，Python首先在实例中查找名称，然后在CheckingAccount类中查找。 最后，它将查看Account类，其中定义了deposit。 根据点表达式的计算规则，因为deposit是在类中为检查实例查找的函数，所以点表达式计算为绑定的方法值。 该方法使用参数10调用，参数10调用self绑定到check对象并将amount绑定到10的deposit方法。</p><p>对象的类始终保持不变。 尽管在Account类中找到了deposit方法，但在调用deposit时，self绑定到CheckingAccount的实例，而不是Account的实例。</p><p><strong>调用父类。</strong> 已经被覆盖的属性仍然可以通过类对象访问。 例如，我们通过调用Account的withdraw方法实现了CheckingAccount的withdraw方法，该方法带有一个包含withdraw_charge的参数。</p><p>注意到我们调用了self.withdraw_charge ，而不是等价的CheckingAccount.withdraw_charge。 <mark style="background: #FF5582A6;">前者优于后者的好处是继承自CheckingAccount的类可以覆盖取款费用</mark>。 如果是这样的话，我们希望我们的withdraw实现找到新的值而不是旧的值。</p><p><strong>接口。</strong> 在面向对象的程序中，<mark style="background: #FF5582A6;">不同类型的对象共享相同的属性名是非常常见的。 </mark><mark style="background: #ABF7F7A6;">对象接口是属性和这些属性上的条件的集合。</mark> 例如，所有帐户都必须有接受数字参数的存款和取款方法，以及一个余额属性。 类Account和CheckingAccount都实现了这个接口。 继承特别以这种方式促进名称共享。 在某些编程语言(如Java)中，必须显式声明接口实现。 在Python、Ruby和Go等其他语言中，任何具有适当名称的对象都实现一个接口。</p><p>如果<mark style="background: #FF5582A6;">程序中使用对象(而不是实现对象)的部分不假设对象类型，而只假设对象的属性名称，那么它们对未来的更改是最健壮的。</mark> 也就是说，它们<mark style="background: #FF5582A6;">使用对象抽象</mark>，而不是对其实现进行任何假设。</p><p>例如，假设我们运行了一个彩票，我们希望向每个帐户列表中存入5美元。 下面的实现没有对这些帐户的类型进行任何假设，因此同样适用于具有deposit方法的任何类型的对象：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">deposit_all</span>(<span class="params">winners, amount=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> winners:</span><br><span class="line">            account.deposit(amount)</span><br></pre></td></tr></tbody></table></figure><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>Python支持子类从多个基类继承属性的概念，这是一种称为多重继承的语言特性。</p><p>假设我们有一个从Account继承的SavingsAccount，但每次向客户存款时都要收取少量费用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        deposit_charge = <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></tbody></table></figure><p>然后，一位聪明的经理构思出一个具有支票账户和储蓄账户双重优点的活期账户：提现费、存款费和低利率。它既是支票账户又是储蓄账户!“ 如果我们建造了它，”行政人员解释道，“就会有人签约并支付所有费用。”我们甚至会给他们一美元。”</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            self.balance = <span class="number">1</span>           <span class="comment"># A free dollar!</span></span><br></pre></td></tr></tbody></table></figure><p>事实上，这个实现已经完成了。取款和存款都将产生费用，分别使用CheckingAccount和SavingsAccount中的函数定义。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal = AsSeenOnTVAccount(<span class="string">"John"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.balance</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit(<span class="number">20</span>)            <span class="comment"># $2 fee from SavingsAccount.deposit</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw(<span class="number">5</span>)            <span class="comment"># $1 fee from CheckingAccount.withdraw</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></tbody></table></figure><p>无歧义引用按预期正确解析：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit_charge</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw_charge</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>但是，如果引用是模糊的，比如对Account和CheckingAccount中定义的withdraw方法的引用，该怎么办?下图描述了AsSeenOnTVAccount类的继承图。每个箭头从一个子类指向一个基类。<br>![[Pasted image 20230206112746.png]]<br>对于这样一个简单的“菱形”形状，Python从左到右，然后向上解析名称。在这个例子中，Python按顺序检查以下类中的属性名，直到找到具有该名称的属性：<br><code>asseenontvaccount, CheckingAccount, SavingsAccount, Account, object</code><br>继承排序问题没有正确的解决方案，因为在某些情况下，我们可能倾向于优先考虑某些继承的类而不是其他类。 然而，任何支持多重继承的编程语言都必须以一致的方式选择某种顺序，以便该语言的用户能够预测其程序的行为。</p><p>Python使用一种称为<mark style="background: #FF5582A6;">C3方法解析排序的递归算</mark>法来解析这个名称。任何类的方法解析顺序都可以在所有类上使用<mark style="background: #FF5582A6;">mro方法</mark>查询。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[c.__name__ <span class="keyword">for</span> c <span class="keyword">in</span> AsSeenOnTVAccount.mro()]</span><br><span class="line">[<span class="string">'AsSeenOnTVAccount'</span>, <span class="string">'CheckingAccount'</span>, <span class="string">'SavingsAccount'</span>, <span class="string">'Account'</span>, <span class="string">'object'</span>]</span><br></pre></td></tr></tbody></table></figure><p>查找方法解析顺序的精确算法不是本文的主题，但Python的主要作者在<a href="http://python-history.blogspot.com/2010/06/method-resolution-order.html">原始论文的参考资料</a>中进行了描述。</p><h2 id="对象的角色"><a href="#对象的角色" class="headerlink" title="对象的角色"></a>对象的角色</h2><p>Python对象系统的设计是为了使数据抽象和消息传递既方便又灵活。 类、方法、继承和点表达式的专门化语法都使我们能够在程序中形式化对象隐喻，这提高了我们组织大型程序的能力。</p><p>特别是，我们希望我们的对象系统能够在程序的不同方面促进关注点的分离。 <mark style="background: #FF5582A6;">程序中的每个对象封装并管理程序状态的某些部分，每个类语句定义实现程序整体逻辑的某些部分的函数</mark>。 <mark style="background: #ABF7F7A6;">抽象障碍加强了大型程序不同方面之间的边界</mark>。</p><p><mark style="background: #FF5582A6;">面向对象编程特别适合为具有独立但相互作用的部分的系统建模的程序</mark>。 例如，不同的用户在社交网络中互动，不同的角色在游戏中互动，不同的形状在物理模拟中互动。 当表示这样的系统时，程序中的对象通常会自然地映射到被建模的系统中的对象，而类表示它们的类型和关系。</p><p>另一方面，<mark style="background: #FF5582A6;">类可能不提供实现某些抽象的最佳机制。 功能抽象为表示输入和输出之间的关系提供了一种更自然的隐喻</mark>。 人们不应该强迫自己在类中容纳程序中的每一点逻辑，特别是在定义用于操作数据的独立函数更自然的情况下。 函数也可以强制关注点分离。</p><p>Python等多范式语言允许程序员将组织范式与适当的问题相匹配。 在软件工程中，为了简化或模块化程序，学习何时引入新类(而不是新函数)是一项重要的设计技能，值得仔细注意。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;像数据抽象中的函数一样，类在数据的使用和实现之间创建了抽象障碍。与分派字典一样，对象响应行为请求。 与可变数据结构一样，对象具有不能从全局环境直接访问的局部状态。&lt;/p&gt;
&lt;p&gt;面向对象编程的范例有自己的词汇表来支持对象隐喻。 我们已经看到，对象是一个具有方法和属性的数据值，可以通过&lt;mark style=&quot;background: #FF5582A6;&quot;&gt;点表示&lt;/mark&gt;法访问。 每个对象也有一个类型，称为它的类。 为了创建新的数据类型，我们实现了新的类。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="SICP" scheme="https://sajlle.github.io/tags/SICP/"/>
    
    <category term="OOP" scheme="https://sajlle.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>SQL声明式编程</title>
    <link href="https://sajlle.github.io/2023/04/15/SQL%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://sajlle.github.io/2023/04/15/SQL%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2023-04-15T14:06:57.000Z</published>
    <updated>2023-04-15T07:09:19.405Z</updated>
    
    <content type="html"><![CDATA[<p>SQL是声明性编程语言的一个例子。 语句不直接描述计算，而是描述某些计算的预期结果。数据库系统的查询解释器的角色是设计并执行一个计算过程来产生这样的结果。</p><p>这种交互与Python或Scheme的过程编程范式有本质区别。 在Python中，计算过程由程序员直接描述。 声明性语言抽象出过程细节，而专注于结果的形式。</p><span id="more"></span><p>SQL语言是标准化的，但是大多数数据库系统实现了该语言的一些自定义变体，这些变体被赋予了专有的特性。<br>union可以构造多行表，它将两个表的行组合在一起。在构造的表中使用左表的列名。行内的间距不会影响结果。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">38</span> <span class="keyword">as</span> latitude, <span class="number">122</span> <span class="keyword">as</span> longitude, "Berkeley" <span class="keyword">as</span> name <span class="keyword">union</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">42</span>, <span class="number">71</span>, "Cambridge" <span class="keyword">union</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">45</span>, <span class="number">93</span>, "Minneapolis";</span><br><span class="line"></span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley</span><br><span class="line"></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge</span><br><span class="line"></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis</span><br></pre></td></tr></tbody></table></figure><p>可以使用<mark style="background: #ABF7F7A6;">create table</mark>语句为表指定名称。虽然该语句也可以用于创建空表，但我们将重点关注为select语句定义的现有表提供名称的表单。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cities <span class="keyword">as</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">38</span> <span class="keyword">as</span> latitude, <span class="number">122</span> <span class="keyword">as</span> longitude, "Berkeley" <span class="keyword">as</span> name <span class="keyword">union</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">42</span>, <span class="number">71</span>, "Cambridge" <span class="keyword">union</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">45</span>, <span class="number">93</span>, "Minneapolis";```</span><br><span class="line"></span><br><span class="line">一旦指定了表的名称，就可以在<span class="keyword">select</span>语句中的<span class="keyword">from</span>子句中使用该名称。使用特殊的<span class="keyword">select</span> <span class="operator">*</span>表单可以显示表的所有列。</span><br><span class="line">```<span class="keyword">SQL</span></span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cities;</span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley</span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge</span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis</span><br></pre></td></tr></tbody></table></figure><h3 id="Select语句"><a href="#Select语句" class="headerlink" title="Select语句"></a>Select语句</h3><p>一个select语句可以通过列出单行中的值来定义一个新表，或者，更常见的是，通过使用from子句投影一个现有的表：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">column</span> description] <span class="keyword">from</span> [existing <span class="keyword">table</span> name]</span><br></pre></td></tr></tbody></table></figure><p>结果表的列由一个以逗号分隔的表达式列表来描述，每个表达式针对现有输入表的每一行进行计算。<br>例如，我们可以创建一个两列的表，根据每个城市离伯克利的北部或南部多远来描述它。 纬度每一度向北测量60海里。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>) <span class="keyword">from</span> cities;</span><br><span class="line">Berkeley<span class="operator">|</span><span class="number">0</span></span><br><span class="line">Cambridge<span class="operator">|</span><span class="number">240</span></span><br><span class="line">Minneapolis<span class="operator">|</span><span class="number">420</span></span><br></pre></td></tr></tbody></table></figure><p>列描述是一种语言中的表达式，它与Python共享许多属性:中缀操作符(如+和%)，内置函数(如abs和round)，以及描述求值顺序的圆括号。 这些表达式中的名称(如上面提到的latitude)计算为被投影行的列值。</p><p>可选地，每个表达式后面可以跟关键字as和列名。 当为整个表指定了一个名称时，为每个列指定一个名称通常是有帮助的，以便在以后的select语句中引用它。 由简单名称描述的列将自动命名。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> distances <span class="keyword">as</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>) <span class="keyword">as</span> distance <span class="keyword">from</span> cities;</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> distance<span class="operator">/</span><span class="number">5</span>, name <span class="keyword">from</span> distances;</span><br><span class="line"><span class="number">0</span><span class="operator">|</span>Berkeley</span><br><span class="line"><span class="number">48</span><span class="operator">|</span>Cambridge</span><br><span class="line"><span class="number">84</span><span class="operator">|</span>Minneapolis</span><br></pre></td></tr></tbody></table></figure><p>Where子句。select语句还可以包含带有筛选表达式的where子句。这个表达式过滤被投影的行。只有过滤表达式计算为真值的行才会用于在结果表中生成一行。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cold <span class="keyword">as</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> name <span class="keyword">from</span> cities <span class="keyword">where</span> latitude <span class="operator">&gt;</span> <span class="number">43</span>;</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> name, "is cold!" <span class="keyword">from</span> cold;</span><br><span class="line">Minneapolis<span class="operator">|</span><span class="keyword">is</span> cold<span class="operator">!</span></span><br></pre></td></tr></tbody></table></figure><p><strong>排序子句</strong>。select语句还可以表示对结果表的排序。order子句包含一个排序表达式，该表达式将为每个未筛选的行求值。该表达式的结果值用作结果表的排序标准。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> distance, name <span class="keyword">from</span> distances <span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">-</span>distance;</span><br><span class="line"><span class="number">84</span><span class="operator">|</span>Minneapolis</span><br><span class="line"><span class="number">48</span><span class="operator">|</span>Cambridge</span><br><span class="line"><span class="number">0</span><span class="operator">|</span>Berkeley</span><br></pre></td></tr></tbody></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>数据库通常包含多个表，查询可能需要包含在不同表中的信息来计算所需的结果。例如，我们可以用第二个表来描述不同城市的日平均高温。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> temps <span class="keyword">as</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> "Berkeley" <span class="keyword">as</span> city, <span class="number">68</span> <span class="keyword">as</span> temp <span class="keyword">union</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> "Chicago"         , <span class="number">59</span>         <span class="keyword">union</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">select</span> "Minneapolis"     , <span class="number">55</span>;</span><br></pre></td></tr></tbody></table></figure><p>通过将多个表合并成一个表来组合数据，这是数据库系统中的基本操作。 有许多连接的方法，都是密切相关的，但我们将集中在这篇文章的一种方法。 当表被连接时，结果表为输入表中的每个行组合包含一个新行。 如果两个表被连接，左边的表有m行，右边的表有n行，那么连接的表将有m*n行。 连接在SQL中是通过select语句的from子句中用逗号分隔表名来表示的。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cities, temps;</span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley<span class="operator">|</span>Berkeley<span class="operator">|</span><span class="number">68</span></span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley<span class="operator">|</span>Chicago<span class="operator">|</span><span class="number">59</span></span><br><span class="line"><span class="number">38</span><span class="operator">|</span><span class="number">122</span><span class="operator">|</span>Berkeley<span class="operator">|</span>Minneapolis<span class="operator">|</span><span class="number">55</span></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge<span class="operator">|</span>Berkeley<span class="operator">|</span><span class="number">68</span></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge<span class="operator">|</span>Chicago<span class="operator">|</span><span class="number">59</span></span><br><span class="line"><span class="number">42</span><span class="operator">|</span><span class="number">71</span><span class="operator">|</span>Cambridge<span class="operator">|</span>Minneapolis<span class="operator">|</span><span class="number">55</span></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis<span class="operator">|</span>Berkeley<span class="operator">|</span><span class="number">68</span></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis<span class="operator">|</span>Chicago<span class="operator">|</span><span class="number">59</span></span><br><span class="line"><span class="number">45</span><span class="operator">|</span><span class="number">93</span><span class="operator">|</span>Minneapolis<span class="operator">|</span>Minneapolis<span class="operator">|</span><span class="number">55</span></span><br></pre></td></tr></tbody></table></figure><p>连接通常伴随着一个<mark style="background: #ABF7F7A6;">where</mark>子句，该子句表示两个表之间的关系。例如，如果我们希望将数据收集到一个表中，该表允许我们关联纬度和温度，那么我们将从连接中选择在每个连接中提到相同城市的行。在cities表中，城市名称存储在名为name的列中。在temps表中，城市名称存储在名为city的列中。<mark style="background: #ABF7F7A6;">where子句可以选择连接表中这些值相等的行。</mark>在SQL中，<mark style="background: #ABF7F7A6;">用一个=符号来测试数字是否相等。</mark></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> name, latitude, temp <span class="keyword">from</span> cities, temps <span class="keyword">where</span> name <span class="operator">=</span> city;</span><br><span class="line">Berkeley<span class="operator">|</span><span class="number">38</span><span class="operator">|</span><span class="number">68</span></span><br><span class="line">Minneapolis<span class="operator">|</span><span class="number">45</span><span class="operator">|</span><span class="number">55</span></span><br></pre></td></tr></tbody></table></figure><p>我们在<mark style="background: #FF5582A6;">SQL中组合表的两种方法是join和union</mark>，这使得该语言具有强大的表达能力。</p><h3 id="解释SQL"><a href="#解释SQL" class="headerlink" title="解释SQL"></a>解释SQL</h3><p>每个表都有自己的一个类，表中的每一行都由其表的类的实例表示。 一行在表中的每一列中有一个属性，而表是一行的序列。<br>表的类是使用Python标准库的collections包中的namedtuple函数创建的，该函数返回tuple的新子类，为tuple中的每个元素命名。<br>考虑下一节中列出的cities表。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cities <span class="keyword">as</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">38</span> <span class="keyword">as</span> latitude, <span class="number">122</span> <span class="keyword">as</span> longitude, "Berkeley" <span class="keyword">as</span> name <span class="keyword">union</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">42</span>, <span class="number">71</span>, "Cambridge" <span class="keyword">union</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">45</span>, <span class="number">93</span>, "Minneapolis";</span><br></pre></td></tr></tbody></table></figure><p>下面的Python语句为这个表构造了一个表示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>CitiesRow = namedtuple(<span class="string">"Row"</span>, [<span class="string">"latitude"</span>, <span class="string">"longitude"</span>, <span class="string">"name"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cities = [CitiesRow(<span class="number">38</span>, <span class="number">122</span>, <span class="string">"Berkeley"</span>),</span><br><span class="line">CitiesRow(<span class="number">42</span>, <span class="number">71</span>, <span class="string">"Cambridge"</span>),</span><br><span class="line">CitiesRow(<span class="number">43</span>, <span class="number">93</span>, <span class="string">"Minneapolis"</span>)]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> distances <span class="keyword">as</span></span><br><span class="line">...<span class="operator">&gt;</span> <span class="keyword">select</span> name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>) <span class="keyword">as</span> distance <span class="keyword">from</span> cities;</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> distance<span class="operator">/</span><span class="number">5</span>, name <span class="keyword">from</span> distances;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span><span class="operator">|</span>Berkeley</span><br><span class="line"></span><br><span class="line"><span class="number">48</span><span class="operator">|</span>Cambridge</span><br><span class="line"></span><br><span class="line"><span class="number">84</span><span class="operator">|</span>Minneapolis```</span><br><span class="line"></span><br><span class="line">这个表是根据cities表的name和latitude列生成的。这个结果表可以通过在输入表的行上映射一个函数来生成，这个函数为每个CitiesRow返回一个DistancesRow。</span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> DistancesRow <span class="operator">=</span> namedtuple("Row", ["name", "distance"])</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> def <span class="keyword">select</span>(cities_row):</span><br><span class="line">   latitude, longitude, name <span class="operator">=</span> cities_row</span><br><span class="line">   <span class="keyword">return</span> DistancesRow(name, <span class="number">60</span><span class="operator">*</span><span class="built_in">abs</span>(latitude<span class="number">-38</span>))</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> distances <span class="operator">=</span> list(map(<span class="keyword">select</span>, cities))</span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> <span class="keyword">for</span> <span class="type">row</span> <span class="keyword">in</span> distances:</span><br><span class="line">   print(<span class="type">row</span>)</span><br><span class="line">   <span class="type">Row</span>(name<span class="operator">=</span><span class="string">'Berkeley'</span>, distance<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">   <span class="type">Row</span>(name<span class="operator">=</span><span class="string">'Cambridge'</span>, distance<span class="operator">=</span><span class="number">240</span>)</span><br><span class="line">   <span class="type">Row</span>(name<span class="operator">=</span><span class="string">'Minneapolis'</span>, distance<span class="operator">=</span><span class="number">300</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们的SQL解释器的设计概括了这种方法。select语句表示为由select语句的子句构造的类select的实例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span> class <span class="keyword">Select</span>:</span><br><span class="line">"""select [columns] from [tables] where [condition] order by [order]."""</span><br><span class="line"></span><br><span class="line">   def __init__(self, columns, tables, <span class="keyword">condition</span>, <span class="keyword">order</span>):</span><br><span class="line">      self.columns <span class="operator">=</span> columns</span><br><span class="line">      self.tables <span class="operator">=</span> tables</span><br><span class="line">      self.condition <span class="operator">=</span> <span class="keyword">condition</span></span><br><span class="line">      self.order <span class="operator">=</span> <span class="keyword">order</span></span><br><span class="line">      self.make_row <span class="operator">=</span> create_make_row(self.columns)</span><br><span class="line"></span><br><span class="line">   def <span class="keyword">execute</span>(self, env):</span><br><span class="line">   """Join, filter, sort, and map rows from tables to columns."""</span><br><span class="line">      from_rows <span class="operator">=</span> <span class="keyword">join</span>(self.tables, env)</span><br><span class="line">      filtered_rows <span class="operator">=</span> <span class="keyword">filter</span>(self.filter, from_rows)</span><br><span class="line">      ordered_rows <span class="operator">=</span> self.sort(filtered_rows)</span><br><span class="line">      <span class="keyword">return</span> map(self.make_row, ordered_rows)</span><br><span class="line"></span><br><span class="line">   def <span class="keyword">filter</span>(self, <span class="type">row</span>):</span><br><span class="line">      if self.condition:</span><br><span class="line">         <span class="keyword">return</span> eval(self.condition, <span class="type">row</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">   def sort(self, <span class="keyword">rows</span>):</span><br><span class="line">      if self.order:</span><br><span class="line">         <span class="keyword">return</span> sorted(<span class="keyword">rows</span>, key<span class="operator">=</span>lambda r: eval(self.order, r))</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">rows</span></span><br></pre></td></tr></tbody></table></figure><p>execute方法连接输入表、筛选并对结果行进行排序，然后在这些结果行上映射一个名为make_row的函数。make_row函数是通过调用create_make_row在Select构造函数中创建的，create_make_row是一个高阶函数，它为结果表创建一个新类，并定义如何将输入行投影到输出行。(这个函数的一个版本在sql中有更多的错误处理和特殊情况。)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL是声明性编程语言的一个例子。 语句不直接描述计算，而是描述某些计算的预期结果。数据库系统的查询解释器的角色是设计并执行一个计算过程来产生这样的结果。&lt;/p&gt;
&lt;p&gt;这种交互与Python或Scheme的过程编程范式有本质区别。 在Python中，计算过程由程序员直接描述。 声明性语言抽象出过程细节，而专注于结果的形式。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://sajlle.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="SQL" scheme="https://sajlle.github.io/tags/SQL/"/>
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>可变数据</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/</id>
    <published>2023-04-15T14:06:26.000Z</published>
    <updated>2023-04-15T06:15:46.718Z</updated>
    
    <content type="html"><![CDATA[<p>Identity <code>is</code> evaluates to True if both and evaluate to the same object<br>Equality <code>==</code> evaluates to True if both and evaluate to equal values Identical objects are always equal values<br>Identity is always Equality.</p><span id="more"></span><p>An immutable sequence may still change if it contains a mutable value as an element</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ([<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="Mutable-Default-Arguments-are-Dangerous"><a href="#Mutable-Default-Arguments-are-Dangerous" class="headerlink" title="Mutable Default Arguments are Dangerous"></a>Mutable Default Arguments are Dangerous</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">s=[]</span>):</span><br><span class="line"><span class="meta">... </span>    s.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">t = [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure><p>![[Pasted image 20230204165726.png]]<br>![[Pasted image 20230204170848.png]]</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">0</span>] = [<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:] = t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:<span class="number">0</span>] = [<span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:] = [<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">4</span>:] = <span class="number">4</span></span><br><span class="line">Error</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">5</span>:] = [<span class="number">55</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">55</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">5</span>] = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.pop()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">1</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">2</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[]</span><br></pre></td></tr></tbody></table></figure><h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">balance</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line"><span class="keyword">nonlocal</span> balance</span><br><span class="line">balance = balance - amount</span><br><span class="line"><span class="keyword">return</span> balance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw1</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line"><span class="comment"># nonlocal balance</span></span><br><span class="line">        balance = balance - amount <span class="comment"># 会报错，变量未赋值便访问</span></span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw2</span>(<span class="params">balance</span>): <span class="comment"># 不报错，但是返回值都一样</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        new_balance = balance</span><br><span class="line">        new_balance = new_balance - amount</span><br><span class="line">        <span class="keyword">return</span> new_balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw3</span>(<span class="params">balance</span>): <span class="comment"># 可变数据，无须nonlocal 即可实现nonlocal的效果</span></span><br><span class="line">    b = [balance]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        b[<span class="number">0</span>] = b[<span class="number">0</span>] - amount</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br></pre></td></tr></tbody></table></figure><p><strong>Effect</strong>: Future assignments to that name change its pre-existing binding in the first non-local frame of the current environment in which that name is bound. (对该名称的未来赋值会改变它在当前环境的第一个非本地框架中的已有的绑定，该名称在其中被绑定。)</p><p>Names listed in a nonlocal statement must refer to pre-existing bindings in an enclosing scope. Names listed in a nonlocal statement must not collide with pre-existing bindings in the local scope.<br>(在非本地语句中列出的名称必须是指在封闭的作用域中预先存在的绑定。<br>在非本地语句中列出的名字不能与本地作用域中预先存在的绑定相冲突。)</p><p>Python pre-computes which frame contains each name before executing the body of a function. Within the body of a function, all instances of a name must refer to the same frame.<br>(在执行一个函数的主体之前，Python 预先计算哪个帧包含每个名字。<br>在一个函数的主体中，一个名字的所有实例必须指向同一个框架。)</p><p>• Expressions are referentially transparent if substituting an expression with its value does not change the meaning of a program.<br>如果用表达式的值替换它不会改变程序的意义，那么表达式是透明的</p><ul><li>Mutation operations violate the condition of referential transparency because they do more than just return a value; they change the environment.<br>  突变操作违反了参照性透明的条件，因为它们不仅仅是返回一个值；它们改变了环境。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    x = <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">z</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> x</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> x+y+z</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = a(<span class="number">2</span>)</span><br><span class="line">total = b(<span class="number">3</span>) + b(<span class="number">4</span>) <span class="comment"># total = 22    b(3)=10</span></span><br><span class="line">total = <span class="number">10</span> + b(<span class="number">4</span>) <span class="comment"># total = 21</span></span><br></pre></td></tr></tbody></table></figure><p>上面案例中，两次结果不同的原因是第一次对h(x)两次调用，导致x递增1。用10替换<code>b(3)</code>之后，只调用了<code>h(x)</code>一次，<code>x</code>只递增了一次</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">6</span>)</span><br><span class="line">? Nothing</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = lst.pop(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">? [<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = lst, lst[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> lst</span><br><span class="line">? <span class="literal">True</span></span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == lst</span><br><span class="line">? <span class="literal">True</span></span><br><span class="line">-- OK! --</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> lst</span><br><span class="line">? <span class="literal">False</span></span><br><span class="line">-- OK! --</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Identity &lt;code&gt;is&lt;/code&gt; evaluates to True if both and evaluate to the same object&lt;br&gt;Equality &lt;code&gt;==&lt;/code&gt; evaluates to True if both and evaluate to equal values Identical objects are always equal values&lt;br&gt;Identity is always Equality.&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://sajlle.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://sajlle.github.io/tags/Python/"/>
    
    <category term="CS61A" scheme="https://sajlle.github.io/tags/CS61A/"/>
    
    <category term="笔记" scheme="https://sajlle.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何用hexo搭建一个博客？</title>
    <link href="https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
    <id>https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%9F/</id>
    <published>2023-04-15T10:31:09.000Z</published>
    <updated>2023-04-15T04:23:38.629Z</updated>
    
    <content type="html"><![CDATA[<h5 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h5><p>最近学了大半年前端，居然没有一个自己写东西的地方，实在是令人汗颜，这不，现在咱就开始把博客搭起来。</p><span id="more"></span><h5 id="使用工具："><a href="#使用工具：" class="headerlink" title="使用工具："></a>使用工具：</h5><ul><li>hexo</li><li>node.js</li><li>GitHub</li></ul><h3 id="搭建之前的准备工作"><a href="#搭建之前的准备工作" class="headerlink" title="搭建之前的准备工作"></a>搭建之前的准备工作</h3><ul><li>下载<a href="https://nodejs.org/en">node.js</a>, 软件版本不得低于10.13</li><li>下载<a href="https://git-scm.com/">Git</a></li></ul><h3 id="下载hexo"><a href="#下载hexo" class="headerlink" title="下载hexo"></a>下载hexo</h3><p>下载之后，使用npm安装hexo。</p><ul><li>在PowerShell中输入以下命令：<br>  <code>$ npm install hexo</code></li><li>把hexo目录下的node_modules添加到环境变量，输入以下命令：  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'PATH="$PATH:./node_modules/.bin"'</span> &gt;&gt; ~/.profile</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="下载配置文件"><a href="#下载配置文件" class="headerlink" title="下载配置文件"></a>下载配置文件</h3><p>安装好hexo之后，新建一个你打算存放blog的文件夹。</p><ul><li>输入命令初始化文件夹：<code>hexo init &lt;folder&gt;</code></li><li>进入该文件夹：<code>cd &lt;folder&gt;</code></li><li>在该文件夹下下载必要的文件：<code>npm install</code></li></ul><h3 id="配置网站"><a href="#配置网站" class="headerlink" title="配置网站"></a>配置网站</h3><ul><li>打开博客的配置文件<code>_config.yml</code><br>  位置：<code>folder/_config.yml</code></li><li>修改参数：<ul><li>把title换成网站标题</li><li>author换成您自己的名字</li><li>language换成中文<code>zh-CN</code></li></ul></li></ul><h3 id="配置主题（以NexT为例）"><a href="#配置主题（以NexT为例）" class="headerlink" title="配置主题（以NexT为例）"></a>配置主题（以NexT为例）</h3><h4 id="下载NexT"><a href="#下载NexT" class="headerlink" title="下载NexT"></a>下载NexT</h4><ul><li>在<code>folder</code>文件夹下，打开git bash</li><li>输入以下命令：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></tbody></table></figure><h4 id="配置NexT"><a href="#配置NexT" class="headerlink" title="配置NexT"></a>配置NexT</h4></li><li>打开站点配置文件，找到theme字段，把值更改为next</li></ul><h4 id="选择布局模型："><a href="#选择布局模型：" class="headerlink" title="选择布局模型："></a>选择布局模型：</h4><ul><li>打开主题配置文件</li><li>找到关键字Scheme, 选择你喜欢的类型，将该类型的注释去掉</li></ul><h4 id="添加标签页和分类页"><a href="#添加标签页和分类页" class="headerlink" title="添加标签页和分类页"></a>添加标签页和分类页</h4><ul><li>打开主题配置文件</li><li>搜索关键字menu</li><li>将tags, categories的注释去除</li><li>打开git bash, 输入:<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n page tags</span><br><span class="line">$ hexo n page categories</span><br></pre></td></tr></tbody></table></figure></li><li>打开<code>folder/source</code>，发现其新增了tags 和 categories文件夹</li><li>打开tags文件夹下的index.md文件，将title值改为分类，并在尾部添加type: categories</li><li>categories操作同上</li></ul><h4 id="更换头像"><a href="#更换头像" class="headerlink" title="更换头像"></a>更换头像</h4><ul><li>打开主题配置页面，搜索avatar关键字</li><li>将其url改为你喜欢的头像的地址<ul><li>其根目录为next主题下的source文件夹</li></ul></li><li>旋转头像和圆形头像按需开启</li></ul><h4 id="更改社交链接"><a href="#更改社交链接" class="headerlink" title="更改社交链接"></a>更改社交链接</h4><ul><li>主题配置文件中搜索social关键字</li><li>添加weibo链接：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weibo: 链接 || 图标（font awesome的图标，或者你自己找一个喜欢的）</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="添加友情链接"><a href="#添加友情链接" class="headerlink" title="添加友情链接"></a>添加友情链接</h4><ul><li>主题配置文件中搜索links</li><li>在links下添加你喜欢的链接<br>  -格式：<code>链接名称：链接</code></li></ul><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><ul><li>git bash中输入：<code>hexo new post 文章名称</code></li><li>打开博客目录中posts文件夹下的md文件</li><li>填写title（标题），tags（标签），categories（分类）</li><li>在结束预览的地方添加<!--more-->，以添加<strong>阅读全文</strong>按钮</li></ul><h4 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h4><ul><li>主题配置中搜索reward<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true(改为true)</span><br><span class="line">  animation: true(鼠标hover有文字旋转效果)</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: 添加收款图片（根目录是source）</span><br><span class="line">  alipay: /images/alipay.png</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="开启订阅功能"><a href="#开启订阅功能" class="headerlink" title="开启订阅功能"></a>开启订阅功能</h4><ul><li>主题配置文件搜索subscribe<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">follow_me:</span><br><span class="line">  #Twitter: https://twitter.com/username || fab fa-twitter</span><br><span class="line">  #Telegram: https://t.me/channel_name || fab fa-telegram</span><br><span class="line">  WeChat: /images/wechat_channel.png （添加公众号图片）|| fab fa-weixin（微信图标）</span><br><span class="line">  #RSS: /atom.xml || fa fa-rss</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="添加GitHub-corner"><a href="#添加GitHub-corner" class="headerlink" title="添加GitHub corner"></a>添加GitHub corner</h4><ul><li>进入<a href="https://tholman.com/github-corners/">GitHub Corners</a></li><li>复制你喜欢的效果</li><li>打开主题文件下的layout文件夹，找到layout.njk文件，并打开</li><li>搜索headband关键字，该div之下粘贴复制的代码<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body itemscope itemtype="http://schema.org/WebPage"{% if theme.motion.enable %} class="use-motion"{% endif %}&gt;</span><br><span class="line">  &lt;div class="headband"&gt;&lt;/div&gt;</span><br><span class="line">    复制的代码贴到这里</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="修改文章内链接样式"><a href="#修改文章内链接样式" class="headerlink" title="修改文章内链接样式"></a>修改文章内链接样式</h4><ul><li>主题文件夹下的source文件夹下的css文件夹下的common文件夹下的components文件夹下的post文件夹</li><li>打开post-body.styl文件</li><li>在文件的尾部添加以下代码（链接修改成蓝色，hover时改为橙色）<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>{ </span><br><span class="line">  <span class="attribute">color</span>: skyblue;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span>{</span><br><span class="line">    <span class="attribute">color</span>:orange;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="修改文章底部的tags标签"><a href="#修改文章底部的tags标签" class="headerlink" title="修改文章底部的tags标签"></a>修改文章底部的tags标签</h4><ul><li>默认是#标签</li><li>打开主题文件夹下的layout文件夹下的marco文件夹下的post.njk文件</li><li>搜索tags关键字，找到以下代码，将其中的#替换为<code>&lt;i class="fa-solid fa-tag"&gt;&lt;/i&gt;</code><ul><li>如果用font awesome的标签不显示，检查标签是否付费标签，付费标签不显示，免费的可以显示<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{%- if post.tags and post.tags.length %}</span><br><span class="line">  {%- set tag_indicate = '&lt;i class="fa fa-tag"&gt;&lt;/i&gt;' if theme.tag_icon else '把这里的#替换成你喜欢的标签' %}</span><br><span class="line">  &lt;div class="post-tags"&gt;</span><br><span class="line">    {%- for tag in post.tags.toArray() %}</span><br><span class="line">      &lt;a href="{{ url_for(tag.path) }}" rel="tag"&gt;{{ tag_indicate }} {{ tag.name }}&lt;/a&gt;</span><br><span class="line">    {%- endfor %}</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">{%- endif %}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h4><ul><li>在根目录运行 <code>$ npm install hexo-generator-searchdb --save</code></li><li>在博客配置文件添加以下代码：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></tbody></table></figure></li><li>主题配置文件搜索local_search, 把开关改为true<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="添加busuanzi统计功能"><a href="#添加busuanzi统计功能" class="headerlink" title="添加busuanzi统计功能"></a>添加busuanzi统计功能</h4><ul><li>主题配置文件搜索busuanzi, 开关改为true<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="隐藏底部驱动"><a href="#隐藏底部驱动" class="headerlink" title="隐藏底部驱动"></a>隐藏底部驱动</h4><ul><li>主题配置文件搜索power<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Powered by Hexo &amp; NexT</span><br><span class="line">  powered: false (改为false就不显示了)</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="增加字数统计和阅读时长"><a href="#增加字数统计和阅读时长" class="headerlink" title="增加字数统计和阅读时长"></a>增加字数统计和阅读时长</h4><ul><li>打开git bash 运行 <code>npm install hexo-word-counter</code></li><li>站点配置文件中添加以下内容，中文的话wpm改成300， awl设置为2<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275 </span><br><span class="line">  suffix: "mins."</span><br></pre></td></tr></tbody></table></figure></li><li>主题配置文件搜索 wordcount, 开关改为true<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/next-theme/hexo-word-counter</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_total: true</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="把博客部署到GitHub上"><a href="#把博客部署到GitHub上" class="headerlink" title="把博客部署到GitHub上"></a>把博客部署到GitHub上</h4><ul><li>注册github账号，新建仓库，仓库名称为username.github.io</li><li>打开git bash，添加用户名和邮箱<ul><li>输入<code>git config --global user.name 'yourname'</code></li><li>输入<code>git config --global user.email 'youremail'</code></li></ul></li><li>设置密钥<ul><li>输入<code>ssh-keygen -t rsa -C 'youremail@example.com'</code></li><li>进入.ssh文件夹，打开.pub文件，复制其中内容</li><li>打开GitHub，找到添加ssh密钥页面，复制公钥内容，点击确定</li><li>打开git bash 输入<code>ssh -T git@github.com</code>验证是否配置成功</li></ul></li><li>编辑博客配置文件<ul><li>打开博客配置文件，找到deployment部分<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: GitHub仓库的ssh地址</span><br><span class="line">    branch: main</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>部署博客<ul><li>打开git bash输入<code>hexo d</code></li><li>如果某些样式无法加载，试试清除浏览器缓存之后再加载</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;写在开头：&quot;&gt;&lt;a href=&quot;#写在开头：&quot; class=&quot;headerlink&quot; title=&quot;写在开头：&quot;&gt;&lt;/a&gt;写在开头：&lt;/h5&gt;&lt;p&gt;最近学了大半年前端，居然没有一个自己写东西的地方，实在是令人汗颜，这不，现在咱就开始把博客搭起来。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://sajlle.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="hexo" scheme="https://sajlle.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
